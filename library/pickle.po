# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2001-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
# Translators:
# Raphael Mendonça, 2019
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2019
# Adorilson Bezerra <adorilson@gmail.com>, 2019
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Python 3.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-05-02 13:45+0000\n"
"PO-Revision-Date: 2019-09-01 03:33+0000\n"
"Last-Translator: Adorilson Bezerra <adorilson@gmail.com>, 2019\n"
"Language-Team: Portuguese (Brazil) (https://www.transifex.com/python-doc/"
"teams/5390/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/pickle.rst:2
msgid ":mod:`pickle` --- Python object serialization"
msgstr ":mod:`pickle` --- Serialização de objetos Python"

#: ../../library/pickle.rst:10
msgid "**Source code:** :source:`Lib/pickle.py`"
msgstr "**Código Fonte:** :source:`Lib/pickle.py`"

#: ../../library/pickle.rst:22
msgid ""
"The :mod:`pickle` module implements binary protocols for serializing and de-"
"serializing a Python object structure.  *\"Pickling\"* is the process "
"whereby a Python object hierarchy is converted into a byte stream, and *"
"\"unpickling\"* is the inverse operation, whereby a byte stream (from a :"
"term:`binary file` or :term:`bytes-like object`) is converted back into an "
"object hierarchy.  Pickling (and unpickling) is alternatively known as "
"\"serialization\", \"marshalling,\" [#]_ or \"flattening\"; however, to "
"avoid confusion, the terms used here are \"pickling\" and \"unpickling\"."
msgstr ""
"O módulo :mod:`pickle` implementa protocolos binários para serializar e "
"desserializar uma estrutura de objeto Python. *\"Pickling\"* é o processo "
"pelo qual uma hierarquia de objetos Python é convertida em um fluxo de "
"bytes, e *\"unpickling\"* é a operação inversa, em que um fluxo de bytes (de "
"um :term:`arquivo binário` ou :term:`objeto byte ou similar`) é convertido "
"de volta em uma hierarquia de objetos. Pickling (e unpickling) é "
"alternativamente conhecido como \"serialização\", \"marshalling\" [#]_ ou "
"\"flattening\"; no entanto, para evitar confusão, os termos usados ​​aqui são "
"\"pickling\" e \"unpickling\"."

#: ../../library/pickle.rst:33
msgid ""
"The :mod:`pickle` module is not secure against erroneous or maliciously "
"constructed data.  Never unpickle data received from an untrusted or "
"unauthenticated source."
msgstr ""

#: ../../library/pickle.rst:39
msgid "Relationship to other Python modules"
msgstr "Relacionamento com outros módulos Python"

#: ../../library/pickle.rst:42
msgid "Comparison with ``marshal``"
msgstr "Comparação com ``marshal``"

#: ../../library/pickle.rst:44
msgid ""
"Python has a more primitive serialization module called :mod:`marshal`, but "
"in general :mod:`pickle` should always be the preferred way to serialize "
"Python objects.  :mod:`marshal` exists primarily to support Python's :file:`."
"pyc` files."
msgstr ""
"Python tem um módulo de serialização mais primitivo chamado :mod:`marshal`, "
"mas em geral :mod:`pickle` deve ser sempre a forma preferida de serializar "
"objetos Python. :mod:`marshal` existe principalmente para oferecer suporte a "
"arquivos :file:`.pyc` do Python."

#: ../../library/pickle.rst:49
msgid ""
"The :mod:`pickle` module differs from :mod:`marshal` in several significant "
"ways:"
msgstr ""
"O módulo :mod:`pickle` difere do :mod:`marshal` de várias maneiras "
"significativas:"

#: ../../library/pickle.rst:51
msgid ""
"The :mod:`pickle` module keeps track of the objects it has already "
"serialized, so that later references to the same object won't be serialized "
"again. :mod:`marshal` doesn't do this."
msgstr ""
"O módulo :mod:`pickle` mantém o controle dos objetos que já serializou, para "
"que referências posteriores ao mesmo objeto não sejam serializadas "
"novamente. :mod:`marshal` não faz isso."

#: ../../library/pickle.rst:55
msgid ""
"This has implications both for recursive objects and object sharing.  "
"Recursive objects are objects that contain references to themselves.  These "
"are not handled by marshal, and in fact, attempting to marshal recursive "
"objects will crash your Python interpreter.  Object sharing happens when "
"there are multiple references to the same object in different places in the "
"object hierarchy being serialized.  :mod:`pickle` stores such objects only "
"once, and ensures that all other references point to the master copy.  "
"Shared objects remain shared, which can be very important for mutable "
"objects."
msgstr ""
"Isso tem implicações tanto para objetos recursivos quanto para "
"compartilhamento de objetos. Objetos recursivos são objetos que contêm "
"referências a si mesmos. Eles não são tratados pelo marshal e, de fato, "
"tentar usar marshal em objetos recursivos irá travar seu interpretador "
"Python. O compartilhamento de objetos ocorre quando há várias referências ao "
"mesmo objeto em locais diferentes na hierarquia de objetos sendo "
"serializados. :mod:`pickle` armazena tais objetos apenas uma vez, e garante "
"que todas as outras referências apontem para a cópia mestre. Os objetos "
"compartilhados permanecem compartilhados, o que pode ser muito importante "
"para objetos mutáveis."

#: ../../library/pickle.rst:64
msgid ""
":mod:`marshal` cannot be used to serialize user-defined classes and their "
"instances.  :mod:`pickle` can save and restore class instances "
"transparently, however the class definition must be importable and live in "
"the same module as when the object was stored."
msgstr ""
":mod:`marshal` não pode ser usado para serializar classes definidas pelo "
"usuário e suas instâncias. :mod:`pickle` pode salvar e restaurar instâncias "
"de classe de forma transparente, no entanto, a definição de classe deve ser "
"importável e viver no mesmo módulo de quando o objeto foi armazenado."

#: ../../library/pickle.rst:69
msgid ""
"The :mod:`marshal` serialization format is not guaranteed to be portable "
"across Python versions.  Because its primary job in life is to support :file:"
"`.pyc` files, the Python implementers reserve the right to change the "
"serialization format in non-backwards compatible ways should the need arise. "
"The :mod:`pickle` serialization format is guaranteed to be backwards "
"compatible across Python releases provided a compatible pickle protocol is "
"chosen and pickling and unpickling code deals with Python 2 to Python 3 type "
"differences if your data is crossing that unique breaking change language "
"boundary."
msgstr ""
"O formato de serialização do :mod:`marshal` não tem garantia de "
"portabilidade entre as versões do Python. Como sua principal tarefa em vida "
"é oferecer suporte a arquivos :file:`.pyc`, os implementadores do Python se "
"reservam o direito de alterar o formato de serialização de maneiras não "
"compatíveis com versões anteriores, caso haja necessidade. O formato de "
"serialização do :mod:`pickle` tem a garantia de ser compatível com versões "
"anteriores em todas as versões do Python, desde que um protocolo pickle "
"compatível seja escolhido e o código de pickling e unpickling lide com "
"diferenças de tipo Python 2 a Python 3 se seus dados estiverem cruzando "
"aquele limite de mudança de linguagem exclusivo."

#: ../../library/pickle.rst:79
msgid "Comparison with ``json``"
msgstr "Comparação com ``json``"

#: ../../library/pickle.rst:81
msgid ""
"There are fundamental differences between the pickle protocols and `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"
msgstr ""
"Existem diferenças fundamentais entre os protocolos pickle e `JSON "
"(JavaScript Object Notation) <http://json.org>`_:"

#: ../../library/pickle.rst:84
msgid ""
"JSON is a text serialization format (it outputs unicode text, although most "
"of the time it is then encoded to ``utf-8``), while pickle is a binary "
"serialization format;"
msgstr ""
"JSON é um formato de serialização de texto (ele produz texto unicode, embora "
"na maioria das vezes seja codificado para ``utf-8``), enquanto pickle é um "
"formato de serialização binário;"

#: ../../library/pickle.rst:88
msgid "JSON is human-readable, while pickle is not;"
msgstr "JSON é legível por humanos, enquanto pickle não é;"

#: ../../library/pickle.rst:90
msgid ""
"JSON is interoperable and widely used outside of the Python ecosystem, while "
"pickle is Python-specific;"
msgstr ""
"JSON é interoperável e amplamente usado fora do ecossistema Python, enquanto "
"pickle é específico para Python;"

#: ../../library/pickle.rst:93
msgid ""
"JSON, by default, can only represent a subset of the Python built-in types, "
"and no custom classes; pickle can represent an extremely large number of "
"Python types (many of them automatically, by clever usage of Python's "
"introspection facilities; complex cases can be tackled by implementing :ref:"
"`specific object APIs <pickle-inst>`)."
msgstr ""

#: ../../library/pickle.rst:100
msgid ""
"The :mod:`json` module: a standard library module allowing JSON "
"serialization and deserialization."
msgstr ""
"O módulo :mod:`json`: um módulo de biblioteca padrão que permite a "
"serialização e desserialização JSON."

#: ../../library/pickle.rst:107
msgid "Data stream format"
msgstr "Formato de fluxo de dados"

#: ../../library/pickle.rst:112
msgid ""
"The data format used by :mod:`pickle` is Python-specific.  This has the "
"advantage that there are no restrictions imposed by external standards such "
"as JSON or XDR (which can't represent pointer sharing); however it means "
"that non-Python programs may not be able to reconstruct pickled Python "
"objects."
msgstr ""
"O formato de dados usado por :mod:`pickle` é específico do Python. Isso tem "
"a vantagem de não haver restrições impostas por padrões externos, como JSON "
"ou XDR (que não podem representar o compartilhamento de ponteiro); no "
"entanto, isso significa que programas não Python podem não ser capazes de "
"reconstruir objetos Python conservados."

#: ../../library/pickle.rst:117
msgid ""
"By default, the :mod:`pickle` data format uses a relatively compact binary "
"representation.  If you need optimal size characteristics, you can "
"efficiently :doc:`compress <archiving>` pickled data."
msgstr ""
"Por padrão, o formato de dados do :mod:`pickle` usa uma representação "
"binária relativamente compacta. Se você precisa de características de "
"tamanho ideal, pode com eficiência :doc:`comprimir <archiving>` dados "
"processados com pickle."

#: ../../library/pickle.rst:121
msgid ""
"The module :mod:`pickletools` contains tools for analyzing data streams "
"generated by :mod:`pickle`.  :mod:`pickletools` source code has extensive "
"comments about opcodes used by pickle protocols."
msgstr ""
"O módulo :mod:`pickletools` contém ferramentas para analisar fluxos de dados "
"gerados por :mod:`pickle`. O código-fonte do :mod:`pickletools` tem extensos "
"comentários sobre códigos de operações usados ​​por protocolos de pickle."

#: ../../library/pickle.rst:125
msgid ""
"There are currently 5 different protocols which can be used for pickling. "
"The higher the protocol used, the more recent the version of Python needed "
"to read the pickle produced."
msgstr ""

#: ../../library/pickle.rst:129
msgid ""
"Protocol version 0 is the original \"human-readable\" protocol and is "
"backwards compatible with earlier versions of Python."
msgstr ""
"A versão 0 do protocolo é o protocolo original \"legível por humanos\" e é "
"compatível com versões anteriores do Python."

#: ../../library/pickle.rst:132
msgid ""
"Protocol version 1 is an old binary format which is also compatible with "
"earlier versions of Python."
msgstr ""
"A versão 1 do protocolo é um formato binário antigo que também é compatível "
"com versões anteriores do Python."

#: ../../library/pickle.rst:135
msgid ""
"Protocol version 2 was introduced in Python 2.3.  It provides much more "
"efficient pickling of :term:`new-style class`\\es.  Refer to :pep:`307` for "
"information about improvements brought by protocol 2."
msgstr ""
"A versão 2 do protocolo foi introduzida no Python 2.3. Ela fornece uma "
"separação muito mais eficiente de :term:`classes estilo novo <new-style "
"class>`. Consulte :pep:`307` para obter informações sobre as melhorias "
"trazidas pelo protocolo 2."

#: ../../library/pickle.rst:139
msgid ""
"Protocol version 3 was added in Python 3.0.  It has explicit support for :"
"class:`bytes` objects and cannot be unpickled by Python 2.x.  This is the "
"default protocol, and the recommended protocol when compatibility with other "
"Python 3 versions is required."
msgstr ""

#: ../../library/pickle.rst:144
msgid ""
"Protocol version 4 was added in Python 3.4.  It adds support for very large "
"objects, pickling more kinds of objects, and some data format "
"optimizations.  Refer to :pep:`3154` for information about improvements "
"brought by protocol 4."
msgstr ""

#: ../../library/pickle.rst:150
msgid ""
"Serialization is a more primitive notion than persistence; although :mod:"
"`pickle` reads and writes file objects, it does not handle the issue of "
"naming persistent objects, nor the (even more complicated) issue of "
"concurrent access to persistent objects.  The :mod:`pickle` module can "
"transform a complex object into a byte stream and it can transform the byte "
"stream into an object with the same internal structure.  Perhaps the most "
"obvious thing to do with these byte streams is to write them onto a file, "
"but it is also conceivable to send them across a network or store them in a "
"database.  The :mod:`shelve` module provides a simple interface to pickle "
"and unpickle objects on DBM-style database files."
msgstr ""
"A serialização é uma noção mais primitiva do que a persistência; embora o :"
"mod:`pickle` leia e escreva objetos de arquivo, ele não lida com a questão "
"de nomear objetos persistentes, nem a questão (ainda mais complicada) de "
"acesso simultâneo a objetos persistentes. O módulo :mod:`pickle` pode "
"transformar um objeto complexo em um fluxo de bytes e pode transformar o "
"fluxo de bytes em um objeto com a mesma estrutura interna. Talvez a coisa "
"mais óbvia a fazer com esses fluxos de bytes seja escrevê-los em um arquivo, "
"mas também é concebível enviá-los através de uma rede ou armazená-los em um "
"banco de dados. O módulo :mod:`shelve` fornece uma interface simples para "
"fazer pickle e unpickle de objetos em arquivos de banco de dados no estilo "
"DBM."

#: ../../library/pickle.rst:163
msgid "Module Interface"
msgstr "Interface do módulo"

#: ../../library/pickle.rst:165
msgid ""
"To serialize an object hierarchy, you simply call the :func:`dumps` "
"function. Similarly, to de-serialize a data stream, you call the :func:"
"`loads` function. However, if you want more control over serialization and "
"de-serialization, you can create a :class:`Pickler` or an :class:`Unpickler` "
"object, respectively."
msgstr ""
"Para serializar uma hierarquia de objeto, você simplesmente chama a função :"
"func:`dumps`. Da mesma forma, para desserializar um fluxo de dados, você "
"chama a função :func:`loads`. No entanto, se você quiser mais controle sobre "
"a serialização e desserialização, pode criar um objeto :class:`Pickler` ou :"
"class:`Unpickler`, respectivamente."

#: ../../library/pickle.rst:170
msgid "The :mod:`pickle` module provides the following constants:"
msgstr "O módulo :mod:`pickle` fornece as seguintes constantes:"

#: ../../library/pickle.rst:175
msgid ""
"An integer, the highest :ref:`protocol version <pickle-protocols>` "
"available.  This value can be passed as a *protocol* value to functions :"
"func:`dump` and :func:`dumps` as well as the :class:`Pickler` constructor."
msgstr ""
"Um inteiro, a mais alta :ref:`versão de protocolo <pickle-protocols>` "
"disponível. Este valor pode ser passado como um valor de *protocol* para as "
"funções :func:`dump` e :func:`dumps`, bem como o construtor de :class:"
"`Pickler`."

#: ../../library/pickle.rst:182
msgid ""
"An integer, the default :ref:`protocol version <pickle-protocols>` used for "
"pickling.  May be less than :data:`HIGHEST_PROTOCOL`.  Currently the default "
"protocol is 3, a new protocol designed for Python 3."
msgstr ""

#: ../../library/pickle.rst:187
msgid ""
"The :mod:`pickle` module provides the following functions to make the "
"pickling process more convenient:"
msgstr ""
"O módulo :mod:`pickle` fornece as seguintes funções para tornar o processo "
"de pickling mais conveniente:"

#: ../../library/pickle.rst:192
msgid ""
"Write the pickled representation of the object *obj* to the open :term:`file "
"object` *file*.  This is equivalent to ``Pickler(file, protocol).dump(obj)``."
msgstr ""
"Escreve a representação após fazer pickling do objeto *obj* no :term:`objeto "
"arquivo` aberto *file*. Isso é equivalente a ``Pickler(file, protocol)."
"dump(obj)``."

#: ../../library/pickle.rst:196 ../../library/pickle.rst:298
msgid ""
"The optional *protocol* argument, an integer, tells the pickler to use the "
"given protocol; supported protocols are 0 to :data:`HIGHEST_PROTOCOL`. If "
"not specified, the default is :data:`DEFAULT_PROTOCOL`.  If a negative "
"number is specified, :data:`HIGHEST_PROTOCOL` is selected."
msgstr ""
"O argumento opcional *protocol*, um inteiro, diz ao pickler para usar o "
"protocolo fornecido; os protocolos suportados são de 0 a :data:"
"`HIGHEST_PROTOCOL`. Se não for especificado, o padrão é :data:"
"`DEFAULT_PROTOCOL`. Se um número negativo for especificado, :data:"
"`HIGHEST_PROTOCOL` é selecionado."

#: ../../library/pickle.rst:201 ../../library/pickle.rst:303
msgid ""
"The *file* argument must have a write() method that accepts a single bytes "
"argument.  It can thus be an on-disk file opened for binary writing, an :"
"class:`io.BytesIO` instance, or any other custom object that meets this "
"interface."
msgstr ""
"O argumento *file* deve ter um método write() que aceite um argumento de um "
"único byte. Portanto, pode ser um arquivo em disco aberto para escrita "
"binária, uma instância :class:`io.BytesIO` ou qualquer outro objeto "
"personalizado que atenda a esta interface."

#: ../../library/pickle.rst:206 ../../library/pickle.rst:308
msgid ""
"If *fix_imports* is true and *protocol* is less than 3, pickle will try to "
"map the new Python 3 names to the old module names used in Python 2, so that "
"the pickle data stream is readable with Python 2."
msgstr ""
"Se *fix_imports* for verdadeiro e *protocolo* for menor que 3, pickle "
"tentará mapear os novos nomes do Python 3 para os nomes dos módulos antigos "
"usados no Python 2, de modo que o fluxo de dados pickle seja legível com o "
"Python 2."

#: ../../library/pickle.rst:212
msgid ""
"Return the pickled representation of the object *obj* as a :class:`bytes` "
"object, instead of writing it to a file."
msgstr ""
"Retorna a representação em após fazer pickling do objeto *obj* como um "
"objeto :class:`bytes`, ao invés de escrevê-lo em um arquivo."

#: ../../library/pickle.rst:215
msgid ""
"Arguments *protocol* and *fix_imports* have the same meaning as in :func:"
"`dump`."
msgstr ""

#: ../../library/pickle.rst:220
msgid ""
"Read the pickled representation of an object from the open :term:`file "
"object` *file* and return the reconstituted object hierarchy specified "
"therein. This is equivalent to ``Unpickler(file).load()``."
msgstr ""
"Lê a representação serializada com pickle de um objeto a partir de :term:"
"`objeto arquivo` aberto *file* e retorna a hierarquia de objeto "
"reconstituído especificada nele. Isso é equivalente a ``Unpickler(file)."
"load()``."

#: ../../library/pickle.rst:224 ../../library/pickle.rst:250
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed.  Bytes past the pickled representation of the object are "
"ignored."
msgstr ""
"A versão do protocolo pickle é detectada automaticamente, portanto, nenhum "
"argumento de protocolo é necessário. Bytes após a representação serializada "
"com pickle do objeto são ignorados."

#: ../../library/pickle.rst:228
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  Both "
"methods should return bytes.  Thus *file* can be an on-disk file opened for "
"binary reading, an :class:`io.BytesIO` object, or any other custom object "
"that meets this interface."
msgstr ""

#: ../../library/pickle.rst:234 ../../library/pickle.rst:254
msgid ""
"Optional keyword arguments are *fix_imports*, *encoding* and *errors*, which "
"are used to control compatibility support for pickle stream generated by "
"Python 2.  If *fix_imports* is true, pickle will try to map the old Python 2 "
"names to the new names used in Python 3.  The *encoding* and *errors* tell "
"pickle how to decode 8-bit string instances pickled by Python 2; these "
"default to 'ASCII' and 'strict', respectively.  The *encoding* can be "
"'bytes' to read these 8-bit string instances as bytes objects. Using "
"``encoding='latin1'`` is required for unpickling NumPy arrays and instances "
"of :class:`~datetime.datetime`, :class:`~datetime.date` and :class:"
"`~datetime.time` pickled by Python 2."
msgstr ""

#: ../../library/pickle.rst:247
msgid ""
"Return the reconstituted object hierarchy of the pickled representation "
"*data* of an object. *data* must be a :term:`bytes-like object`."
msgstr ""
"Retorna a hierarquia de objeto reconstituído da representação serializada "
"com pickle *data* de um objeto. *data* deve ser um :term:`objeto byte ou "
"similar`."

#: ../../library/pickle.rst:266
msgid "The :mod:`pickle` module defines three exceptions:"
msgstr "O módulo :mod:`pickle` define três exceções:"

#: ../../library/pickle.rst:270
msgid ""
"Common base class for the other pickling exceptions.  It inherits :exc:"
"`Exception`."
msgstr ""
"Classe base comum para as outras exceções de serialização com pickle. Herda :"
"exc:`Exception`."

#: ../../library/pickle.rst:275
msgid ""
"Error raised when an unpicklable object is encountered by :class:`Pickler`. "
"It inherits :exc:`PickleError`."
msgstr ""
"Erro levantado quando um objeto não serializável com pickle é encontrado "
"por :class:`Pickler`. Herda :exc:`PickleError`."

#: ../../library/pickle.rst:278
msgid ""
"Refer to :ref:`pickle-picklable` to learn what kinds of objects can be "
"pickled."
msgstr ""
"Consulte :ref:`pickle-picklable` para saber quais tipos de objetos podem ser "
"serializados com pickle."

#: ../../library/pickle.rst:283
msgid ""
"Error raised when there is a problem unpickling an object, such as a data "
"corruption or a security violation.  It inherits :exc:`PickleError`."
msgstr ""
"Erro levantado quando há um problema ao desserializar com pickle um objeto, "
"como dados corrompidos ou violação de segurança. Herda :exc:`PickleError`."

#: ../../library/pickle.rst:286
msgid ""
"Note that other exceptions may also be raised during unpickling, including "
"(but not necessarily limited to) AttributeError, EOFError, ImportError, and "
"IndexError."
msgstr ""
"Observe que outras exceções também podem ser levantadas durante a "
"desserialização com pickle, incluindo (mas não necessariamente limitado a) "
"AttributeError, EOFError, ImportError e IndexError."

#: ../../library/pickle.rst:291
msgid ""
"The :mod:`pickle` module exports two classes, :class:`Pickler` and :class:"
"`Unpickler`:"
msgstr ""

#: ../../library/pickle.rst:296
msgid "This takes a binary file for writing a pickle data stream."
msgstr "Isso leva um arquivo binário a escrever um fluxo de dados pickle."

#: ../../library/pickle.rst:314
msgid ""
"Write the pickled representation of *obj* to the open file object given in "
"the constructor."
msgstr ""
"Escreve a representação serializada em pickle de *obj* no objeto arquivo "
"aberto fornecido no construtor."

#: ../../library/pickle.rst:319
msgid "Do nothing by default.  This exists so a subclass can override it."
msgstr ""
"Não faz nada por padrão. Isso existe para que uma subclasse possa substituí-"
"lo."

#: ../../library/pickle.rst:321
msgid ""
"If :meth:`persistent_id` returns ``None``, *obj* is pickled as usual.  Any "
"other value causes :class:`Pickler` to emit the returned value as a "
"persistent ID for *obj*.  The meaning of this persistent ID should be "
"defined by :meth:`Unpickler.persistent_load`.  Note that the value returned "
"by :meth:`persistent_id` cannot itself have a persistent ID."
msgstr ""
"Se :meth:`persistent_id` retornar ``None``, *obj* é serializado com pickle "
"como de costume. Qualquer outro valor faz com que :class:`Pickler` emita o "
"valor retornado como um ID persistente para *obj*. O significado deste ID "
"persistente deve ser definido por :meth:`Unpickler.persistent_load`. Observe "
"que o valor retornado por :meth:`persistent_id` não pode ter um ID "
"persistente."

#: ../../library/pickle.rst:327 ../../library/pickle.rst:399
msgid "See :ref:`pickle-persistent` for details and examples of uses."
msgstr "Consulte :ref:`pickle-persistent` para detalhes e exemplos de usos."

#: ../../library/pickle.rst:331
msgid ""
"A pickler object's dispatch table is a registry of *reduction functions* of "
"the kind which can be declared using :func:`copyreg.pickle`.  It is a "
"mapping whose keys are classes and whose values are reduction functions.  A "
"reduction function takes a single argument of the associated class and "
"should conform to the same interface as a :meth:`__reduce__` method."
msgstr ""
"A tabela de despacho de um objeto pickler é um registro de *funções de "
"redução* do tipo que pode ser declarado usando :func:`copyreg.pickle`. É um "
"mapeamento cujas chaves são classes e cujos valores são funções de redução. "
"Uma função de redução leva um único argumento da classe associada e deve "
"estar de acordo com a mesma interface de um método :meth:`__reduce__`."

#: ../../library/pickle.rst:339
msgid ""
"By default, a pickler object will not have a :attr:`dispatch_table` "
"attribute, and it will instead use the global dispatch table managed by the :"
"mod:`copyreg` module. However, to customize the pickling for a specific "
"pickler object one can set the :attr:`dispatch_table` attribute to a dict-"
"like object.  Alternatively, if a subclass of :class:`Pickler` has a :attr:"
"`dispatch_table` attribute then this will be used as the default dispatch "
"table for instances of that class."
msgstr ""
"Por padrão, um objeto pickler não terá um atributo :attr:`dispatch_table`, e "
"em vez disso usará a tabela de despacho global gerenciada pelo módulo :mod:"
"`copyreg`. No entanto, para personalizar a serialização com pickle de um "
"objeto pickler específico, pode-se definir o atributo :attr:`dispatch_table` "
"para um objeto do tipo dict. Alternativamente, se uma subclasse de :class:"
"`Pickler` tem um atributo :attr:`dispatch_table` então ele será usado como a "
"tabela de despacho padrão para instâncias daquela classe."

#: ../../library/pickle.rst:348
msgid "See :ref:`pickle-dispatch` for usage examples."
msgstr "Consulte :ref:`pickle-dispatch` para exemplos de uso."

#: ../../library/pickle.rst:354
msgid ""
"Deprecated. Enable fast mode if set to a true value.  The fast mode disables "
"the usage of memo, therefore speeding the pickling process by not generating "
"superfluous PUT opcodes.  It should not be used with self-referential "
"objects, doing otherwise will cause :class:`Pickler` to recurse infinitely."
msgstr ""
"Descontinuado. Ative o modo rápido se definido como um valor verdadeiro. O "
"modo rápido desabilita o uso de memo, portanto, agilizando o processo de "
"serialização com pickle por não gerar códigos de operação PUT supérfluos. "
"Ele não deve ser usado com objetos autorreferenciais, fazer o contrário fará "
"com que :class:`Pickler` recorra infinitamente."

#: ../../library/pickle.rst:360
msgid "Use :func:`pickletools.optimize` if you need more compact pickles."
msgstr ""
"Use :func:`pickletools.optimize` se você precisar de serializações com "
"pickle mais compactas."

#: ../../library/pickle.rst:365
msgid "This takes a binary file for reading a pickle data stream."
msgstr "Recebe um arquivo binário para ler um fluxo de dados pickle."

#: ../../library/pickle.rst:367
msgid ""
"The protocol version of the pickle is detected automatically, so no protocol "
"argument is needed."
msgstr ""
"A versão do protocolo do pickle é detectada automaticamente, portanto, "
"nenhum argumento de protocolo é necessário."

#: ../../library/pickle.rst:370
msgid ""
"The argument *file* must have two methods, a read() method that takes an "
"integer argument, and a readline() method that requires no arguments.  Both "
"methods should return bytes.  Thus *file* can be an on-disk file object "
"opened for binary reading, an :class:`io.BytesIO` object, or any other "
"custom object that meets this interface."
msgstr ""

#: ../../library/pickle.rst:376
msgid ""
"Optional keyword arguments are *fix_imports*, *encoding* and *errors*, which "
"are used to control compatibility support for pickle stream generated by "
"Python 2.  If *fix_imports* is true, pickle will try to map the old Python 2 "
"names to the new names used in Python 3.  The *encoding* and *errors* tell "
"pickle how to decode 8-bit string instances pickled by Python 2; these "
"default to 'ASCII' and 'strict', respectively.  The *encoding* can be "
"'bytes' to read these 8-bit string instances as bytes objects."
msgstr ""

#: ../../library/pickle.rst:386
msgid ""
"Read the pickled representation of an object from the open file object given "
"in the constructor, and return the reconstituted object hierarchy specified "
"therein.  Bytes past the pickled representation of the object are ignored."
msgstr ""
"Lê a representação serializada com pickle de um objeto a partir do objeto "
"arquivo aberto fornecido no construtor e retorna a hierarquia de objeto "
"reconstituído especificada nele. Os bytes após a representação serializada "
"com pickle do objeto são ignorados."

#: ../../library/pickle.rst:393
msgid "Raise an :exc:`UnpicklingError` by default."
msgstr "Levanta um :exc:`UnpicklingError` por padrão."

#: ../../library/pickle.rst:395
msgid ""
"If defined, :meth:`persistent_load` should return the object specified by "
"the persistent ID *pid*.  If an invalid persistent ID is encountered, an :"
"exc:`UnpicklingError` should be raised."
msgstr ""
"Se definido, :meth:`persistent_load` deve retornar o objeto especificado "
"pelo ID persistente *pid*. Se um ID persistente inválido for encontrado, "
"uma :exc:`UnpicklingError` deve ser levantada."

#: ../../library/pickle.rst:403
msgid ""
"Import *module* if necessary and return the object called *name* from it, "
"where the *module* and *name* arguments are :class:`str` objects.  Note, "
"unlike its name suggests, :meth:`find_class` is also used for finding "
"functions."
msgstr ""
"Importa *module* se necessário e retorna o objeto chamado *name* dele, onde "
"os argumentos *module* e *name* são objetos :classe:`str`. Observe, ao "
"contrário do que seu nome sugere, :meth:`find_class` também é usado para "
"encontrar funções."

#: ../../library/pickle.rst:408
msgid ""
"Subclasses may override this to gain control over what type of objects and "
"how they can be loaded, potentially reducing security risks. Refer to :ref:"
"`pickle-restrict` for details."
msgstr ""
"As subclasses podem substituir isso para obter controle sobre quais tipos de "
"objetos e como eles podem ser carregados, reduzindo potencialmente os riscos "
"de segurança. Confira :ref:`pickle-restrict` para detalhes."

#: ../../library/pickle.rst:416
msgid "What can be pickled and unpickled?"
msgstr "O que pode ser serializado e desserializado com pickle?"

#: ../../library/pickle.rst:418
msgid "The following types can be pickled:"
msgstr "Os seguintes tipos podem ser serializados com pickle:"

#: ../../library/pickle.rst:420
msgid "``None``, ``True``, and ``False``"
msgstr "``None``, ``True``, e ``False``"

#: ../../library/pickle.rst:422
msgid "integers, floating point numbers, complex numbers"
msgstr "inteiros, números de ponto flutuante, números complexos"

#: ../../library/pickle.rst:424
msgid "strings, bytes, bytearrays"
msgstr "strings, bytes, bytearrays"

#: ../../library/pickle.rst:426
msgid "tuples, lists, sets, and dictionaries containing only picklable objects"
msgstr ""
"tuplas, listas, conjuntos e dicionários contendo apenas objetos "
"serializáveis com pickle"

#: ../../library/pickle.rst:428
msgid ""
"functions defined at the top level of a module (using :keyword:`def`, not :"
"keyword:`lambda`)"
msgstr ""
"funções definidas no nível superior de um módulo (usando :keyword:`def`, "
"não :keyword:`lambda`)"

#: ../../library/pickle.rst:431
msgid "built-in functions defined at the top level of a module"
msgstr "funções embutidas definidas no nível superior de um módulo"

#: ../../library/pickle.rst:433
msgid "classes that are defined at the top level of a module"
msgstr "classes que são definidas no nível superior de um módulo"

#: ../../library/pickle.rst:435
msgid ""
"instances of such classes whose :attr:`~object.__dict__` or the result of "
"calling :meth:`__getstate__` is picklable  (see section :ref:`pickle-inst` "
"for details)."
msgstr ""
"instâncias de classes cujo :attr:`~object.__dict__` ou o resultado da "
"chamada de :meth:`__getstate__` seja serializável com pickle  (veja a seção :"
"ref:`pickle-inst` para detalhes)."

#: ../../library/pickle.rst:439
msgid ""
"Attempts to pickle unpicklable objects will raise the :exc:`PicklingError` "
"exception; when this happens, an unspecified number of bytes may have "
"already been written to the underlying file.  Trying to pickle a highly "
"recursive data structure may exceed the maximum recursion depth, a :exc:"
"`RecursionError` will be raised in this case.  You can carefully raise this "
"limit with :func:`sys.setrecursionlimit`."
msgstr ""
"As tentativas de serializar objetos não serializáveis com pickle vão "
"levantar a exceção :exc:`PicklingError`; quando isso acontece, um número não "
"especificado de bytes pode já ter sido escrito no arquivo subjacente. Tentar "
"serializar com pickle uma estrutura de dados altamente recursiva pode "
"exceder a profundidade máxima de recursão, a :exc:`RecursionError` será "
"levantada neste caso. Você pode aumentar este limite cuidadosamente com :"
"func:`sys.setrecursionlimit`."

#: ../../library/pickle.rst:446
msgid ""
"Note that functions (built-in and user-defined) are pickled by \"fully "
"qualified\" name reference, not by value. [#]_  This means that only the "
"function name is pickled, along with the name of the module the function is "
"defined in.  Neither the function's code, nor any of its function attributes "
"are pickled.  Thus the defining module must be importable in the unpickling "
"environment, and the module must contain the named object, otherwise an "
"exception will be raised. [#]_"
msgstr ""
"Observe que as funções (embutidas e definidas pelo usuário) são serializadas "
"com pickle por referência de nome \"totalmente qualificado\", não por valor. "
"[#]_ Isso significa que apenas o nome da função é serializado com pickle, "
"junto com o nome do módulo no qual a função está definida. Nem o código da "
"função, nem qualquer um de seus atributos de função são serializados com "
"pickle. Assim, o módulo de definição deve ser importável no ambiente de "
"desserialização com pickle, e o módulo deve conter o objeto nomeado, caso "
"contrário, uma exceção será levantada. [#]_"

#: ../../library/pickle.rst:453
msgid ""
"Similarly, classes are pickled by named reference, so the same restrictions "
"in the unpickling environment apply.  Note that none of the class's code or "
"data is pickled, so in the following example the class attribute ``attr`` is "
"not restored in the unpickling environment::"
msgstr ""
"Da mesma forma, as classes são serializadas com pickle por referência "
"nomeada, portanto, aplicam-se as mesmas restrições no ambiente de "
"desserialização com pickle. Observe que nenhum código ou dado da classe é "
"coletado, portanto, no exemplo a seguir, o atributo de classe ``attr`` não é "
"restaurado no ambiente de desserialização com pickle::"

#: ../../library/pickle.rst:463
msgid ""
"These restrictions are why picklable functions and classes must be defined "
"in the top level of a module."
msgstr ""
"Essas restrições são a razão pela qual as funções e classes serializáveis "
"com pickle devem ser definidas no nível superior de um módulo."

#: ../../library/pickle.rst:466
msgid ""
"Similarly, when class instances are pickled, their class's code and data are "
"not pickled along with them.  Only the instance data are pickled.  This is "
"done on purpose, so you can fix bugs in a class or add methods to the class "
"and still load objects that were created with an earlier version of the "
"class.  If you plan to have long-lived objects that will see many versions "
"of a class, it may be worthwhile to put a version number in the objects so "
"that suitable conversions can be made by the class's :meth:`__setstate__` "
"method."
msgstr ""
"Da mesma forma, quando as instâncias da classe são serializadas com pickle, "
"o código e os dados de sua classe não são serializados junto com elas. "
"Apenas os dados da instância são serializados com pickle. Isso é feito "
"propositalmente, para que você possa corrigir bugs em uma classe ou "
"adicionar métodos à classe e ainda carregar objetos que foram criados com "
"uma versão anterior da classe. Se você planeja ter objetos de longa duração "
"que verão muitas versões de uma classe, pode valer a pena colocar um número "
"de versão nos objetos para que as conversões adequadas possam ser feitas "
"pelo método :meth:`__setstate__` da classe."

#: ../../library/pickle.rst:478
msgid "Pickling Class Instances"
msgstr "Serializando com pickle instâncias de classes"

#: ../../library/pickle.rst:482
msgid ""
"In this section, we describe the general mechanisms available to you to "
"define, customize, and control how class instances are pickled and unpickled."
msgstr ""
"Nesta seção, descrevemos os mecanismos gerais disponíveis para você definir, "
"personalizar e controlar como as instâncias de classe são serializadas e "
"desserializadas com pickle."

#: ../../library/pickle.rst:485
msgid ""
"In most cases, no additional code is needed to make instances picklable.  By "
"default, pickle will retrieve the class and the attributes of an instance "
"via introspection. When a class instance is unpickled, its :meth:`__init__` "
"method is usually *not* invoked.  The default behaviour first creates an "
"uninitialized instance and then restores the saved attributes.  The "
"following code shows an implementation of this behaviour::"
msgstr ""
"Na maioria dos casos, nenhum código adicional é necessário para tornar as "
"instâncias serializáveis com pickle. Por padrão, o pickle recuperará a "
"classe e os atributos de uma instância por meio de introspecção. Quando uma "
"instância de classe não está serializada com pickle, seu método :meth:"
"`__init__` geralmente *não* é invocado. O comportamento padrão primeiro cria "
"uma instância não inicializada e, em seguida, restaura os atributos salvos. "
"O código a seguir mostra uma implementação desse comportamento::"

#: ../../library/pickle.rst:500
msgid ""
"Classes can alter the default behaviour by providing one or several special "
"methods:"
msgstr ""
"As classes podem alterar o comportamento padrão, fornecendo um ou vários "
"métodos especiais:"

#: ../../library/pickle.rst:505
msgid ""
"In protocols 2 and newer, classes that implements the :meth:"
"`__getnewargs_ex__` method can dictate the values passed to the :meth:"
"`__new__` method upon unpickling.  The method must return a pair ``(args, "
"kwargs)`` where *args* is a tuple of positional arguments and *kwargs* a "
"dictionary of named arguments for constructing the object.  Those will be "
"passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Nos protocolos 2 e mais recentes, as classes que implementam o método :meth:"
"`__getnewargs_ex__` podem ditar os valores passados para o método :meth:"
"`__new__` após a desserialização com pickle. O método deve retornar um par "
"``(args, kwargs)`` onde *args* é uma tupla de argumentos posicionais e "
"*kwargs* um dicionário de argumentos nomeados para construir o objeto. Esses "
"serão passados para o método :meth:`__new__` após a desserialização com "
"pickle."

#: ../../library/pickle.rst:513
msgid ""
"You should implement this method if the :meth:`__new__` method of your class "
"requires keyword-only arguments.  Otherwise, it is recommended for "
"compatibility to implement :meth:`__getnewargs__`."
msgstr ""
"Você deve implementar este método se o método :meth:`__new__` de sua classe "
"requer argumentos somente-nomeados. Caso contrário, é recomendado para "
"compatibilidade implementar :meth:`__getnewargs__`."

#: ../../library/pickle.rst:517
msgid ":meth:`__getnewargs_ex__` is now used in protocols 2 and 3."
msgstr ":meth:`__getnewargs_ex__` é agora usado em protocolos 2 e 3."

#: ../../library/pickle.rst:523
msgid ""
"This method serves a similar purpose as :meth:`__getnewargs_ex__`, but "
"supports only positional arguments.  It must return a tuple of arguments "
"``args`` which will be passed to the :meth:`__new__` method upon unpickling."
msgstr ""
"Este método serve a um propósito semelhante ao de :meth:`__getnewargs_ex__`, "
"mas tem suporte apenas a argumentos posicionais. Ele deve retornar uma tupla "
"de argumentos ``args`` que serão passados para o método :meth:`__new__` após "
"a desserialização com pickle."

#: ../../library/pickle.rst:527
msgid ""
":meth:`__getnewargs__` will not be called if :meth:`__getnewargs_ex__` is "
"defined."
msgstr ""
":meth:`__getnewargs__` não será chamado se :meth:`__getnewargs_ex__` estiver "
"definido."

#: ../../library/pickle.rst:530
msgid ""
"Before Python 3.6, :meth:`__getnewargs__` was called instead of :meth:"
"`__getnewargs_ex__` in protocols 2 and 3."
msgstr ""
"Antes do Python 3.6, :meth:`__getnewargs__` era chamado em vez de :meth:"
"`__getnewargs_ex__` nos protocolos 2 e 3."

#: ../../library/pickle.rst:537
msgid ""
"Classes can further influence how their instances are pickled; if the class "
"defines the method :meth:`__getstate__`, it is called and the returned "
"object is pickled as the contents for the instance, instead of the contents "
"of the instance's dictionary.  If the :meth:`__getstate__` method is absent, "
"the instance's :attr:`~object.__dict__` is pickled as usual."
msgstr ""
"As classes podem influenciar ainda mais como suas instâncias são "
"serializadas com pickle; se a classe define o método :meth:`__getstate__`, "
"ele é chamado e o objeto retornado é serializado com pickle como o conteúdo "
"da instância, ao invés do conteúdo do dicionário da instância. Se o método :"
"meth:`__getstate__` estiver ausente, o :attr:`~object.__dict__` da instância "
"é serializado com pickle como de costume."

#: ../../library/pickle.rst:546
msgid ""
"Upon unpickling, if the class defines :meth:`__setstate__`, it is called "
"with the unpickled state.  In that case, there is no requirement for the "
"state object to be a dictionary.  Otherwise, the pickled state must be a "
"dictionary and its items are assigned to the new instance's dictionary."
msgstr ""
"Ao desserializar com pickle, se a classe define :meth:`__setstate__`, ela é "
"chamada com o estado não desserializado. Nesse caso, não há nenhum requisito "
"para que o objeto de estado seja um dicionário. Caso contrário, o estado "
"serializado com pickle deve ser um dicionário e seus itens são atribuídos ao "
"dicionário da nova instância."

#: ../../library/pickle.rst:553
msgid ""
"If :meth:`__getstate__` returns a false value, the :meth:`__setstate__` "
"method will not be called upon unpickling."
msgstr ""
"Se :meth:`__getstate__` retornar um valor falso, o método :meth:"
"`__setstate__` não será chamado quando da desserialização com pickle."

#: ../../library/pickle.rst:557
msgid ""
"Refer to the section :ref:`pickle-state` for more information about how to "
"use the methods :meth:`__getstate__` and :meth:`__setstate__`."
msgstr ""
"Confira a seção :ref:`pickle-state` para mais informações sobre como usar os "
"métodos :meth:`__getstate__` e :meth:`__setstate__`."

#: ../../library/pickle.rst:562
msgid ""
"At unpickling time, some methods like :meth:`__getattr__`, :meth:"
"`__getattribute__`, or :meth:`__setattr__` may be called upon the instance.  "
"In case those methods rely on some internal invariant being true, the type "
"should implement :meth:`__new__` to establish such an invariant, as :meth:"
"`__init__` is not called when unpickling an instance."
msgstr ""
"Quando da desserialização com pickle, alguns métodos, como :meth:"
"`__getattr__`, :meth:`__getattribute__` ou :meth:`__setattr__`, podem ser "
"chamados na instância. No caso desses métodos dependerem de alguma "
"invariante interna ser verdadeira, o tipo deve ser implementado :meth:"
"`__new__` para estabelecer tal invariante, pois :meth:`__init__` não é "
"chamada quando da desserialização com pickle em uma instância."

#: ../../library/pickle.rst:571
msgid ""
"As we shall see, pickle does not use directly the methods described above.  "
"In fact, these methods are part of the copy protocol which implements the :"
"meth:`__reduce__` special method.  The copy protocol provides a unified "
"interface for retrieving the data necessary for pickling and copying "
"objects. [#]_"
msgstr ""
"Como veremos, o pickle não usa diretamente os métodos descritos acima. Na "
"verdade, esses métodos são parte do protocolo de cópia que implementa o "
"método especial :meth:`__reduce__`. O protocolo de cópia fornece uma "
"interface unificada para recuperar os dados necessários para serialização "
"com pickle e cópia de objetos. [#]_"

#: ../../library/pickle.rst:577
msgid ""
"Although powerful, implementing :meth:`__reduce__` directly in your classes "
"is error prone.  For this reason, class designers should use the high-level "
"interface (i.e., :meth:`__getnewargs_ex__`, :meth:`__getstate__` and :meth:"
"`__setstate__`) whenever possible.  We will show, however, cases where "
"using :meth:`__reduce__` is the only option or leads to more efficient "
"pickling or both."
msgstr ""
"Apesar de poderoso, implementar :meth:`__reduce__` diretamente em sua classe "
"é algo propenso a erro. Por este motivo, designers de classe devem usar a "
"interface de alto nível (ou seja, :meth:`__getnewargs_ex__`, :meth:"
"`__getstate__` e :meth:`__setstate__`) sempre que possível. Vamos mostrar, "
"porém, casos em que o uso de :meth:`__reduce__` é a única opção ou leva a "
"uma serialização com pickle mais eficiente, ou as ambas."

#: ../../library/pickle.rst:586
msgid ""
"The interface is currently defined as follows.  The :meth:`__reduce__` "
"method takes no argument and shall return either a string or preferably a "
"tuple (the returned object is often referred to as the \"reduce value\")."
msgstr ""
"A interface está atualmente definida da seguinte maneira. O método :meth:"
"`__reduce__` não aceita nenhum argumento e deve retornar uma string ou "
"preferencialmente uma tupla (o objeto retornado é frequentemente referido "
"como o \"valor de redução\")."

#: ../../library/pickle.rst:590
msgid ""
"If a string is returned, the string should be interpreted as the name of a "
"global variable.  It should be the object's local name relative to its "
"module; the pickle module searches the module namespace to determine the "
"object's module.  This behaviour is typically useful for singletons."
msgstr ""
"Se uma string é retornada, ela deve ser interpretada como o nome de uma "
"variável global. Deve ser o nome local do objeto relativo ao seu módulo; o "
"módulo pickle pesquisa o espaço de nomes do módulo para determinar o módulo "
"do objeto. Esse comportamento é normalmente útil para singletons."

#: ../../library/pickle.rst:595
msgid ""
"When a tuple is returned, it must be between two and five items long. "
"Optional items can either be omitted, or ``None`` can be provided as their "
"value.  The semantics of each item are in order:"
msgstr ""

#: ../../library/pickle.rst:601
msgid ""
"A callable object that will be called to create the initial version of the "
"object."
msgstr ""
"Um objeto chamável que será chamado para criar a versão inicial do objeto."

#: ../../library/pickle.rst:604
msgid ""
"A tuple of arguments for the callable object.  An empty tuple must be given "
"if the callable does not accept any argument."
msgstr ""
"Uma tupla de argumentos para o objeto chamável. Uma tupla vazia deve ser "
"fornecida se o chamável não aceitar nenhum argumento."

#: ../../library/pickle.rst:607
msgid ""
"Optionally, the object's state, which will be passed to the object's :meth:"
"`__setstate__` method as previously described.  If the object has no such "
"method then, the value must be a dictionary and it will be added to the "
"object's :attr:`~object.__dict__` attribute."
msgstr ""
"Opcionalmente, o estado do objeto, que será passado para o método :meth:"
"`__setstate__` do objeto conforme descrito anteriormente. Se o objeto não "
"tiver tal método, o valor deve ser um dicionário e será adicionado ao "
"atributo :attr:`~object.__dict__` do objeto."

#: ../../library/pickle.rst:612
msgid ""
"Optionally, an iterator (and not a sequence) yielding successive items. "
"These items will be appended to the object either using ``obj.append(item)`` "
"or, in batch, using ``obj.extend(list_of_items)``. This is primarily used "
"for list subclasses, but may be used by other classes as long as they have :"
"meth:`append` and :meth:`extend` methods with the appropriate signature.  "
"(Whether :meth:`append` or :meth:`extend` is used depends on which pickle "
"protocol version is used as well as the number of items to append, so both "
"must be supported.)"
msgstr ""
"Opcionalmente, um iterador (e não uma sequência) produzindo itens "
"sucessivos. Esses itens serão anexados ao objeto usando ``obj.append(item)`` "
"ou, em lote, usando ``obj.extend(lista_de_itens)``. Isso é usado "
"principalmente para subclasses de lista, mas pode ser usado por outras "
"classes, desde que tenham os métodos :meth:`append` e :meth:`extend` com a "
"assinatura apropriada. (Se :meth:`append` ou :meth:`extend` é usado depende "
"de qual versão do protocolo pickle é usada, bem como o número de itens a "
"anexar, então ambos devem ser suportados.)"

#: ../../library/pickle.rst:621
msgid ""
"Optionally, an iterator (not a sequence) yielding successive key-value "
"pairs.  These items will be stored to the object using ``obj[key] = "
"value``.  This is primarily used for dictionary subclasses, but may be used "
"by other classes as long as they implement :meth:`__setitem__`."
msgstr ""
"Opcionalmente, um iterador (não uma sequência) produzindo pares de valor-"
"chave sucessivos. Esses itens serão armazenados no objeto usando "
"``obj[chave]=valor``. Isso é usado principalmente para subclasses de "
"dicionário, mas pode ser usado por outras classes, desde que implementem :"
"meth:`__setitem__`."

#: ../../library/pickle.rst:629
msgid ""
"Alternatively, a :meth:`__reduce_ex__` method may be defined.  The only "
"difference is this method should take a single integer argument, the "
"protocol version.  When defined, pickle will prefer it over the :meth:"
"`__reduce__` method.  In addition, :meth:`__reduce__` automatically becomes "
"a synonym for the extended version.  The main use for this method is to "
"provide backwards-compatible reduce values for older Python releases."
msgstr ""
"Alternativamente, um método :meth:`__reduce_ex__` pode ser definido. A única "
"diferença é que este método deve ter um único argumento inteiro, a versão do "
"protocolo. Quando definido, pickle irá preferir isso ao método :meth:"
"`__reduce__`. Além disso, :meth:`__reduce__` automaticamente se torna um "
"sinônimo para a versão estendida. O principal uso desse método é fornecer "
"valores de redução com compatibilidade reversa para versões mais antigas do "
"Python."

#: ../../library/pickle.rst:641
msgid "Persistence of External Objects"
msgstr "Persistência de objetos externos"

#: ../../library/pickle.rst:647
msgid ""
"For the benefit of object persistence, the :mod:`pickle` module supports the "
"notion of a reference to an object outside the pickled data stream.  Such "
"objects are referenced by a persistent ID, which should be either a string "
"of alphanumeric characters (for protocol 0) [#]_ or just an arbitrary object "
"(for any newer protocol)."
msgstr ""
"Para o benefício da persistência do objeto, o módulo :mod:`pickle` tem "
"suporte à noção de uma referência a um objeto fora do fluxo de dados "
"serializados com pickle. Esses objetos são referenciados por um ID "
"persistente, que deve ser uma string de caracteres alfanuméricos (para o "
"protocolo 0) [#]_ ou apenas um objeto arbitrário (para qualquer protocolo "
"mais recente)."

#: ../../library/pickle.rst:653
msgid ""
"The resolution of such persistent IDs is not defined by the :mod:`pickle` "
"module; it will delegate this resolution to the user-defined methods on the "
"pickler and unpickler, :meth:`~Pickler.persistent_id` and :meth:`~Unpickler."
"persistent_load` respectively."
msgstr ""
"A resolução de tais IDs persistentes não é definida pelo módulo :mod:"
"`pickle`; ele vai delegar esta resolução aos métodos definidos pelo usuário "
"no selecionador e no separador, :meth:`~Pickler.persistent_id` e :meth:"
"`~Unpickler.persistent_load` respectivamente."

#: ../../library/pickle.rst:658
msgid ""
"To pickle objects that have an external persistent ID, the pickler must have "
"a custom :meth:`~Pickler.persistent_id` method that takes an object as an "
"argument and returns either ``None`` or the persistent ID for that object. "
"When ``None`` is returned, the pickler simply pickles the object as normal. "
"When a persistent ID string is returned, the pickler will pickle that "
"object, along with a marker so that the unpickler will recognize it as a "
"persistent ID."
msgstr ""
"Para serializar com pickle objetos que têm um ID externo persistente, o "
"pickler deve ter um método :meth:`~Pickler.persistent_id` personalizado que "
"recebe um objeto como um argumento e retorna ``None`` ou o ID persistente "
"para esse objeto. Quando ``None`` é retornado, o pickler simplesmente "
"serializa o objeto normalmente. Quando uma string de ID persistente é "
"retornada, o pickler serializa aquele objeto, junto com um marcador para que "
"o unpickler o reconheça como um ID persistente."

#: ../../library/pickle.rst:665
msgid ""
"To unpickle external objects, the unpickler must have a custom :meth:"
"`~Unpickler.persistent_load` method that takes a persistent ID object and "
"returns the referenced object."
msgstr ""
"Para desserializar com pickle objetos externos, o unpickler deve ter um "
"método :meth:`~Unpickler.persistent_load` personalizado que recebe um objeto "
"de ID persistente e retorna o objeto referenciado."

#: ../../library/pickle.rst:669
msgid ""
"Here is a comprehensive example presenting how persistent ID can be used to "
"pickle external objects by reference."
msgstr ""
"Aqui está um exemplo abrangente que apresenta como o ID persistente pode ser "
"usado para serializar com pickle objetos externos por referência."

#: ../../library/pickle.rst:677
msgid "Dispatch Tables"
msgstr "Tabelas de despacho"

#: ../../library/pickle.rst:679
msgid ""
"If one wants to customize pickling of some classes without disturbing any "
"other code which depends on pickling, then one can create a pickler with a "
"private dispatch table."
msgstr ""
"Se alguém quiser personalizar a serialização com pickle de algumas classes "
"sem perturbar nenhum outro código que dependa da serialização, pode-se criar "
"um pickler com uma tabela de despacho privada."

#: ../../library/pickle.rst:683
msgid ""
"The global dispatch table managed by the :mod:`copyreg` module is available "
"as :data:`copyreg.dispatch_table`.  Therefore, one may choose to use a "
"modified copy of :data:`copyreg.dispatch_table` as a private dispatch table."
msgstr ""
"A tabela de despacho global gerenciada pelo módulo :mod:`copyreg` está "
"disponível como :data:`copyreg.dispatch_table`. Portanto, pode-se escolher "
"usar uma cópia modificada de :data:`copyreg.dispatch_table` como uma tabela "
"de despacho privada."

#: ../../library/pickle.rst:688
msgid "For example ::"
msgstr "Por exemplo ::"

#: ../../library/pickle.rst:695
msgid ""
"creates an instance of :class:`pickle.Pickler` with a private dispatch table "
"which handles the ``SomeClass`` class specially.  Alternatively, the code ::"
msgstr ""
"cria uma instância de :class:`pickle.Pickler` com uma tabela de despacho "
"privada que trata a classe ``SomeClass`` especialmente. Alternativamente, o "
"código ::"

#: ../../library/pickle.rst:705
msgid ""
"does the same, but all instances of ``MyPickler`` will by default share the "
"same dispatch table.  The equivalent code using the :mod:`copyreg` module "
"is ::"
msgstr ""
"faz o mesmo, mas todas as instâncias de ``MyPickler`` irão por padrão "
"compartilhar a mesma tabela de despacho. O código equivalente usando o "
"módulo :mod:`copyreg` é ::"

#: ../../library/pickle.rst:716
msgid "Handling Stateful Objects"
msgstr "Manipulação de objetos com estado"

#: ../../library/pickle.rst:722
msgid ""
"Here's an example that shows how to modify pickling behavior for a class. "
"The :class:`TextReader` class opens a text file, and returns the line number "
"and line contents each time its :meth:`!readline` method is called. If a :"
"class:`TextReader` instance is pickled, all attributes *except* the file "
"object member are saved. When the instance is unpickled, the file is "
"reopened, and reading resumes from the last location. The :meth:"
"`__setstate__` and :meth:`__getstate__` methods are used to implement this "
"behavior. ::"
msgstr ""
"Aqui está um exemplo que mostra como modificar o comportamento de "
"serialização com pickle de uma classe. A classe :class:`TextReader` abre um "
"arquivo texto e retorna o número da linha e o conteúdo da linha cada vez que "
"seu método :meth:`!readline` é chamado. Se uma instância de :class:"
"`TextReader` for selecionada, todos os atributos *exceto* o membro do objeto "
"arquivo são salvos. Quando a instância é removida, o arquivo é reaberto e a "
"leitura continua a partir do último local. Os métodos :meth:`__setstate__` "
"e :meth:`__getstate__` são usados para implementar este comportamento. ::"

#: ../../library/pickle.rst:768
msgid "A sample usage might be something like this::"
msgstr "Um exemplo de uso pode ser algo assim:: "

#: ../../library/pickle.rst:783
msgid "Restricting Globals"
msgstr ""

#: ../../library/pickle.rst:788
msgid ""
"By default, unpickling will import any class or function that it finds in "
"the pickle data.  For many applications, this behaviour is unacceptable as "
"it permits the unpickler to import and invoke arbitrary code.  Just consider "
"what this hand-crafted pickle data stream does when loaded::"
msgstr ""

#: ../../library/pickle.rst:798
msgid ""
"In this example, the unpickler imports the :func:`os.system` function and "
"then apply the string argument \"echo hello world\".  Although this example "
"is inoffensive, it is not difficult to imagine one that could damage your "
"system."
msgstr ""

#: ../../library/pickle.rst:802
msgid ""
"For this reason, you may want to control what gets unpickled by customizing :"
"meth:`Unpickler.find_class`.  Unlike its name suggests, :meth:`Unpickler."
"find_class` is called whenever a global (i.e., a class or a function) is "
"requested.  Thus it is possible to either completely forbid globals or "
"restrict them to a safe subset."
msgstr ""

#: ../../library/pickle.rst:808
msgid ""
"Here is an example of an unpickler allowing only few safe classes from the :"
"mod:`builtins` module to be loaded::"
msgstr ""

#: ../../library/pickle.rst:837
msgid "A sample usage of our unpickler working has intended::"
msgstr ""

#: ../../library/pickle.rst:856
msgid ""
"As our examples shows, you have to be careful with what you allow to be "
"unpickled.  Therefore if security is a concern, you may want to consider "
"alternatives such as the marshalling API in :mod:`xmlrpc.client` or third-"
"party solutions."
msgstr ""

#: ../../library/pickle.rst:863
msgid "Performance"
msgstr "Performance"

#: ../../library/pickle.rst:865
msgid ""
"Recent versions of the pickle protocol (from protocol 2 and upwards) feature "
"efficient binary encodings for several common features and built-in types. "
"Also, the :mod:`pickle` module has a transparent optimizer written in C."
msgstr ""

#: ../../library/pickle.rst:873
msgid "Examples"
msgstr "Exemplos"

#: ../../library/pickle.rst:875
msgid ""
"For the simplest code, use the :func:`dump` and :func:`load` functions. ::"
msgstr ""

#: ../../library/pickle.rst:891
msgid "The following example reads the resulting pickled data. ::"
msgstr ""

#: ../../library/pickle.rst:908
msgid "Module :mod:`copyreg`"
msgstr ""

#: ../../library/pickle.rst:908
msgid "Pickle interface constructor registration for extension types."
msgstr ""

#: ../../library/pickle.rst:911
msgid "Module :mod:`pickletools`"
msgstr ""

#: ../../library/pickle.rst:911
msgid "Tools for working with and analyzing pickled data."
msgstr ""

#: ../../library/pickle.rst:914
msgid "Module :mod:`shelve`"
msgstr ""

#: ../../library/pickle.rst:914
msgid "Indexed databases of objects; uses :mod:`pickle`."
msgstr ""

#: ../../library/pickle.rst:917
msgid "Module :mod:`copy`"
msgstr ""

#: ../../library/pickle.rst:917
msgid "Shallow and deep object copying."
msgstr ""

#: ../../library/pickle.rst:919
msgid "Module :mod:`marshal`"
msgstr ""

#: ../../library/pickle.rst:920
msgid "High-performance serialization of built-in types."
msgstr ""

#: ../../library/pickle.rst:924
msgid "Footnotes"
msgstr "Notas de rodapé"

#: ../../library/pickle.rst:925
msgid "Don't confuse this with the :mod:`marshal` module"
msgstr ""

#: ../../library/pickle.rst:927
msgid ""
"This is why :keyword:`lambda` functions cannot be pickled:  all :keyword:`!"
"lambda` functions share the same name:  ``<lambda>``."
msgstr ""

#: ../../library/pickle.rst:930
msgid ""
"The exception raised will likely be an :exc:`ImportError` or an :exc:"
"`AttributeError` but it could be something else."
msgstr ""

#: ../../library/pickle.rst:933
msgid ""
"The :mod:`copy` module uses this protocol for shallow and deep copying "
"operations."
msgstr ""

#: ../../library/pickle.rst:936
msgid ""
"The limitation on alphanumeric characters is due to the fact the persistent "
"IDs, in protocol 0, are delimited by the newline character.  Therefore if "
"any kind of newline characters occurs in persistent IDs, the resulting "
"pickle will become unreadable."
msgstr ""
