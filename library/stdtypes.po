# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:46+0900\n"
"PO-Revision-Date: 2020-05-07 00:35+0000\n"
"Last-Translator: Vinicius Gubiani Ferreira <vini.g.fer@gmail.com>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/python-doc/python-27/language/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../library/stdtypes.rst:8
msgid "Built-in Types"
msgstr "Tipos internos"

#: ../../library/stdtypes.rst:10
msgid ""
"The following sections describe the standard types that are built into the "
"interpreter."
msgstr ""
"As seções a seguir descrevem os tipos padrão que são incorporados ao "
"interpretador."

#: ../../library/stdtypes.rst:15
msgid ""
"Historically (until release 2.2), Python's built-in types have differed from"
" user-defined types because it was not possible to use the built-in types as"
" the basis for object-oriented inheritance. This limitation no longer "
"exists."
msgstr ""

#: ../../library/stdtypes.rst:22
msgid ""
"The principal built-in types are numerics, sequences, mappings, files, "
"classes, instances and exceptions."
msgstr ""

#: ../../library/stdtypes.rst:27
msgid ""
"Some operations are supported by several object types; in particular, "
"practically all objects can be compared, tested for truth value, and "
"converted to a string (with the :ref:`repr() <func-repr>` function or the "
"slightly different :func:`str` function).  The latter function is implicitly"
" used when an object is written by the :func:`print` function."
msgstr ""

#: ../../library/stdtypes.rst:37
msgid "Truth Value Testing"
msgstr "Teste do Valor Verdade"

#: ../../library/stdtypes.rst:46
msgid ""
"Any object can be tested for truth value, for use in an :keyword:`if` or "
":keyword:`while` condition or as operand of the Boolean operations below. "
"The following values are considered false:"
msgstr ""
"Qualquer objeto pode ser testado para seu valor verdade, para uso em uma "
"condição :keyword:ìf`ou :keyword:`while` ou como operando para as operações "
"Booleanas abaixo. Os seguintes valores são considerados falsos:"

#: ../../library/stdtypes.rst:52
msgid "``None``"
msgstr "``None``"

#: ../../library/stdtypes.rst:56
msgid "``False``"
msgstr "``False``"

#: ../../library/stdtypes.rst:58
msgid "zero of any numeric type, for example, ``0``, ``0L``, ``0.0``, ``0j``."
msgstr ""

#: ../../library/stdtypes.rst:60
msgid "any empty sequence, for example, ``''``, ``()``, ``[]``."
msgstr "qualquer sequência vazia, por exemplo, ``''``, ``()``, ``[]``."

#: ../../library/stdtypes.rst:62
msgid "any empty mapping, for example, ``{}``."
msgstr "qualquer mapeamento vazio, por exemplo, ``{}``."

#: ../../library/stdtypes.rst:64
msgid ""
"instances of user-defined classes, if the class defines a "
":meth:`__nonzero__` or :meth:`__len__` method, when that method returns the "
"integer zero or :class:`bool` value ``False``. [1]_"
msgstr ""

#: ../../library/stdtypes.rst:70
msgid ""
"All other values are considered true --- so objects of many types are always"
" true."
msgstr ""
"Todos os outros valores são considerados verdadeiros --- então os objetos de"
" muitos tipos são sempre verdadeiros."

#: ../../library/stdtypes.rst:79
msgid ""
"Operations and built-in functions that have a Boolean result always return "
"``0`` or ``False`` for false and ``1`` or ``True`` for true, unless "
"otherwise stated. (Important exception: the Boolean operations ``or`` and "
"``and`` always return one of their operands.)"
msgstr ""
"Operações e funções embutidas que têm um resultado Booleano retornam ``0`` "
"ou ``False`` para falso e ``1`` ou ``True`` para verdadeiro, salvo "
"indicações ao contrário. (Exceção importante: as operações Booleanas  ``or``"
" e ``and`` sempre retornam um de seus operandos.)"

#: ../../library/stdtypes.rst:88
msgid "Boolean Operations --- :keyword:`and`, :keyword:`or`, :keyword:`not`"
msgstr "Operações Booleanas --- :keyword:`and`, :keyword:`or`, :keyword:`not`"

#: ../../library/stdtypes.rst:92
msgid "These are the Boolean operations, ordered by ascending priority:"
msgstr ""
"Esses são as operações Booleanas, ordenados por prioridade ascendente:"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:299 ../../library/stdtypes.rst:397
#: ../../library/stdtypes.rst:444 ../../library/stdtypes.rst:733
#: ../../library/stdtypes.rst:1657
msgid "Operation"
msgstr "Operação"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:299
#: ../../library/stdtypes.rst:397 ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733 ../../library/stdtypes.rst:1657
msgid "Result"
msgstr "Resultado"

#: ../../library/stdtypes.rst:95 ../../library/stdtypes.rst:153
#: ../../library/stdtypes.rst:299 ../../library/stdtypes.rst:444
#: ../../library/stdtypes.rst:733 ../../library/stdtypes.rst:1508
#: ../../library/stdtypes.rst:1657
msgid "Notes"
msgstr "Notas"

#: ../../library/stdtypes.rst:97
msgid "``x or y``"
msgstr "``x ou y``"

#: ../../library/stdtypes.rst:97
msgid "if *x* is false, then *y*, else *x*"
msgstr "se *x* é falso, então *y*, do contrário *x*"

#: ../../library/stdtypes.rst:97 ../../library/stdtypes.rst:165
#: ../../library/stdtypes.rst:307 ../../library/stdtypes.rst:735
#: ../../library/stdtypes.rst:738 ../../library/stdtypes.rst:1514
#: ../../library/stdtypes.rst:1668
msgid "\\(1)"
msgstr "\\(1)"

#: ../../library/stdtypes.rst:100
msgid "``x and y``"
msgstr "``x e y``"

#: ../../library/stdtypes.rst:100
msgid "if *x* is false, then *x*, else *y*"
msgstr "se *x* é falso, então *x*, do contrário *y*"

#: ../../library/stdtypes.rst:100 ../../library/stdtypes.rst:321
#: ../../library/stdtypes.rst:323 ../../library/stdtypes.rst:744
#: ../../library/stdtypes.rst:1518 ../../library/stdtypes.rst:1520
#: ../../library/stdtypes.rst:1674
msgid "\\(2)"
msgstr "\\(2)"

#: ../../library/stdtypes.rst:103
msgid "``not x``"
msgstr "``not x``"

#: ../../library/stdtypes.rst:103
msgid "if *x* is false, then ``True``, else ``False``"
msgstr "se *x* é falso, então ``True``, do contrário ``False``"

#: ../../library/stdtypes.rst:103 ../../library/stdtypes.rst:318
#: ../../library/stdtypes.rst:747 ../../library/stdtypes.rst:1522
#: ../../library/stdtypes.rst:1524 ../../library/stdtypes.rst:1526
#: ../../library/stdtypes.rst:1528 ../../library/stdtypes.rst:1677
msgid "\\(3)"
msgstr "\\(3)"

#: ../../library/stdtypes.rst:112 ../../library/stdtypes.rst:172
#: ../../library/stdtypes.rst:345 ../../library/stdtypes.rst:462
#: ../../library/stdtypes.rst:787 ../../library/stdtypes.rst:1551
#: ../../library/stdtypes.rst:1704
msgid "Notes:"
msgstr "Notas:"

#: ../../library/stdtypes.rst:115
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is false."
msgstr ""
"Esse é um operador de curto-circuito, sendo assim ele apenas avalia o "
"segundo argumento se o primeiro é falso."

#: ../../library/stdtypes.rst:119
msgid ""
"This is a short-circuit operator, so it only evaluates the second argument "
"if the first one is true."
msgstr ""
"Este é um operador de curto-circuito, por isso só avalia o segundo argumento"
" se o primeiro é verdadeiro."

#: ../../library/stdtypes.rst:123
msgid ""
"``not`` has a lower priority than non-Boolean operators, so ``not a == b`` "
"is interpreted as ``not (a == b)``, and ``a == not b`` is a syntax error."
msgstr ""
"``not`` tem uma baixa prioridade do que operadores não-Booleanos, então "
"``not a == b`` é interpretado como ``not (a == b)``, e ``a == not b`` é um "
"erro de sintaxe. "

#: ../../library/stdtypes.rst:130
msgid "Comparisons"
msgstr "Comparações"

#: ../../library/stdtypes.rst:144
msgid ""
"Comparison operations are supported by all objects.  They all have the same "
"priority (which is higher than that of the Boolean operations). Comparisons "
"can be chained arbitrarily; for example, ``x < y <= z`` is equivalent to ``x"
" < y and y <= z``, except that *y* is evaluated only once (but in both cases"
" *z* is not evaluated at all when ``x < y`` is found to be false)."
msgstr ""

#: ../../library/stdtypes.rst:150
msgid "This table summarizes the comparison operations:"
msgstr "Esta tabela resume as operações de comparação:"

#: ../../library/stdtypes.rst:153 ../../library/stdtypes.rst:1485
#: ../../library/stdtypes.rst:1508
msgid "Meaning"
msgstr "Significado"

#: ../../library/stdtypes.rst:155
msgid "``<``"
msgstr "``<``"

#: ../../library/stdtypes.rst:155
msgid "strictly less than"
msgstr "estritamente menor que"

#: ../../library/stdtypes.rst:157
msgid "``<=``"
msgstr "``<=``"

#: ../../library/stdtypes.rst:157
msgid "less than or equal"
msgstr "menor do que ou igual"

#: ../../library/stdtypes.rst:159
msgid "``>``"
msgstr "``>``"

#: ../../library/stdtypes.rst:159
msgid "strictly greater than"
msgstr "estritamente maior que"

#: ../../library/stdtypes.rst:161
msgid "``>=``"
msgstr "``>=``"

#: ../../library/stdtypes.rst:161
msgid "greater than or equal"
msgstr "maior que ou igual"

#: ../../library/stdtypes.rst:163
msgid "``==``"
msgstr "``==``"

#: ../../library/stdtypes.rst:163
msgid "equal"
msgstr "igual"

#: ../../library/stdtypes.rst:165
msgid "``!=``"
msgstr "``!=``"

#: ../../library/stdtypes.rst:165
msgid "not equal"
msgstr "não é igual"

#: ../../library/stdtypes.rst:167
msgid "``is``"
msgstr "``é``"

#: ../../library/stdtypes.rst:167
msgid "object identity"
msgstr "identidade do objeto"

#: ../../library/stdtypes.rst:169
msgid "``is not``"
msgstr "``is not``"

#: ../../library/stdtypes.rst:169
msgid "negated object identity"
msgstr "identidade de objeto negada"

#: ../../library/stdtypes.rst:175
msgid ""
"``!=`` can also be written ``<>``, but this is an obsolete usage kept for "
"backwards compatibility only. New code should always use ``!=``."
msgstr ""

#: ../../library/stdtypes.rst:183
msgid ""
"Objects of different types, except different numeric types and different "
"string types, never compare equal; such objects are ordered consistently but"
" arbitrarily (so that sorting a heterogeneous array yields a consistent "
"result). Furthermore, some types (for example, file objects) support only a "
"degenerate notion of comparison where any two objects of that type are "
"unequal.  Again, such objects are ordered arbitrarily but consistently. The "
"``<``, ``<=``, ``>`` and ``>=`` operators will raise a :exc:`TypeError` "
"exception when any operand is a complex number."
msgstr ""

#: ../../library/stdtypes.rst:201
msgid ""
"Non-identical instances of a class normally compare as non-equal unless the "
"class defines the :meth:`__eq__` method or the :meth:`__cmp__` method."
msgstr ""

#: ../../library/stdtypes.rst:204
msgid ""
"Instances of a class cannot be ordered with respect to other instances of "
"the same class, or other types of object, unless the class defines either "
"enough of the rich comparison methods (:meth:`__lt__`, :meth:`__le__`, "
":meth:`__gt__`, and :meth:`__ge__`) or the :meth:`__cmp__` method."
msgstr ""

#: ../../library/stdtypes.rst:211
msgid ""
"Objects of different types except numbers are ordered by their type names; "
"objects of the same types that don't support proper comparison are ordered "
"by their address."
msgstr ""

#: ../../library/stdtypes.rst:219
msgid ""
"Two more operations with the same syntactic priority, ``in`` and ``not in``,"
" are supported only by sequence types (below)."
msgstr ""

#: ../../library/stdtypes.rst:226
msgid ""
"Numeric Types --- :class:`int`, :class:`float`, :class:`long`, "
":class:`complex`"
msgstr ""

#: ../../library/stdtypes.rst:237
msgid ""
"There are four distinct numeric types: :dfn:`plain integers`, :dfn:`long "
"integers`, :dfn:`floating point numbers`, and :dfn:`complex numbers`. In "
"addition, Booleans are a subtype of plain integers. Plain integers (also "
"just called :dfn:`integers`) are implemented using :c:type:`long` in C, "
"which gives them at least 32 bits of precision (``sys.maxint`` is always set"
" to the maximum plain integer value for the current platform, the minimum "
"value is ``-sys.maxint - 1``).  Long integers have unlimited precision.  "
"Floating point numbers are usually implemented using :c:type:`double` in C; "
"information about the precision and internal representation of floating "
"point numbers for the machine on which your program is running is available "
"in :data:`sys.float_info`.  Complex numbers have a real and imaginary part, "
"which are each a floating point number.  To extract these parts from a "
"complex number *z*, use ``z.real`` and ``z.imag``. (The standard library "
"includes additional numeric types, :mod:`fractions` that hold rationals, and"
" :mod:`decimal` that hold floating-point numbers with user-definable "
"precision.)"
msgstr ""

#: ../../library/stdtypes.rst:262
msgid ""
"Numbers are created by numeric literals or as the result of built-in "
"functions and operators.  Unadorned integer literals (including binary, hex,"
" and octal numbers) yield plain integers unless the value they denote is too"
" large to be represented as a plain integer, in which case they yield a long"
" integer. Integer literals with an ``'L'`` or ``'l'`` suffix yield long "
"integers (``'L'`` is preferred because ``1l`` looks too much like eleven!)."
"  Numeric literals containing a decimal point or an exponent sign yield "
"floating point numbers. Appending ``'j'`` or ``'J'`` to a numeric literal "
"yields an imaginary number (a complex number with a zero real part) which "
"you can add to an integer or float to get a complex number with real and "
"imaginary parts."
msgstr ""

#: ../../library/stdtypes.rst:287
msgid ""
"Python fully supports mixed arithmetic: when a binary arithmetic operator "
"has operands of different numeric types, the operand with the \"narrower\" "
"type is widened to that of the other, where plain integer is narrower than "
"long integer is narrower than floating point is narrower than complex. "
"Comparisons between numbers of mixed type use the same rule. [2]_ The "
"constructors :func:`int`, :func:`long`, :func:`float`, and :func:`complex` "
"can be used to produce numbers of a specific type."
msgstr ""

#: ../../library/stdtypes.rst:295
msgid ""
"All built-in numeric types support the following operations. See "
":ref:`power` and later sections for the operators' priorities."
msgstr ""

#: ../../library/stdtypes.rst:301
msgid "``x + y``"
msgstr "``x + y``"

#: ../../library/stdtypes.rst:301
msgid "sum of *x* and *y*"
msgstr "soma de *x* e *y*"

#: ../../library/stdtypes.rst:303
msgid "``x - y``"
msgstr "``x - y``"

#: ../../library/stdtypes.rst:303
msgid "difference of *x* and *y*"
msgstr "diferença de * x * e * y *"

#: ../../library/stdtypes.rst:305
msgid "``x * y``"
msgstr "``x * y``"

#: ../../library/stdtypes.rst:305
msgid "product of *x* and *y*"
msgstr "produto de * x * e * y *"

#: ../../library/stdtypes.rst:307
msgid "``x / y``"
msgstr "``x / y``"

#: ../../library/stdtypes.rst:307
msgid "quotient of *x* and *y*"
msgstr "quociente de *x* e *y*"

#: ../../library/stdtypes.rst:309
msgid "``x // y``"
msgstr "``x // y``"

#: ../../library/stdtypes.rst:309
msgid "(floored) quotient of *x* and *y*"
msgstr ""

#: ../../library/stdtypes.rst:309
msgid "(4)(5)"
msgstr ""

#: ../../library/stdtypes.rst:312
msgid "``x % y``"
msgstr "``x % y``"

#: ../../library/stdtypes.rst:312
msgid "remainder of ``x / y``"
msgstr "restante de ``x / y``"

#: ../../library/stdtypes.rst:312 ../../library/stdtypes.rst:1530
#: ../../library/stdtypes.rst:1534 ../../library/stdtypes.rst:1686
#: ../../library/stdtypes.rst:1695
msgid "\\(4)"
msgstr "\\(4)"

#: ../../library/stdtypes.rst:314
msgid "``-x``"
msgstr "``-x``"

#: ../../library/stdtypes.rst:314
msgid "*x* negated"
msgstr "*x* negado"

#: ../../library/stdtypes.rst:316
msgid "``+x``"
msgstr "``+x``"

#: ../../library/stdtypes.rst:316
msgid "*x* unchanged"
msgstr "*x* inalterado"

#: ../../library/stdtypes.rst:318
msgid "``abs(x)``"
msgstr "``abs(x)``"

#: ../../library/stdtypes.rst:318
msgid "absolute value or magnitude of *x*"
msgstr "valor absoluto ou magnitude de *x*"

#: ../../library/stdtypes.rst:321
msgid "``int(x)``"
msgstr "``int(x)``"

#: ../../library/stdtypes.rst:321
msgid "*x* converted to integer"
msgstr "*x* convertido em inteiro"

#: ../../library/stdtypes.rst:323
msgid "``long(x)``"
msgstr ""

#: ../../library/stdtypes.rst:323
msgid "*x* converted to long integer"
msgstr ""

#: ../../library/stdtypes.rst:325
msgid "``float(x)``"
msgstr "``float(x)``"

#: ../../library/stdtypes.rst:325
msgid "*x* converted to floating point"
msgstr "*x* convertido em ponto flutuante"

#: ../../library/stdtypes.rst:325 ../../library/stdtypes.rst:741
#: ../../library/stdtypes.rst:1544 ../../library/stdtypes.rst:1692
msgid "\\(6)"
msgstr "\\(6)"

#: ../../library/stdtypes.rst:327
msgid "``complex(re,im)``"
msgstr ""

#: ../../library/stdtypes.rst:327
msgid ""
"a complex number with real part *re*, imaginary part *im*. *im* defaults to "
"zero."
msgstr ""
"um número complexo com parte real *re*, parte imaginária *im*. *im* acarreta"
" em zero."

#: ../../library/stdtypes.rst:331
msgid "``c.conjugate()``"
msgstr "``c.conjugate()``"

#: ../../library/stdtypes.rst:331
msgid "conjugate of the complex number *c*. (Identity on real numbers)"
msgstr ""

#: ../../library/stdtypes.rst:334
msgid "``divmod(x, y)``"
msgstr "``divmod(x, y)``"

#: ../../library/stdtypes.rst:334
msgid "the pair ``(x // y, x % y)``"
msgstr "o par ``(x // y, x % y)``"

#: ../../library/stdtypes.rst:334 ../../library/stdtypes.rst:749
msgid "(3)(4)"
msgstr "(3)(4)"

#: ../../library/stdtypes.rst:336
msgid "``pow(x, y)``"
msgstr "``pow(x, y)``"

#: ../../library/stdtypes.rst:336 ../../library/stdtypes.rst:338
msgid "*x* to the power *y*"
msgstr "*x* elevado a *y*"

#: ../../library/stdtypes.rst:336
msgid "(3)(7)"
msgstr ""

#: ../../library/stdtypes.rst:338
msgid "``x ** y``"
msgstr "``x ** y``"

#: ../../library/stdtypes.rst:338 ../../library/stdtypes.rst:1516
#: ../../library/stdtypes.rst:1697
msgid "\\(7)"
msgstr "\\(7)"

#: ../../library/stdtypes.rst:352
msgid ""
"For (plain or long) integer division, the result is an integer. The result "
"is always rounded towards minus infinity: 1/2 is 0, (-1)/2 is -1, 1/(-2) is "
"-1, and (-1)/(-2) is 0.  Note that the result is a long integer if either "
"operand is a long integer, regardless of the numeric value."
msgstr ""

#: ../../library/stdtypes.rst:365
msgid ""
"Conversion from floats using :func:`int` or :func:`long` truncates toward "
"zero like the related function, :func:`math.trunc`.  Use the function "
":func:`math.floor` to round downward and :func:`math.ceil` to round upward."
msgstr ""

#: ../../library/stdtypes.rst:371
msgid "See :ref:`built-in-funcs` for a full description."
msgstr ""

#: ../../library/stdtypes.rst:374
msgid ""
"The floor division operator, the modulo operator, and the :func:`divmod` "
"function are no longer defined for complex numbers.  Instead, convert to a "
"floating point number using the :func:`abs` function if appropriate."
msgstr ""

#: ../../library/stdtypes.rst:380
msgid ""
"Also referred to as integer division.  The resultant value is a whole "
"integer, though the result's type is not necessarily int."
msgstr ""

#: ../../library/stdtypes.rst:384
msgid ""
"float also accepts the strings \"nan\" and \"inf\" with an optional prefix "
"\"+\" or \"-\" for Not a Number (NaN) and positive or negative infinity."
msgstr ""
"ponto flutuante também aceita a string \"nan\" e \"inf\" com um prefixo "
"opcional \"+\" ou \"-\" para Não é um Número (NaN) e infinidade positiva ou "
"negativa."

#: ../../library/stdtypes.rst:390
msgid ""
"Python defines ``pow(0, 0)`` and ``0 ** 0`` to be ``1``, as is common for "
"programming languages."
msgstr ""
"Python define ``pow(0, 0)`` e ``0 ** 0`` sendo ``1``, como é comum para "
"linguagens de programação."

#: ../../library/stdtypes.rst:393
msgid ""
"All :class:`numbers.Real` types (:class:`int`, :class:`long`, and "
":class:`float`) also include the following operations:"
msgstr ""

#: ../../library/stdtypes.rst:399
msgid ":func:`math.trunc(\\ x) <math.trunc>`"
msgstr ":func:`math.trunc(\\ x) <math.trunc>`"

#: ../../library/stdtypes.rst:399
msgid "*x* truncated to :class:`~numbers.Integral`"
msgstr "*x* truncated to :class:`~numbers.Integral`"

#: ../../library/stdtypes.rst:402
msgid ":func:`round(x[, n]) <round>`"
msgstr ":func:`round(x[, n]) 1`<round>"

#: ../../library/stdtypes.rst:402
msgid ""
"*x* rounded to *n* digits, rounding ties away from zero. If *n* is omitted, "
"it defaults to 0."
msgstr ""

#: ../../library/stdtypes.rst:406
msgid ":func:`math.floor(\\ x) <math.floor>`"
msgstr ":func:`math.floor(\\ x) <math.floor>`"

#: ../../library/stdtypes.rst:406
msgid "the greatest integer as a float <= *x*"
msgstr ""

#: ../../library/stdtypes.rst:409
msgid ":func:`math.ceil(x) <math.ceil>`"
msgstr ":func:`math.ceil(x) <math.ceil>`"

#: ../../library/stdtypes.rst:409
msgid "the least integer as a float >= *x*"
msgstr ""

#: ../../library/stdtypes.rst:419
msgid "Bitwise Operations on Integer Types"
msgstr "Operações de bits em tipos inteiros"

#: ../../library/stdtypes.rst:433
msgid ""
"Bitwise operations only make sense for integers.  Negative numbers are "
"treated as their 2's complement value (this assumes a sufficiently large "
"number of bits that no overflow occurs during the operation)."
msgstr ""

#: ../../library/stdtypes.rst:437
msgid ""
"The priorities of the binary bitwise operations are all lower than the "
"numeric operations and higher than the comparisons; the unary operation "
"``~`` has the same priority as the other unary numeric operations (``+`` and"
" ``-``)."
msgstr ""
"As prioridades das operações bitwise binárias são todas menores do que as "
"operações numéricas e maiores que as comparações; a operação unária ``~`` "
"tem a mesma prioridade que as outras operações numéricas unárias (``+`` e "
"``-``)."

#: ../../library/stdtypes.rst:441
msgid "This table lists the bitwise operations sorted in ascending priority:"
msgstr ""
"Esta tabela lista as operações de bits classificadas em prioridade "
"ascendente:"

#: ../../library/stdtypes.rst:446
msgid "``x | y``"
msgstr "``x | y``"

#: ../../library/stdtypes.rst:446
msgid "bitwise :dfn:`or` of *x* and *y*"
msgstr "bitwise :dfn:`or` de *x* e *y*"

#: ../../library/stdtypes.rst:449
msgid "``x ^ y``"
msgstr "``x ^ y``"

#: ../../library/stdtypes.rst:449
msgid "bitwise :dfn:`exclusive or` of *x* and *y*"
msgstr "bitwise :dfn:`exclusive or` de *x* e *y*"

#: ../../library/stdtypes.rst:452
msgid "``x & y``"
msgstr "``x & y``"

#: ../../library/stdtypes.rst:452
msgid "bitwise :dfn:`and` of *x* and *y*"
msgstr "bitwise :dfn:`and` de *x* e *y*"

#: ../../library/stdtypes.rst:455
msgid "``x << n``"
msgstr "``x << n``"

#: ../../library/stdtypes.rst:455
msgid "*x* shifted left by *n* bits"
msgstr "*x* deslocado para a esquerda pelos bits *n*"

#: ../../library/stdtypes.rst:455
msgid "(1)(2)"
msgstr "(1)(2)"

#: ../../library/stdtypes.rst:457
msgid "``x >> n``"
msgstr "``x >> n``"

#: ../../library/stdtypes.rst:457
msgid "*x* shifted right by *n* bits"
msgstr "*x* deslocado para a direita pelos bits *n*"

#: ../../library/stdtypes.rst:457
msgid "(1)(3)"
msgstr "(1)(3)"

#: ../../library/stdtypes.rst:459
msgid "``~x``"
msgstr "``~x``"

#: ../../library/stdtypes.rst:459
msgid "the bits of *x* inverted"
msgstr "os bits de *x* invertidos"

#: ../../library/stdtypes.rst:465
msgid ""
"Negative shift counts are illegal and cause a :exc:`ValueError` to be "
"raised."
msgstr ""
"Contagens de deslocamento negativo são ilegais e causam o acionamento de um "
":exc:`ValueError` ."

#: ../../library/stdtypes.rst:468
msgid ""
"A left shift by *n* bits is equivalent to multiplication by ``pow(2, n)``.  "
"A long integer is returned if the result exceeds the range of plain "
"integers."
msgstr ""

#: ../../library/stdtypes.rst:472
msgid "A right shift by *n* bits is equivalent to division by ``pow(2, n)``."
msgstr ""

#: ../../library/stdtypes.rst:476
msgid "Additional Methods on Integer Types"
msgstr "Métodos adicionais em tipos inteiros"

#: ../../library/stdtypes.rst:478
msgid ""
"The integer types implement the :class:`numbers.Integral` :term:`abstract "
"base class`. In addition, they provide one more method:"
msgstr ""

#: ../../library/stdtypes.rst:484
msgid ""
"Return the number of bits necessary to represent an integer in binary, "
"excluding the sign and leading zeros::"
msgstr ""
"Retornar o número de bits necessários para representar um inteiro em "
"binário, excluindo o sinal e entrelinha zeros::"

#: ../../library/stdtypes.rst:493
msgid ""
"More precisely, if ``x`` is nonzero, then ``x.bit_length()`` is the unique "
"positive integer ``k`` such that ``2**(k-1) <= abs(x) < 2**k``. "
"Equivalently, when ``abs(x)`` is small enough to have a correctly rounded "
"logarithm, then ``k = 1 + int(log(abs(x), 2))``. If ``x`` is zero, then "
"``x.bit_length()`` returns ``0``."
msgstr ""
"Mais precisamente, se ``x`` for diferente de zero, então ``x.bit_length()` é"
" o único integral positivo ``k`` tal que ``2**(k-1) <= abs(x) <2**k``. "
"Equvalentemente, quando ``abs(x)`` for menor o suficiente para ter um "
"arredondamento algorítmicamente correto, então ``k=1 + int(log(abs(x),2))``."
" Se ``x`` é zero, então ``x.bit_length()`` retorna ``0``."

#: ../../library/stdtypes.rst:499
msgid "Equivalent to::"
msgstr "Equivalente a::"

#: ../../library/stdtypes.rst:510
msgid "Additional Methods on Float"
msgstr "Métodos Adicionais em Ponto Flutuante"

#: ../../library/stdtypes.rst:512
msgid ""
"The float type implements the :class:`numbers.Real` :term:`abstract base "
"class`. float also has the following additional methods."
msgstr ""
"O tipo float implementa :class:`numbers.Real` :term:`abstract base class`. "
"float também possui os seguintes métodos adicionais."

#: ../../library/stdtypes.rst:517
msgid ""
"Return a pair of integers whose ratio is exactly equal to the original float"
" and with a positive denominator.  Raises :exc:`OverflowError` on infinities"
" and a :exc:`ValueError` on NaNs."
msgstr ""
"Retorna um par de inteiros dos quais a proporção é exatamente igual ao float"
" original e com um denominador positivo. Levanta um :exc:`OverflowError` em "
"infinidades e um :exc:`ValueError` em NaNs."

#: ../../library/stdtypes.rst:526
msgid ""
"Return ``True`` if the float instance is finite with integral value, and "
"``False`` otherwise::"
msgstr ""
"Retornar `` True`` se a instância do float for finita com o valor integral e"
" `` False``, caso contrário::"

#: ../../library/stdtypes.rst:536
msgid ""
"Two methods support conversion to and from hexadecimal strings.  Since "
"Python's floats are stored internally as binary numbers, converting a float "
"to or from a *decimal* string usually involves a small rounding error.  In "
"contrast, hexadecimal strings allow exact representation and specification "
"of floating-point numbers.  This can be useful when debugging, and in "
"numerical work."
msgstr ""
"Dois métodos suportam conversão para e de cadeias hexadecimais. Uma vez que "
"os flutuadores do Python são armazenados internamente como números binários,"
" a conversão de um flutuador para ou de uma seqüência *decimal* geralmente "
"envolve um pequeno erro de arredondamento. Em contraste, as frases "
"hexadecimais permitem a representação exata e a especificação de números de "
"ponto flutuante. Isso pode ser útil na depuração e no trabalho numérico."

#: ../../library/stdtypes.rst:547
msgid ""
"Return a representation of a floating-point number as a hexadecimal string."
"  For finite floating-point numbers, this representation will always include"
" a leading ``0x`` and a trailing ``p`` and exponent."
msgstr ""
"Retorna a representação de um número de ponto-flutuante como uma string "
"hexadecimal. Para números de ponto-flutuante finitos, essa representação vai"
" sempre incluir um ``0x`` inicial e um ``p`` final e expoente."

#: ../../library/stdtypes.rst:557
msgid ""
"Class method to return the float represented by a hexadecimal string *s*.  "
"The string *s* may have leading and trailing whitespace."
msgstr ""
"Método de classe para retornar um float representado por uma string "
"hexadecimal *s*. A string *s* pode ter espaços em branco iniciais e finais."

#: ../../library/stdtypes.rst:564
msgid ""
"Note that :meth:`float.hex` is an instance method, while "
":meth:`float.fromhex` is a class method."
msgstr ""
"Note que :meth:`float.hex` é um método de instância, enquanto "
":meth:`float.fromhex` é um método de classe."

#: ../../library/stdtypes.rst:567
msgid "A hexadecimal string takes the form::"
msgstr "Uma string hexadecimal toma a forma:"

#: ../../library/stdtypes.rst:571
msgid ""
"where the optional ``sign`` may by either ``+`` or ``-``, ``integer`` and "
"``fraction`` are strings of hexadecimal digits, and ``exponent`` is a "
"decimal integer with an optional leading sign.  Case is not significant, and"
" there must be at least one hexadecimal digit in either the integer or the "
"fraction.  This syntax is similar to the syntax specified in section 6.4.4.2"
" of the C99 standard, and also to the syntax used in Java 1.5 onwards.  In "
"particular, the output of :meth:`float.hex` is usable as a hexadecimal "
"floating-point literal in C or Java code, and hexadecimal strings produced "
"by C's ``%a`` format character or Java's ``Double.toHexString`` are accepted"
" by :meth:`float.fromhex`."
msgstr ""
"aonde o sinal ``sign`` opcional pode ser tanto ``+`` or ``-``, ``integer`` e"
" ``fraction`` são strings de dígitos hexadecimais, e ``exponent`` é um "
"inteiro decimal com um símbolo precedente opcional. Case não é significante,"
" e deve haver ao menos um dígito hexadecimal tanto no inteiro ou na fração. "
"Essa síntaxe é similar à síntaxe especificada na seção 6.4.4.2 do padrão "
"C99, e também do da síntaxe usada no Java 1.5 em diante. Em particular, a "
"saída de :meth:`float.hex` é usável como um literal hexadecimal de ponto-"
"flutuante em código C ou Java, e hexadecimal strings produzidas pelo formato"
" do caráctere do C's ``%a``ou ``Double.toHexString`` do Java são aceitos "
"pelo :meth:`float.fromhex`."

#: ../../library/stdtypes.rst:584
msgid ""
"Note that the exponent is written in decimal rather than hexadecimal, and "
"that it gives the power of 2 by which to multiply the coefficient. For "
"example, the hexadecimal string ``0x3.a7p10`` represents the floating-point "
"number ``(3 + 10./16 + 7./16**2) * 2.0**10``, or ``3740.0``::"
msgstr ""
"Note que o expoente é escrito em decimal ao invés de hexadecimal, e que ele "
"dá a potência de 2 pela qual se multiplica o coeficiente.  Por exemplo, a "
"string hexadecimal ``0x3.a7p10`` representa o número de ponto-flutuante ``(3"
" + 10./16 + 7./16**2) * 2.0**10``, ou ``3740.0``::"

#: ../../library/stdtypes.rst:594
msgid ""
"Applying the reverse conversion to ``3740.0`` gives a different hexadecimal "
"string representing the same number::"
msgstr ""
"Aplicando a conversão reversa a ``3740.0`` retorna uma string hexadecimal "
"diferente representada pelo mesmo número::"

#: ../../library/stdtypes.rst:604
msgid "Iterator Types"
msgstr "Tipos de Iteração"

#: ../../library/stdtypes.rst:614
msgid ""
"Python supports a concept of iteration over containers.  This is implemented"
" using two distinct methods; these are used to allow user-defined classes to"
" support iteration.  Sequences, described below in more detail, always "
"support the iteration methods."
msgstr ""
"Python suporta o conceito de iteração sobre conteineres. Isso é implementado"
" usando dois métodos distintos; estes são usados para permitir classes "
"definidas pelo usuário suportem iteração. Sequências, descritas abaixo em "
"mais detalhes, sempre suportam os métodos de iteração."

#: ../../library/stdtypes.rst:619
msgid ""
"One method needs to be defined for container objects to provide iteration "
"support:"
msgstr ""
"Um método necessita ser definido para objetos conteineres afim destes "
"proverem suporte a iteração:"

#: ../../library/stdtypes.rst:626
msgid ""
"Return an iterator object.  The object is required to support the iterator "
"protocol described below.  If a container supports different types of "
"iteration, additional methods can be provided to specifically request "
"iterators for those iteration types.  (An example of an object supporting "
"multiple forms of iteration would be a tree structure which supports both "
"breadth-first and depth-first traversal.)  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"Retorna um objeto iterador. O objeto é requerido suportar o protocolo "
"iterador descrito abaixo. Se um conteiner suporta diferentes tipos de "
"iterador, métodos adicionais podem ser providenciados para requisitar "
"especificamente iteradores para aqueles tipos de iterações. "

#: ../../library/stdtypes.rst:635
msgid ""
"The iterator objects themselves are required to support the following two "
"methods, which together form the :dfn:`iterator protocol`:"
msgstr ""
"Os objetos iterator por eles mesmos são requeridos que suportem os dois "
"seguintes métodos, que juntos formam o :dfn:`iterator protocol`:"

#: ../../library/stdtypes.rst:641
msgid ""
"Return the iterator object itself.  This is required to allow both "
"containers and iterators to be used with the :keyword:`for` and "
":keyword:`in` statements. This method corresponds to the "
":c:member:`~PyTypeObject.tp_iter` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"Retorna o próprio iterator object. Isso é necessário para permitir que ambos"
" os conteineres e iteradores sejam usados com as declarações  :keyword:`for`"
" e :keyword:`in`. Esse method corresponde ao slot "
":c:member:`~PyTypeObject.tp_iter` da estrutura type para objetos do Python "
"na API Python/C."

#: ../../library/stdtypes.rst:649
msgid ""
"Return the next item from the container.  If there are no further items, "
"raise the :exc:`StopIteration` exception.  This method corresponds to the "
":c:member:`~PyTypeObject.tp_iternext` slot of the type structure for Python "
"objects in the Python/C API."
msgstr ""
"Retorna o próximo item do conteiner. Se não houver itens além, a exceção "
":exc:`StopIteration` é levantada. Esse method corresponde ao slot "
":c:member:`~PyTypeObject.tp_iternext` do type de estrutura para objetos "
"Python na API Python/C."

#: ../../library/stdtypes.rst:654
msgid ""
"Python defines several iterator objects to support iteration over general "
"and specific sequence types, dictionaries, and other more specialized forms."
"  The specific types are not important beyond their implementation of the "
"iterator protocol."
msgstr ""
"Python define diversos objetos iterator para suportar iterações sobre tipos "
"de sequências gerais e específicas, dicionários, e outras formas mais "
"especializadas. Os tipos específicos não são importantes além de sua "
"implementação do protocolo iterator."

#: ../../library/stdtypes.rst:659
msgid ""
"The intention of the protocol is that once an iterator's "
":meth:`~iterator.next` method raises :exc:`StopIteration`, it will continue "
"to do so on subsequent calls. Implementations that do not obey this property"
" are deemed broken.  (This constraint was added in Python 2.3; in Python "
"2.2, various iterators are broken according to this rule.)"
msgstr ""

#: ../../library/stdtypes.rst:669
msgid "Generator Types"
msgstr "Tipos de Geradores"

#: ../../library/stdtypes.rst:671
msgid ""
"Python's :term:`generator`\\s provide a convenient way to implement the "
"iterator protocol.  If a container object's :meth:`__iter__` method is "
"implemented as a generator, it will automatically return an iterator object "
"(technically, a generator object) supplying the :meth:`~iterator.__iter__` "
"and :meth:`~iterator.next` methods.  More information about generators can "
"be found in :ref:`the documentation for the yield expression <yieldexpr>`."
msgstr ""

#: ../../library/stdtypes.rst:682
msgid ""
"Sequence Types --- :class:`str`, :class:`unicode`, :class:`list`, "
":class:`tuple`, :class:`bytearray`, :class:`buffer`, :class:`xrange`"
msgstr ""

#: ../../library/stdtypes.rst:684
msgid ""
"There are seven sequence types: strings, Unicode strings, lists, tuples, "
"bytearrays, buffers, and xrange objects."
msgstr ""

#: ../../library/stdtypes.rst:687
msgid ""
"For other containers see the built in :class:`dict` and :class:`set` "
"classes, and the :mod:`collections` module."
msgstr ""

#: ../../library/stdtypes.rst:701
msgid ""
"String literals are written in single or double quotes: ``'xyzzy'``, "
"``\"frobozz\"``.  See :ref:`strings` for more about string literals. Unicode"
" strings are much like strings, but are specified in the syntax using a "
"preceding ``'u'`` character: ``u'abc'``, ``u\"def\"``. In addition to the "
"functionality described here, there are also string-specific methods "
"described in the :ref:`string-methods` section. Lists are constructed with "
"square brackets, separating items with commas: ``[a, b, c]``. Tuples are "
"constructed by the comma operator (not within square brackets), with or "
"without enclosing parentheses, but an empty tuple must have the enclosing "
"parentheses, such as ``a, b, c`` or ``()``.  A single item tuple must have a"
" trailing comma, such as ``(d,)``."
msgstr ""

#: ../../library/stdtypes.rst:713
msgid ""
"Bytearray objects are created with the built-in function :func:`bytearray`."
msgstr ""

#: ../../library/stdtypes.rst:715
msgid ""
"Buffer objects are not directly supported by Python syntax, but can be "
"created by calling the built-in function :func:`buffer`.  They don't support"
" concatenation or repetition."
msgstr ""

#: ../../library/stdtypes.rst:719
msgid ""
"Objects of type xrange are similar to buffers in that there is no specific "
"syntax to create them, but they are created using the :func:`xrange` "
"function.  They don't support slicing, concatenation or repetition, and "
"using ``in``, ``not in``, :func:`min` or :func:`max` on them is inefficient."
msgstr ""

#: ../../library/stdtypes.rst:724
msgid ""
"Most sequence types support the following operations.  The ``in`` and ``not "
"in`` operations have the same priorities as the comparison operations.  The "
"``+`` and ``*`` operations have the same priority as the corresponding "
"numeric operations. [3]_ Additional methods are provided for :ref:`typesseq-"
"mutable`."
msgstr ""

#: ../../library/stdtypes.rst:729
msgid ""
"This table lists the sequence operations sorted in ascending priority. In "
"the table, *s* and *t* are sequences of the same type; *n*, *i* and *j* are "
"integers:"
msgstr ""

#: ../../library/stdtypes.rst:735
msgid "``x in s``"
msgstr "``x in s``"

#: ../../library/stdtypes.rst:735
msgid "``True`` if an item of *s* is equal to *x*, else ``False``"
msgstr "``True`` caso um item de *s* seja igual a *x*, senão ``False``"

#: ../../library/stdtypes.rst:738
msgid "``x not in s``"
msgstr "``x not in s``"

#: ../../library/stdtypes.rst:738
msgid "``False`` if an item of *s* is equal to *x*, else ``True``"
msgstr "``False`` caso um item de *s* for igual a *x*, senão ``True``"

#: ../../library/stdtypes.rst:741
msgid "``s + t``"
msgstr "``s + t``"

#: ../../library/stdtypes.rst:741
msgid "the concatenation of *s* and *t*"
msgstr "a concatenão de *s* e *t*"

#: ../../library/stdtypes.rst:744
msgid "``s * n, n * s``"
msgstr ""

#: ../../library/stdtypes.rst:744
msgid "equivalent to adding *s* to itself *n* times"
msgstr "equivalente a adicionar *s* a si mesmo *n* vezes"

#: ../../library/stdtypes.rst:747
msgid "``s[i]``"
msgstr "``s[i]``"

#: ../../library/stdtypes.rst:747
msgid "*i*\\ th item of *s*, origin 0"
msgstr "*i*\\ enésimo item de *s*, origem 0"

#: ../../library/stdtypes.rst:749
msgid "``s[i:j]``"
msgstr "``s[i:j]``"

#: ../../library/stdtypes.rst:749
msgid "slice of *s* from *i* to *j*"
msgstr "fatia de *s* desde *i* para *j*"

#: ../../library/stdtypes.rst:751
msgid "``s[i:j:k]``"
msgstr "``s[i:j:k]``"

#: ../../library/stdtypes.rst:751
msgid "slice of *s* from *i* to *j* with step *k*"
msgstr "fatia de *s* desde *i* para *j* com passo *k*"

#: ../../library/stdtypes.rst:751
msgid "(3)(5)"
msgstr "(3)(5)"

#: ../../library/stdtypes.rst:754
msgid "``len(s)``"
msgstr "``len(s)``"

#: ../../library/stdtypes.rst:754
msgid "length of *s*"
msgstr "comprimento de *s*"

#: ../../library/stdtypes.rst:756
msgid "``min(s)``"
msgstr "``min(s)``"

#: ../../library/stdtypes.rst:756
msgid "smallest item of *s*"
msgstr "menor item de *s*"

#: ../../library/stdtypes.rst:758
msgid "``max(s)``"
msgstr "``max(s)``"

#: ../../library/stdtypes.rst:758
msgid "largest item of *s*"
msgstr "maior item de *s*"

#: ../../library/stdtypes.rst:760
msgid "``s.index(x)``"
msgstr ""

#: ../../library/stdtypes.rst:760
msgid "index of the first occurrence of *x* in *s*"
msgstr ""

#: ../../library/stdtypes.rst:763 ../../library/stdtypes.rst:1683
msgid "``s.count(x)``"
msgstr "``s.count(x)``"

#: ../../library/stdtypes.rst:763
msgid "total number of occurrences of *x* in *s*"
msgstr "numero total de ocorrência de *x* em *s*"

#: ../../library/stdtypes.rst:767
msgid ""
"Sequence types also support comparisons. In particular, tuples and lists are"
" compared lexicographically by comparing corresponding elements. This means "
"that to compare equal, every element must compare equal and the two "
"sequences must be of the same type and have the same length. (For full "
"details see :ref:`comparisons` in the language reference.)"
msgstr ""

#: ../../library/stdtypes.rst:790
msgid ""
"When *s* is a string or Unicode string object the ``in`` and ``not in`` "
"operations act like a substring test.  In Python versions before 2.3, *x* "
"had to be a string of length 1. In Python 2.3 and beyond, *x* may be a "
"string of any length."
msgstr ""

#: ../../library/stdtypes.rst:796
msgid ""
"Values of *n* less than ``0`` are treated as ``0`` (which yields an empty "
"sequence of the same type as *s*).  Note that items in the sequence *s* are "
"not copied; they are referenced multiple times.  This often haunts new "
"Python programmers; consider:"
msgstr ""

#: ../../library/stdtypes.rst:808
msgid ""
"What has happened is that ``[[]]`` is a one-element list containing an empty"
" list, so all three elements of ``[[]] * 3`` are references to this single "
"empty list.  Modifying any of the elements of ``lists`` modifies this single"
" list. You can create a list of different lists this way:"
msgstr ""

#: ../../library/stdtypes.rst:820
msgid ""
"Further explanation is available in the FAQ entry :ref:`faq-"
"multidimensional-list`."
msgstr ""
"Outra explicação está disponível em FAQ :ref:`faq-multidimensional-list`."

#: ../../library/stdtypes.rst:824
msgid ""
"If *i* or *j* is negative, the index is relative to the end of sequence *s*:"
" ``len(s) + i`` or ``len(s) + j`` is substituted.  But note that ``-0`` is "
"still ``0``."
msgstr ""
"Se *i* ou *j* forem negativo, o índice será relativo ao fim da seqüência "
"*s*: `` len(s) + i`` ou ``len(s) + j`` será substituído. Mas note que ``-0``"
" ainda será ``0``."

#: ../../library/stdtypes.rst:829
msgid ""
"The slice of *s* from *i* to *j* is defined as the sequence of items with "
"index *k* such that ``i <= k < j``.  If *i* or *j* is greater than "
"``len(s)``, use ``len(s)``.  If *i* is omitted or ``None``, use ``0``.  If "
"*j* is omitted or ``None``, use ``len(s)``.  If *i* is greater than or equal"
" to *j*, the slice is empty."
msgstr ""
"A fatia *s* de *i* para *j* é definida como a seqüência de itens com índice "
"*k* tal que ``i <= k <j``. Se *i* ou *j* forem maior do que ``len(s)``, use "
"``len(s)``. Se *i* for omitido ou for igual a ``None``, use ``0``. Se *j* "
"for omitido ou ``None``, use ``len(s)``. Se *i* for maior ou igual a *j*, a "
"fatia está vazia."

#: ../../library/stdtypes.rst:836
msgid ""
"The slice of *s* from *i* to *j* with step *k* is defined as the sequence of"
" items with index  ``x = i + n*k`` such that ``0 <= n < (j-i)/k``.  In other"
" words, the indices are ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` and so on, "
"stopping when *j* is reached (but never including *j*).  When *k* is "
"positive, *i* and *j* are reduced to ``len(s)`` if they are greater. When "
"*k* is negative, *i* and *j* are reduced to ``len(s) - 1`` if they are "
"greater.  If *i* or *j* are omitted or ``None``, they become \"end\" values "
"(which end depends on the sign of *k*).  Note, *k* cannot be zero. If *k* is"
" ``None``, it is treated like ``1``."
msgstr ""
"A fatia *s* de *i* para *j* com passo *k* é definida como sendo a seqüência "
"de itens com índice ``x = i + n * k`` tal que ``0 <= n <(j-i)/k``. Em outras"
" palavras, os índices são ``i``, ``i+k``, ``i+2*k``, ``i+3*k`` e assim por "
"diante, parando quando *j* for atingiu (mas nunca incluindo *j*). Quando *k*"
" for positivo, *i* e *j* serão reduzidos a ``len(s)`` se forem maiores. "
"Quando *k* for negativo, *i* e *j* são reduzidos para ``len(s)-1`` se forem "
"maiores. Se *i* ou *j* forem omitidos ou `` None`, eles se tornam valores "
"\"finais\" (cujo final depende de *k*). Nota: *k* não pode ser zero. Se *k* "
"for ``None``, o mesmo será tratado como sendo igual a ``1```."

#: ../../library/stdtypes.rst:849
msgid ""
"If *s* and *t* are both strings, some Python implementations such as CPython"
" can usually perform an in-place optimization for assignments of the form "
"``s = s + t`` or ``s += t``.  When applicable, this optimization makes "
"quadratic run-time much less likely.  This optimization is both version and "
"implementation dependent.  For performance sensitive code, it is preferable "
"to use the :meth:`str.join` method which assures consistent linear "
"concatenation performance across versions and implementations."
msgstr ""

#: ../../library/stdtypes.rst:857
msgid "Formerly, string concatenation never occurred in-place."
msgstr ""

#: ../../library/stdtypes.rst:864
msgid "String Methods"
msgstr "Métodos de String"

#: ../../library/stdtypes.rst:868
msgid ""
"Below are listed the string methods which both 8-bit strings and Unicode "
"objects support.  Some of them are also available on :class:`bytearray` "
"objects."
msgstr ""

#: ../../library/stdtypes.rst:872
msgid ""
"In addition, Python's strings support the sequence type methods described in"
" the :ref:`typesseq` section. To output formatted strings use template "
"strings or the ``%`` operator described in the :ref:`string-formatting` "
"section. Also, see the :mod:`re` module for string functions based on "
"regular expressions."
msgstr ""

#: ../../library/stdtypes.rst:880
msgid ""
"Return a copy of the string with its first character capitalized and the "
"rest lowercased."
msgstr ""
"Retorna uma cópia da String com o seu primeiro caractere em maiúsculo e o "
"restantes em minúsculo."

#: ../../library/stdtypes.rst:883 ../../library/stdtypes.rst:1019
#: ../../library/stdtypes.rst:1027 ../../library/stdtypes.rst:1035
#: ../../library/stdtypes.rst:1043 ../../library/stdtypes.rst:1051
#: ../../library/stdtypes.rst:1060 ../../library/stdtypes.rst:1068
#: ../../library/stdtypes.rst:1095 ../../library/stdtypes.rst:1323
#: ../../library/stdtypes.rst:1351 ../../library/stdtypes.rst:1388
msgid "For 8-bit strings, this method is locale-dependent."
msgstr ""

#: ../../library/stdtypes.rst:888
msgid ""
"Return centered in a string of length *width*. Padding is done using the "
"specified *fillchar* (default is a space)."
msgstr ""

#: ../../library/stdtypes.rst:891 ../../library/stdtypes.rst:1086
#: ../../library/stdtypes.rst:1150
msgid "Support for the *fillchar* argument."
msgstr ""

#: ../../library/stdtypes.rst:897
msgid ""
"Return the number of non-overlapping occurrences of substring *sub* in the "
"range [*start*, *end*].  Optional arguments *start* and *end* are "
"interpreted as in slice notation."
msgstr ""
"Retorna o número de ocorrências da sub-string *sub* que não se sobrepõem no "
"intervalo [*start*, *end*]. Argumentos opcionais *start* e *end* são "
"interpretados como na notação de fatias."

#: ../../library/stdtypes.rst:904
msgid ""
"Decodes the string using the codec registered for *encoding*. *encoding* "
"defaults to the default string encoding.  *errors* may be given to set a "
"different error handling scheme.  The default is ``'strict'``, meaning that "
"encoding errors raise :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'`` and any other name registered via "
":func:`codecs.register_error`, see section :ref:`codec-base-classes`."
msgstr ""

#: ../../library/stdtypes.rst:913
msgid "Support for other error handling schemes added."
msgstr ""

#: ../../library/stdtypes.rst:916 ../../library/stdtypes.rst:936
msgid "Support for keyword arguments added."
msgstr "Suporte para argumentos que possuem keyword adicionados."

#: ../../library/stdtypes.rst:921
msgid ""
"Return an encoded version of the string.  Default encoding is the current "
"default string encoding.  *errors* may be given to set a different error "
"handling scheme.  The default for *errors* is ``'strict'``, meaning that "
"encoding errors raise a :exc:`UnicodeError`.  Other possible values are "
"``'ignore'``, ``'replace'``, ``'xmlcharrefreplace'``, ``'backslashreplace'``"
" and any other name registered via :func:`codecs.register_error`, see "
"section :ref:`codec-base-classes`. For a list of possible encodings, see "
"section :ref:`standard-encodings`."
msgstr ""

#: ../../library/stdtypes.rst:932
msgid ""
"Support for ``'xmlcharrefreplace'`` and ``'backslashreplace'`` and other "
"error handling schemes added."
msgstr ""

#: ../../library/stdtypes.rst:941
msgid ""
"Return ``True`` if the string ends with the specified *suffix*, otherwise "
"return ``False``.  *suffix* can also be a tuple of suffixes to look for.  "
"With optional *start*, test beginning at that position.  With optional "
"*end*, stop comparing at that position."
msgstr ""
"Retorna ``True`` se a string terminar com o *suffix* especificado, caso "
"contrário retorna ``False``.  *suffix* também pode ser uma tupla de sufixos "
"para procurar. Com o parâmetro opcional *start*, começamos a testart a "
"partir daquela posição. Com o parâmetro opcional *end*, devemos parar de "
"comparar na posição especificada."

#: ../../library/stdtypes.rst:946
msgid "Accept tuples as *suffix*."
msgstr ""

#: ../../library/stdtypes.rst:952
msgid ""
"Return a copy of the string where all tab characters are replaced by one or "
"more spaces, depending on the current column and the given tab size.  Tab "
"positions occur every *tabsize* characters (default is 8, giving tab "
"positions at columns 0, 8, 16 and so on).  To expand the string, the current"
" column is set to zero and the string is examined character by character.  "
"If the character is a tab (``\\t``), one or more space characters are "
"inserted in the result until the current column is equal to the next tab "
"position. (The tab character itself is not copied.)  If the character is a "
"newline (``\\n``) or return (``\\r``), it is copied and the current column "
"is reset to zero.  Any other character is copied unchanged and the current "
"column is incremented by one regardless of how the character is represented "
"when printed."
msgstr ""
"Devolve uma cópia da string onde todos os caracteres de tabulação são "
"substituídos por um ou mais espaços, dependendo da coluna atual e do tamanho"
" fornecido para a tabulação. Posições de tabulação ocorrem a cada *tabsize* "
"caracteres (o padrão é 8, dada as posições de tabulação nas colunas 0, 8, 16"
" e assim por diante). Para expandir a string, a coluna atual é definida como"
" zero e a string é examinada caracter por caracter. Se o caracter é uma "
"tabulação (``\\t``), um ou mais caracteres de espaço são inseridos no "
"resultado até que a coluna atual seja igual a próxima posição de tabulação. "
"(O caracter de tabulação em si não é copiado.) Se o caracter é um caracter "
"de nova linha (``\\n``) ou de retorno (``\\r``), ele é copiado e a coluna "
"atual é resetada para zero. Qualquer outro caracter é copiado sem ser "
"modificado e a coluna atual é incrementada em uma unidate independentemente "
"de como o caracter é representado quanto é impresso."

#: ../../library/stdtypes.rst:973
msgid ""
"Return the lowest index in the string where substring *sub* is found within "
"the slice ``s[start:end]``.  Optional arguments *start* and *end* are "
"interpreted as in slice notation.  Return ``-1`` if *sub* is not found."
msgstr ""
"Retorna o índice mais baixo na String onde a substring *sub* é encontrado "
"dentro da fatia ``s[start:end]``.  Argumntos opcionais como *start* e *end* "
"são interpretados como umanotação de fatiamento.  Retorna ``-1`` se *sub* "
"não for localizado."

#: ../../library/stdtypes.rst:979
msgid ""
"The :meth:`~str.find` method should be used only if you need to know the "
"position of *sub*.  To check if *sub* is a substring or not, use the "
":keyword:`in` operator::"
msgstr ""
"O método :meth:`~str.find` deve ser usado apenas se precisarmos conhecer a "
"posição de *sub*. Para verificar se *sub* é ou não uma substring, use o "
"operador :keyword:`in`::"

#: ../../library/stdtypes.rst:989
msgid ""
"Perform a string formatting operation.  The string on which this method is "
"called can contain literal text or replacement fields delimited by braces "
"``{}``.  Each replacement field contains either the numeric index of a "
"positional argument, or the name of a keyword argument.  Returns a copy of "
"the string where each replacement field is replaced with the string value of"
" the corresponding argument."
msgstr ""
"Executa uma operação de formatação de string. A string na qual este método é"
" chamado pode conter texto literal ou campos para substituição delimitados "
"por chaves ``{}``. Cada campo de substituição contém ou um índice numérico "
"de um argumento posicional, ou o nome de um argumento palavra-chave. Retorna"
" a cópia da string onde cada campo para substituição é substituído com o "
"valor da string do argumento correspondente."

#: ../../library/stdtypes.rst:999
msgid ""
"See :ref:`formatstrings` for a description of the various formatting options"
" that can be specified in format strings."
msgstr ""
"Veja :ref:`formatstrings` para uma descrição das várias opções de formatação"
" que podem ser especificadas em um formato Strings."

#: ../../library/stdtypes.rst:1002
msgid ""
"This method of string formatting is the new standard in Python 3, and should"
" be preferred to the ``%`` formatting described in :ref:`string-formatting` "
"in new code."
msgstr ""

#: ../../library/stdtypes.rst:1011
msgid ""
"Like :meth:`find`, but raise :exc:`ValueError` when the substring is not "
"found."
msgstr ""

#: ../../library/stdtypes.rst:1016
msgid ""
"Return true if all characters in the string are alphanumeric and there is at"
" least one character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1024
msgid ""
"Return true if all characters in the string are alphabetic and there is at "
"least one character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1032
msgid ""
"Return true if all characters in the string are digits and there is at least"
" one character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1040
msgid ""
"Return true if all cased characters [4]_ in the string are lowercase and "
"there is at least one cased character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1048
msgid ""
"Return true if there are only whitespace characters in the string and there "
"is at least one character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1056
msgid ""
"Return true if the string is a titlecased string and there is at least one "
"character, for example uppercase characters may only follow uncased "
"characters and lowercase characters only cased ones.  Return false "
"otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1065
msgid ""
"Return true if all cased characters [4]_ in the string are uppercase and "
"there is at least one cased character, false otherwise."
msgstr ""

#: ../../library/stdtypes.rst:1073
msgid ""
"Return a string which is the concatenation of the strings in *iterable*. If "
"there is any Unicode object in *iterable*, return a Unicode instead. A "
":exc:`TypeError` will be raised if there are any non-string or non Unicode "
"object values in *iterable*.  The separator between elements is the string "
"providing this method."
msgstr ""

#: ../../library/stdtypes.rst:1082
msgid ""
"Return the string left justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space).  The original "
"string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1092
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"lowercase."
msgstr ""
"Retorna uma cópia da string com todos os caracteres que permitem maiúsculo E"
" minúsculo [4]_ convertidos para letras minúsculas."

#: ../../library/stdtypes.rst:1100
msgid ""
"Return a copy of the string with leading characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a prefix; rather, all combinations of its values"
" are stripped:"
msgstr ""

#: ../../library/stdtypes.rst:1110 ../../library/stdtypes.rst:1187
#: ../../library/stdtypes.rst:1314
msgid "Support for the *chars* argument."
msgstr ""

#: ../../library/stdtypes.rst:1116
msgid ""
"Split the string at the first occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing the string itself, followed by two empty strings."
msgstr ""
"Quebra a string na primeira ocorrência de *sep*, e retorna uma tupla com 3 "
"elementos contendo a parte antes do separador, o próprio separator, e a "
"parte após o separador. Se o separador não for encontrado, retorna uma tupla"
" com 3 elementos contendo a string, seguido de duas strings vazias."

#: ../../library/stdtypes.rst:1126
msgid ""
"Return a copy of the string with all occurrences of substring *old* replaced"
" by *new*.  If the optional argument *count* is given, only the first "
"*count* occurrences are replaced."
msgstr ""
"Retorna uma cópia da string com todas as ocorrências da substring *old* "
"substituídas por *new*. Se o argumento opcional *count* é fornecido, apenas "
"as primeiras *count* ocorrências são substituídas."

#: ../../library/stdtypes.rst:1133
msgid ""
"Return the highest index in the string where substring *sub* is found, such "
"that *sub* is contained within ``s[start:end]``.  Optional arguments *start*"
" and *end* are interpreted as in slice notation.  Return ``-1`` on failure."
msgstr ""
"Retorna o maior índice onde a substring *sub* foi encontrada dentro da "
"string, onde *sub* está contida dentro do intervalo ``s[start:end]``. "
"Argumentos opcionais *start* e *end* são interpretados usando a notação "
"slice. Retorna ``-1`` em caso de falha."

#: ../../library/stdtypes.rst:1140
msgid ""
"Like :meth:`rfind` but raises :exc:`ValueError` when the substring *sub* is "
"not found."
msgstr ""
"Similar a :meth:`rfind` mas levanta um :exc:`ValueError` quando a substring "
"*sub* não é encontrada."

#: ../../library/stdtypes.rst:1146
msgid ""
"Return the string right justified in a string of length *width*. Padding is "
"done using the specified *fillchar* (default is a space). The original "
"string is returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1156
msgid ""
"Split the string at the last occurrence of *sep*, and return a 3-tuple "
"containing the part before the separator, the separator itself, and the part"
" after the separator.  If the separator is not found, return a 3-tuple "
"containing two empty strings, followed by the string itself."
msgstr ""
"Quebra a string na última ocorrência de *sep*, e retorna uma tupla com 3 "
"elementos contendo a parte antes do separador, o próprio separator, e a "
"parte após o separador. Se o separador não for encontrado, retorna uma tupla"
" com 3 elementos contendo duas strings vazias, seguido da própria string "
"original."

#: ../../library/stdtypes.rst:1166
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string. If *maxsplit* is given, at most *maxsplit* splits are done, the "
"*rightmost* ones.  If *sep* is not specified or ``None``, any whitespace "
"string is a separator.  Except for splitting from the right, :meth:`rsplit` "
"behaves like :meth:`split` which is described in detail below."
msgstr ""
"Retorna uma lista de palavras na string, usando *sep* como a string "
"delimitadora. Se *maxsplit* é fornecido, no máximo *maxsplit* cortes são "
"feitos, sendo estes mais *à direita*. Se *sep* não foi especificado ou "
"``None`` foi informado, qualquer string de espaço em branco é um separador. "
"Exceto pelo fato de separar pela direita, :meth:`rsplit` se comporta como "
":meth:`split`, o qual é descrito em detalhes abaixo."

#: ../../library/stdtypes.rst:1177
msgid ""
"Return a copy of the string with trailing characters removed.  The *chars* "
"argument is a string specifying the set of characters to be removed.  If "
"omitted or ``None``, the *chars* argument defaults to removing whitespace.  "
"The *chars* argument is not a suffix; rather, all combinations of its values"
" are stripped:"
msgstr ""

#: ../../library/stdtypes.rst:1193
msgid ""
"Return a list of the words in the string, using *sep* as the delimiter "
"string.  If *maxsplit* is given, at most *maxsplit* splits are done (thus, "
"the list will have at most ``maxsplit+1`` elements).  If *maxsplit* is not "
"specified or ``-1``, then there is no limit on the number of splits (all "
"possible splits are made)."
msgstr ""
"Retorna uma lista de palavras na string, usando *sep* como a string "
"delimitadora. Se *maxsplit* é fornecido, no máximo *maxsplit* cortes são "
"feitos (portando, a lista terá no máximo ``maxsplit+1`` elementos). Se "
"*maxsplit* não foi especificado ou ``-1`` foi informado, então não existe "
"limite no número de cortes (todos os cortes possíveis são realizados)."

#: ../../library/stdtypes.rst:1199
msgid ""
"If *sep* is given, consecutive delimiters are not grouped together and are "
"deemed to delimit empty strings (for example, ``'1,,2'.split(',')`` returns "
"``['1', '', '2']``).  The *sep* argument may consist of multiple characters "
"(for example, ``'1<>2<>3'.split('<>')`` returns ``['1', '2', '3']``). "
"Splitting an empty string with a specified separator returns ``['']``."
msgstr ""
"Se *sep* é fornecido, delimitadores consecutivos não são agrupados juntos e "
"eles são destinados para delimitar strings vazias (por exemplo "
"``'1,,2'.split(',')`` retorna ``['1', '', '2']``). O argumento *sep* pode "
"consistir de múltiplos caracteres (por exemplo, ``'1<>2<>3'.split('<>')`` "
"retorna ``['1', '2', '3']``). Separar uma string vazia com um separador "
"especificado retorna ``['']``."

#: ../../library/stdtypes.rst:1205
msgid ""
"If *sep* is not specified or is ``None``, a different splitting algorithm is"
" applied: runs of consecutive whitespace are regarded as a single separator,"
" and the result will contain no empty strings at the start or end if the "
"string has leading or trailing whitespace.  Consequently, splitting an empty"
" string or a string consisting of just whitespace with a ``None`` separator "
"returns ``[]``."
msgstr ""
"Se *sep* não for especificado ou for ``None``, um algoritmo diferente de "
"separação é aplicado: ocorrências consecutivas de espaços em branco são "
"consideradas como um separador único, e o resultado não conterá strings "
"vazias no início ou no final, se a string tiver espaços em branco no início "
"ou no final. Consequentemente, separar uma string vazia ou uma string que "
"consiste apenas de espaços em branco com o separador ``None``, retorna "
"``[]``."

#: ../../library/stdtypes.rst:1212
msgid ""
"For example, ``' 1  2   3  '.split()`` returns ``['1', '2', '3']``, and ``'"
"  1  2   3  '.split(None, 1)`` returns ``['1', '2   3  ']``."
msgstr ""

#: ../../library/stdtypes.rst:1221
msgid ""
"Return a list of the lines in the string, breaking at line boundaries. This "
"method uses the :term:`universal newlines` approach to splitting lines. Line"
" breaks are not included in the resulting list unless *keepends* is given "
"and true."
msgstr ""

#: ../../library/stdtypes.rst:1226
msgid ""
"Python recognizes ``\"\\r\"``, ``\"\\n\"``, and ``\"\\r\\n\"`` as line "
"boundaries for 8-bit strings."
msgstr ""

#: ../../library/stdtypes.rst:1229
msgid "For example::"
msgstr "Por exemplo::"

#: ../../library/stdtypes.rst:1236
msgid ""
"Unlike :meth:`~str.split` when a delimiter string *sep* is given, this "
"method returns an empty list for the empty string, and a terminal line break"
" does not result in an extra line::"
msgstr ""
"Ao contrário do método :meth:`~str.split` quando um delimitador de String "
"*sep* é fornecido, este método retorna uma lista vazia para a uma String "
"vazia e uma quebra de linha de terminal não resulta numa linha extra::"

#: ../../library/stdtypes.rst:1245
msgid "For comparison, ``split('\\n')`` gives::"
msgstr "Para comparação, temos ``split('\\n')``::"

#: ../../library/stdtypes.rst:1254
msgid ""
"Return a list of the lines in the string, like :meth:`str.splitlines`. "
"However, the Unicode method splits on the following line boundaries, which "
"are a superset of the :term:`universal newlines` recognized for 8-bit "
"strings."
msgstr ""

#: ../../library/stdtypes.rst:1260
msgid "Representation"
msgstr "Representação"

#: ../../library/stdtypes.rst:1260
msgid "Description"
msgstr "Descrição"

#: ../../library/stdtypes.rst:1262
msgid "``\\n``"
msgstr "``\\n``"

#: ../../library/stdtypes.rst:1262
msgid "Line Feed"
msgstr "Feed de linha"

#: ../../library/stdtypes.rst:1264
msgid "``\\r``"
msgstr "``\\r``"

#: ../../library/stdtypes.rst:1264
msgid "Carriage Return"
msgstr "Retorno de Carro"

#: ../../library/stdtypes.rst:1266
msgid "``\\r\\n``"
msgstr "``\\r\\n``"

#: ../../library/stdtypes.rst:1266
msgid "Carriage Return + Line Feed"
msgstr "Retorno do Carro + Feed da Linha"

#: ../../library/stdtypes.rst:1268
msgid "``\\v`` or ``\\x0b``"
msgstr "``\\v`` ou ``\\x0b``"

#: ../../library/stdtypes.rst:1268
msgid "Line Tabulation"
msgstr "Tabulação de Linha"

#: ../../library/stdtypes.rst:1270
msgid "``\\f`` or ``\\x0c``"
msgstr "``\\f`` ou ``\\x0c``"

#: ../../library/stdtypes.rst:1270
msgid "Form Feed"
msgstr "Formulário de Feed"

#: ../../library/stdtypes.rst:1272
msgid "``\\x1c``"
msgstr "``\\x1c``"

#: ../../library/stdtypes.rst:1272
msgid "File Separator"
msgstr "Separador de Arquivos"

#: ../../library/stdtypes.rst:1274
msgid "``\\x1d``"
msgstr "``\\x1d``"

#: ../../library/stdtypes.rst:1274
msgid "Group Separator"
msgstr "Separador de Grupo"

#: ../../library/stdtypes.rst:1276
msgid "``\\x1e``"
msgstr "``\\x1e``"

#: ../../library/stdtypes.rst:1276
msgid "Record Separator"
msgstr "Separador de Registro"

#: ../../library/stdtypes.rst:1278
msgid "``\\x85``"
msgstr "``\\x85``"

#: ../../library/stdtypes.rst:1278
msgid "Next Line (C1 Control Code)"
msgstr "Próxima Linha (C1 Control Code)"

#: ../../library/stdtypes.rst:1280
msgid "``\\u2028``"
msgstr "``\\u2028``"

#: ../../library/stdtypes.rst:1280
msgid "Line Separator"
msgstr "Separador de Linha"

#: ../../library/stdtypes.rst:1282
msgid "``\\u2029``"
msgstr "``\\u2029``"

#: ../../library/stdtypes.rst:1282
msgid "Paragraph Separator"
msgstr "Parágrafo Separador"

#: ../../library/stdtypes.rst:1287
msgid "``\\v`` and ``\\f`` added to list of line boundaries."
msgstr "``\\v`` e ``\\f`` adicionado à lista de limites de linha."

#: ../../library/stdtypes.rst:1292
msgid ""
"Return ``True`` if string starts with the *prefix*, otherwise return "
"``False``. *prefix* can also be a tuple of prefixes to look for.  With "
"optional *start*, test string beginning at that position.  With optional "
"*end*, stop comparing string at that position."
msgstr ""
"Retorne ``True`` se a String começar com o *prefixo*, caso contrário, "
"retorna ``False``. *prefixo* também pode ser uma tupla de prefixos a serem "
"procurados. Com *start* opcional, a String de teste começa nessa posição. "
"Com *fim* opcional, interrompe a comparação de String nessa posição."

#: ../../library/stdtypes.rst:1297
msgid "Accept tuples as *prefix*."
msgstr ""

#: ../../library/stdtypes.rst:1303
msgid ""
"Return a copy of the string with the leading and trailing characters "
"removed. The *chars* argument is a string specifying the set of characters "
"to be removed. If omitted or ``None``, the *chars* argument defaults to "
"removing whitespace. The *chars* argument is not a prefix or suffix; rather,"
" all combinations of its values are stripped:"
msgstr ""

#: ../../library/stdtypes.rst:1320
msgid ""
"Return a copy of the string with uppercase characters converted to lowercase"
" and vice versa."
msgstr ""

#: ../../library/stdtypes.rst:1328
msgid ""
"Return a titlecased version of the string where words start with an "
"uppercase character and the remaining characters are lowercase."
msgstr ""
"Retorna uma versão titlecased da string, onde palavras iniciam com um "
"caractere com letra maiúscula e os caracteres restantes são em letras "
"minúsculas."

#: ../../library/stdtypes.rst:1331
msgid ""
"The algorithm uses a simple language-independent definition of a word as "
"groups of consecutive letters.  The definition works in many contexts but it"
" means that apostrophes in contractions and possessives form word "
"boundaries, which may not be the desired result::"
msgstr ""
"O algoritmo usa uma definição simples independente de idioma para uma "
"palavra, como grupos de letras consecutivas. A definição funciona em muitos "
"contextos, mas isso significa que apóstrofes em contradições e possessivos "
"formam limites de palavras, os quais podem não ser o resultado desejado::"

#: ../../library/stdtypes.rst:1339
msgid ""
"A workaround for apostrophes can be constructed using regular expressions::"
msgstr ""
"Uma solução alternativa para os apóstrofes pode ser construída usando "
"expressões regulares::"

#: ../../library/stdtypes.rst:1356
msgid ""
"Return a copy of the string where all characters occurring in the optional "
"argument *deletechars* are removed, and the remaining characters have been "
"mapped through the given translation table, which must be a string of length"
" 256."
msgstr ""

#: ../../library/stdtypes.rst:1361
msgid ""
"You can use the :func:`~string.maketrans` helper function in the "
":mod:`string` module to create a translation table. For string objects, set "
"the *table* argument to ``None`` for translations that only delete "
"characters:"
msgstr ""

#: ../../library/stdtypes.rst:1368
msgid "Support for a ``None`` *table* argument."
msgstr ""

#: ../../library/stdtypes.rst:1371
msgid ""
"For Unicode objects, the :meth:`translate` method does not accept the "
"optional *deletechars* argument.  Instead, it returns a copy of the *s* "
"where all characters have been mapped through the given translation table "
"which must be a mapping of Unicode ordinals to Unicode ordinals, Unicode "
"strings or ``None``. Unmapped characters are left untouched. Characters "
"mapped to ``None`` are deleted.  Note, a more flexible approach is to create"
" a custom character mapping codec using the :mod:`codecs` module (see "
":mod:`encodings.cp1251` for an example)."
msgstr ""

#: ../../library/stdtypes.rst:1383
msgid ""
"Return a copy of the string with all the cased characters [4]_ converted to "
"uppercase.  Note that ``s.upper().isupper()`` might be ``False`` if ``s`` "
"contains uncased characters or if the Unicode category of the resulting "
"character(s) is not \"Lu\" (Letter, uppercase), but e.g. \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Retorna uma cópia da string com todos os caracteres que permitem maiúsculo e"
" minúsculo [4]_ convertidos para letras maiúsculas. Perceba que "
"``s.upper().isupper()`` pode ser ``False`` se ``s`` contiver caracteres que "
"não possuem maiúsculas e minúsculas, ou se a categoria Unicode do(s) "
"caractere(s) resultante(s) não for \"Lu\" (Letra maiúscula), mas por ex "
"\"Lt\" (Letra em titlecase)."

#: ../../library/stdtypes.rst:1393
msgid ""
"Return the numeric string left filled with zeros in a string of length "
"*width*.  A sign prefix is handled correctly.  The original string is "
"returned if *width* is less than or equal to ``len(s)``."
msgstr ""

#: ../../library/stdtypes.rst:1400
msgid "The following methods are present only on unicode objects:"
msgstr ""

#: ../../library/stdtypes.rst:1404
msgid ""
"Return ``True`` if there are only numeric characters in S, ``False`` "
"otherwise. Numeric characters include digit characters, and all characters "
"that have the Unicode numeric value property, e.g. U+2155, VULGAR FRACTION "
"ONE FIFTH."
msgstr ""

#: ../../library/stdtypes.rst:1411
msgid ""
"Return ``True`` if there are only decimal characters in S, ``False`` "
"otherwise. Decimal characters include digit characters, and all characters "
"that can be used to form decimal-radix numbers, e.g. U+0660, ARABIC-INDIC "
"DIGIT ZERO."
msgstr ""

#: ../../library/stdtypes.rst:1420
msgid "String Formatting Operations"
msgstr ""

#: ../../library/stdtypes.rst:1432
msgid ""
"String and Unicode objects have one unique built-in operation: the ``%`` "
"operator (modulo).  This is also known as the string *formatting* or "
"*interpolation* operator.  Given ``format % values`` (where *format* is a "
"string or Unicode object), ``%`` conversion specifications in *format* are "
"replaced with zero or more elements of *values*.  The effect is similar to "
"the using :c:func:`sprintf` in the C language.  If *format* is a Unicode "
"object, or if any of the objects being converted using the ``%s`` conversion"
" are Unicode objects, the result will also be a Unicode object."
msgstr ""

#: ../../library/stdtypes.rst:1441
msgid ""
"If *format* requires a single argument, *values* may be a single non-tuple "
"object. [5]_  Otherwise, *values* must be a tuple with exactly the number of"
" items specified by the format string, or a single mapping object (for "
"example, a dictionary)."
msgstr ""
"Se *format* precisar de um único operador, *valores* podem ser objetos "
"simples ou que não sejam uma tupla. [5]_  Caso contrário, *valores* "
"precisarão ser uma tupla com exatamente o número de itens especificados pela"
" string de formatação, ou um único mapa de objetos (por exemplo, um "
"dicionário)."

#: ../../library/stdtypes.rst:1446
msgid ""
"A conversion specifier contains two or more characters and has the following"
" components, which must occur in this order:"
msgstr ""
"Um especificador de conversão contém dois ou mais caracteres e tem os "
"seguintes componentes, que devem aparecer nesta ordem:"

#: ../../library/stdtypes.rst:1449
msgid "The ``'%'`` character, which marks the start of the specifier."
msgstr "O caractere ``'%'``, que determina o início do especificador."

#: ../../library/stdtypes.rst:1451
msgid ""
"Mapping key (optional), consisting of a parenthesised sequence of characters"
" (for example, ``(somename)``)."
msgstr ""
"Mapeamento de Chaves (opcional), consistindo de uma sequência entre "
"parênteses de caracteres (por exemplo, ``(algumnome)``)."

#: ../../library/stdtypes.rst:1454
msgid ""
"Conversion flags (optional), which affect the result of some conversion "
"types."
msgstr ""
"Flags de conversão (opcional), que afetam o resultado de alguns tipos de "
"conversão."

#: ../../library/stdtypes.rst:1457
msgid ""
"Minimum field width (optional).  If specified as an ``'*'`` (asterisk), the "
"actual width is read from the next element of the tuple in *values*, and the"
" object to convert comes after the minimum field width and optional "
"precision."
msgstr ""
"Largura mínima do Campo(opcional). Se for especificado por ``'*'`` "
"(asterisco), a largura real será lida a partir do próximo elemento da tupla "
"em *values* e o objeto a converter virá após a largura mínima do campo e a "
"precisão que é opcional."

#: ../../library/stdtypes.rst:1461
msgid ""
"Precision (optional), given as a ``'.'`` (dot) followed by the precision.  "
"If specified as ``'*'`` (an asterisk), the actual width is read from the "
"next element of the tuple in *values*, and the value to convert comes after "
"the precision."
msgstr ""

#: ../../library/stdtypes.rst:1466
msgid "Length modifier (optional)."
msgstr "Modificador de Comprimento(opcional)."

#: ../../library/stdtypes.rst:1468
msgid "Conversion type."
msgstr "Tipos de Conversão"

#: ../../library/stdtypes.rst:1470
msgid ""
"When the right argument is a dictionary (or other mapping type), then the "
"formats in the string *must* include a parenthesised mapping key into that "
"dictionary inserted immediately after the ``'%'`` character. The mapping key"
" selects the value to be formatted from the mapping.  For example:"
msgstr ""
"Quando o argumento certo for um dicionário (ou outro tipo de mapeamento), "
"então os formatos na string *deverão* incluir uma chave de mapeamento entre "
"parênteses nesse dicionário inserido imediatamente após o caractere ``'%'``."
" A key de mapeamento seleciona o valor a ser formatado a partir do "
"mapeamento. Por exemplo:"

#: ../../library/stdtypes.rst:1479
msgid ""
"In this case no ``*`` specifiers may occur in a format (since they require a"
" sequential parameter list)."
msgstr ""
"Nesse caso, nenhum especificador ``*`` poderá ocorrer num formato (uma vez "
"que eles exigem uma lista de parâmetros sequenciais)."

#: ../../library/stdtypes.rst:1482
msgid "The conversion flag characters are:"
msgstr "Os caracteres flags de conversão são:"

#: ../../library/stdtypes.rst:1485
msgid "Flag"
msgstr "Flag"

#: ../../library/stdtypes.rst:1487
msgid "``'#'``"
msgstr "``'#'``"

#: ../../library/stdtypes.rst:1487
msgid ""
"The value conversion will use the \"alternate form\" (where defined below)."
msgstr ""
"A conversão de valor usará o \"formulário alternativo\" (em que definimos "
"abaixo)."

#: ../../library/stdtypes.rst:1490
msgid "``'0'``"
msgstr "``'0'``"

#: ../../library/stdtypes.rst:1490
msgid "The conversion will be zero padded for numeric values."
msgstr "A conversão será preenchida por zeros para valores numéricos."

#: ../../library/stdtypes.rst:1492
msgid "``'-'``"
msgstr "``'-'``"

#: ../../library/stdtypes.rst:1492
msgid ""
"The converted value is left adjusted (overrides the ``'0'`` conversion if "
"both are given)."
msgstr ""
"O valor convertido será ajustado à esquerda (substitui a conversão ``'0'`` "
"se ambos forem fornecidos)."

#: ../../library/stdtypes.rst:1495
msgid "``' '``"
msgstr "``' '``"

#: ../../library/stdtypes.rst:1495
msgid ""
"(a space) A blank should be left before a positive number (or empty string) "
"produced by a signed conversion."
msgstr ""
"(um espaço) Um espaço em branco deverá ser deixado antes de um número "
"positivo (ou uma String vazia) produzido por uma conversão assinada."

#: ../../library/stdtypes.rst:1498
msgid "``'+'``"
msgstr "``'+'``"

#: ../../library/stdtypes.rst:1498
msgid ""
"A sign character (``'+'`` or ``'-'``) will precede the conversion (overrides"
" a \"space\" flag)."
msgstr ""
"Um sinal de caractere (``'+'`` or ``'-'``) precedera a conversão "
"(substituindo o sinalizador \"space\")."

#: ../../library/stdtypes.rst:1502
msgid ""
"A length modifier (``h``, ``l``, or ``L``) may be present, but is ignored as"
" it is not necessary for Python -- so e.g. ``%ld`` is identical to ``%d``."
msgstr ""
"Um modificador de comprimento (``h``, ``l``, ou ``L``) pode estar presente, "
"mas será ignorado, pois o mesmo não é necessário para o Python -- então por "
"exemplo ``%ld`` é idêntico a ``%d``."

#: ../../library/stdtypes.rst:1505
msgid "The conversion types are:"
msgstr "Os tipos de conversão são:"

#: ../../library/stdtypes.rst:1508
msgid "Conversion"
msgstr "Conversão"

#: ../../library/stdtypes.rst:1510
msgid "``'d'``"
msgstr "``'d'``"

#: ../../library/stdtypes.rst:1510 ../../library/stdtypes.rst:1512
msgid "Signed integer decimal."
msgstr "Número decimal inteiro sinalizador."

#: ../../library/stdtypes.rst:1512
msgid "``'i'``"
msgstr "``'i'``"

#: ../../library/stdtypes.rst:1514
msgid "``'o'``"
msgstr "``'o'``"

#: ../../library/stdtypes.rst:1514
msgid "Signed octal value."
msgstr "Valor octal sinalizador."

#: ../../library/stdtypes.rst:1516
msgid "``'u'``"
msgstr "``'u'``"

#: ../../library/stdtypes.rst:1516
msgid "Obsolete type -- it is identical to ``'d'``."
msgstr "Tipo obsoleto - é idêntico a ``'d'``."

#: ../../library/stdtypes.rst:1518
msgid "``'x'``"
msgstr "``'x'``"

#: ../../library/stdtypes.rst:1518
msgid "Signed hexadecimal (lowercase)."
msgstr "Sinalizador hexadecimal (minúsculas)."

#: ../../library/stdtypes.rst:1520
msgid "``'X'``"
msgstr "``'X'``"

#: ../../library/stdtypes.rst:1520
msgid "Signed hexadecimal (uppercase)."
msgstr "Sinalizador hexadecimal (maiúscula)."

#: ../../library/stdtypes.rst:1522
msgid "``'e'``"
msgstr "``'e'``"

#: ../../library/stdtypes.rst:1522
msgid "Floating point exponential format (lowercase)."
msgstr "Formato exponencial de ponto flutuante (minúsculas)."

#: ../../library/stdtypes.rst:1524
msgid "``'E'``"
msgstr "``'E'``"

#: ../../library/stdtypes.rst:1524
msgid "Floating point exponential format (uppercase)."
msgstr "Floating point exponential format (uppercase)."

#: ../../library/stdtypes.rst:1526
msgid "``'f'``"
msgstr "``'f'``"

#: ../../library/stdtypes.rst:1526 ../../library/stdtypes.rst:1528
msgid "Floating point decimal format."
msgstr "Formato decimal de ponto flutuante."

#: ../../library/stdtypes.rst:1528
msgid "``'F'``"
msgstr "``'F'``"

#: ../../library/stdtypes.rst:1530
msgid "``'g'``"
msgstr "``'g'``"

#: ../../library/stdtypes.rst:1530
msgid ""
"Floating point format. Uses lowercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr ""
"O formato de ponto flutuante. Usa o formato exponencial em minúsculas se o "
"expoente for inferior a -4 ou não inferior a precisão, formato decimal, caso"
" contrário."

#: ../../library/stdtypes.rst:1534
msgid "``'G'``"
msgstr "``'G'``"

#: ../../library/stdtypes.rst:1534
msgid ""
"Floating point format. Uses uppercase exponential format if exponent is less"
" than -4 or not less than precision, decimal format otherwise."
msgstr ""
"Formato de ponto flutuante. Usa o formato exponencial em maiúsculas se o "
"expoente for inferior a -4 ou não inferior que a precisão, formato decimal, "
"caso contrário."

#: ../../library/stdtypes.rst:1538
msgid "``'c'``"
msgstr "``'c'``"

#: ../../library/stdtypes.rst:1538
msgid "Single character (accepts integer or single character string)."
msgstr "Caráter único (aceita inteiro ou um único caractere String)."

#: ../../library/stdtypes.rst:1541
msgid "``'r'``"
msgstr "``'r'``"

#: ../../library/stdtypes.rst:1541
msgid "String (converts any Python object using :ref:`repr() <func-repr>`)."
msgstr ""

#: ../../library/stdtypes.rst:1541 ../../library/stdtypes.rst:1690
msgid "\\(5)"
msgstr "\\(5)"

#: ../../library/stdtypes.rst:1544
msgid "``'s'``"
msgstr "``'s'``"

#: ../../library/stdtypes.rst:1544
msgid "String (converts any Python object using :func:`str`)."
msgstr "String (converte qualquer objeto Python usando a função :func:`str`)."

#: ../../library/stdtypes.rst:1547
msgid "``'%'``"
msgstr "``'%'``"

#: ../../library/stdtypes.rst:1547
msgid ""
"No argument is converted, results in a ``'%'`` character in the result."
msgstr ""
"Nenhum argumento é convertido, resultando um caractere ``''%'`` no "
"resultado."

#: ../../library/stdtypes.rst:1554
msgid ""
"The alternate form causes a leading zero (``'0'``) to be inserted between "
"left-hand padding and the formatting of the number if the leading character "
"of the result is not already a zero."
msgstr ""

#: ../../library/stdtypes.rst:1559
msgid ""
"The alternate form causes a leading ``'0x'`` or ``'0X'`` (depending on "
"whether the ``'x'`` or ``'X'`` format was used) to be inserted before the "
"first digit."
msgstr ""
"O formato alternativo produz um ``'0x'`` ou ``'0X'``  (dependendo se o "
"formato  ``'x'`` or ``'X'`` foi usado) para ser inserido antes do primeiro "
"dígito."

#: ../../library/stdtypes.rst:1563
msgid ""
"The alternate form causes the result to always contain a decimal point, even"
" if no digits follow it."
msgstr ""
"A forma alternativa faz com que o resultado sempre contenha um ponto "
"decimal, mesmo que nenhum dígito o siga."

#: ../../library/stdtypes.rst:1566
msgid ""
"The precision determines the number of digits after the decimal point and "
"defaults to 6."
msgstr ""
"A precisão determina o número de dígitos após o ponto decimal e o padrão é "
"6."

#: ../../library/stdtypes.rst:1570
msgid ""
"The alternate form causes the result to always contain a decimal point, and "
"trailing zeroes are not removed as they would otherwise be."
msgstr ""
"A forma alternativa faz com que o resultado sempre contenha um ponto decimal"
" e os zeros à direita não sejam removidos, como de outra forma seriam."

#: ../../library/stdtypes.rst:1573
msgid ""
"The precision determines the number of significant digits before and after "
"the decimal point and defaults to 6."
msgstr ""
"A precisão determina o número de dígitos significativos antes e depois do "
"ponto decimal e o padrão é 6."

#: ../../library/stdtypes.rst:1577
msgid "The ``%r`` conversion was added in Python 2.0."
msgstr ""

#: ../../library/stdtypes.rst:1579 ../../library/stdtypes.rst:1585
msgid "The precision determines the maximal number of characters used."
msgstr ""

#: ../../library/stdtypes.rst:1582
msgid ""
"If the object or format provided is a :class:`unicode` string, the resulting"
" string will also be :class:`unicode`."
msgstr ""

#: ../../library/stdtypes.rst:1588
msgid "See :pep:`237`."
msgstr "Veja :pep:`237`."

#: ../../library/stdtypes.rst:1590
msgid ""
"Since Python strings have an explicit length, ``%s`` conversions do not "
"assume that ``'\\0'`` is the end of the string."
msgstr ""
"Como as Strings do Python possuem comprimento explícito, ``%s`` as "
"conversões não assumem que ``'\\0'`` é o fim da string."

#: ../../library/stdtypes.rst:1595
msgid ""
"``%f`` conversions for numbers whose absolute value is over 1e50 are no "
"longer replaced by ``%g`` conversions."
msgstr ""
"``%f`` as conversões para números cujo valor absoluto é superior a 1e50 não "
"são mais substituídas pela conversão ``%g``."

#: ../../library/stdtypes.rst:1603
msgid ""
"Additional string operations are defined in standard modules :mod:`string` "
"and :mod:`re`."
msgstr ""

#: ../../library/stdtypes.rst:1610
msgid "XRange Type"
msgstr ""

#: ../../library/stdtypes.rst:1614
msgid ""
"The :class:`xrange` type is an immutable sequence which is commonly used for"
" looping.  The advantage of the :class:`xrange` type is that an "
":class:`xrange` object will always take the same amount of memory, no matter"
" the size of the range it represents.  There are no consistent performance "
"advantages."
msgstr ""

#: ../../library/stdtypes.rst:1619
msgid ""
"XRange objects have very little behavior: they only support indexing, "
"iteration, and the :func:`len` function."
msgstr ""

#: ../../library/stdtypes.rst:1626
msgid "Mutable Sequence Types"
msgstr "Tipos de Sequências Mutáveis"

#: ../../library/stdtypes.rst:1632
msgid ""
"List and :class:`bytearray` objects support additional operations that allow"
" in-place modification of the object. Other mutable sequence types (when "
"added to the language) should also support these operations. Strings and "
"tuples are immutable sequence types: such objects cannot be modified once "
"created. The following operations are defined on mutable sequence types "
"(where *x* is an arbitrary object):"
msgstr ""

#: ../../library/stdtypes.rst:1659
msgid "``s[i] = x``"
msgstr "``s[i] = x``"

#: ../../library/stdtypes.rst:1659
msgid "item *i* of *s* is replaced by *x*"
msgstr "item *i* de *s* é substituído por *x*"

#: ../../library/stdtypes.rst:1662
msgid "``s[i:j] = t``"
msgstr "``s[i:j] = t``"

#: ../../library/stdtypes.rst:1662
msgid ""
"slice of *s* from *i* to *j* is replaced by the contents of the iterable *t*"
msgstr ""
"fatias de *s* de *i* para *j* são substituídas pelo conteúdo do iterável *t*"

#: ../../library/stdtypes.rst:1666
msgid "``del s[i:j]``"
msgstr "``del s[i:j]``"

#: ../../library/stdtypes.rst:1666
msgid "same as ``s[i:j] = []``"
msgstr "o mesmo que ``s[i:j] = []``"

#: ../../library/stdtypes.rst:1668
msgid "``s[i:j:k] = t``"
msgstr "``s[i:j:k] = t``"

#: ../../library/stdtypes.rst:1668
msgid "the elements of ``s[i:j:k]`` are replaced by those of *t*"
msgstr "os elementos de ``s[i:j:k]`` são substituídos por aqueles de *t*"

#: ../../library/stdtypes.rst:1671
msgid "``del s[i:j:k]``"
msgstr "``del s[i:j:k]``"

#: ../../library/stdtypes.rst:1671
msgid "removes the elements of ``s[i:j:k]`` from the list"
msgstr "remove os elementos de ``s[i:j:k]`` desde a listas"

#: ../../library/stdtypes.rst:1674
msgid "``s.append(x)``"
msgstr "``s.append(x)``"

#: ../../library/stdtypes.rst:1674
msgid "same as ``s[len(s):len(s)] = [x]``"
msgstr ""

#: ../../library/stdtypes.rst:1677
msgid "``s.extend(t)`` or ``s += t``"
msgstr "``s.extend(t)`` ou ``s += t``"

#: ../../library/stdtypes.rst:1677
msgid "for the most part the same as ``s[len(s):len(s)] = t``"
msgstr ""

#: ../../library/stdtypes.rst:1680
msgid "``s *= n``"
msgstr "``s *= n``"

#: ../../library/stdtypes.rst:1680
msgid "updates *s* with its contents repeated *n* times"
msgstr "atualiza *s* com o seu conteúdo por *n* vezes"

#: ../../library/stdtypes.rst:1680
msgid "\\(11)"
msgstr ""

#: ../../library/stdtypes.rst:1683
msgid "return number of *i*'s for which ``s[i] == x``"
msgstr ""

#: ../../library/stdtypes.rst:1686
msgid "``s.index(x[, i[, j]])``"
msgstr "``s.index(x[, i[, j]])``"

#: ../../library/stdtypes.rst:1686
msgid "return smallest *k* such that ``s[k] == x`` and ``i <= k < j``"
msgstr ""

#: ../../library/stdtypes.rst:1690
msgid "``s.insert(i, x)``"
msgstr "``s.insert(i, x)``"

#: ../../library/stdtypes.rst:1690
msgid "same as ``s[i:i] = [x]``"
msgstr ""

#: ../../library/stdtypes.rst:1692
msgid "``s.pop([i])``"
msgstr "``s.pop([i])``"

#: ../../library/stdtypes.rst:1692
msgid "same as ``x = s[i]; del s[i]; return x``"
msgstr ""

#: ../../library/stdtypes.rst:1695
msgid "``s.remove(x)``"
msgstr "``s.remove(x)``"

#: ../../library/stdtypes.rst:1695
msgid "same as ``del s[s.index(x)]``"
msgstr ""

#: ../../library/stdtypes.rst:1697
msgid "``s.reverse()``"
msgstr "``s.reverse()``"

#: ../../library/stdtypes.rst:1697
msgid "reverses the items of *s* in place"
msgstr "inverte os itens de *s* no lugar"

#: ../../library/stdtypes.rst:1700
msgid "``s.sort([cmp[, key[, reverse]]])``"
msgstr ""

#: ../../library/stdtypes.rst:1700
msgid "sort the items of *s* in place"
msgstr ""

#: ../../library/stdtypes.rst:1700
msgid "(7)(8)(9)(10)"
msgstr ""

#: ../../library/stdtypes.rst:1707
msgid "*t* must have the same length as the slice it is  replacing."
msgstr ""

#: ../../library/stdtypes.rst:1710
msgid ""
"The C implementation of Python has historically accepted multiple parameters"
" and implicitly joined them into a tuple; this no longer works in Python "
"2.0.  Use of this misfeature has been deprecated since Python 1.4."
msgstr ""

#: ../../library/stdtypes.rst:1715
msgid "*t* can be any iterable object."
msgstr ""

#: ../../library/stdtypes.rst:1718
msgid ""
"Raises :exc:`ValueError` when *x* is not found in *s*. When a negative index"
" is passed as the second or third parameter to the :meth:`index` method, the"
" list length is added, as for slice indices.  If it is still negative, it is"
" truncated to zero, as for slice indices."
msgstr ""

#: ../../library/stdtypes.rst:1723
msgid ""
"Previously, :meth:`index` didn't have arguments for specifying start and "
"stop positions."
msgstr ""

#: ../../library/stdtypes.rst:1728
msgid ""
"When a negative index is passed as the first parameter to the :meth:`insert`"
" method, the list length is added, as for slice indices.  If it is still "
"negative, it is truncated to zero, as for slice indices."
msgstr ""

#: ../../library/stdtypes.rst:1732
msgid "Previously, all negative indices were truncated to zero."
msgstr ""

#: ../../library/stdtypes.rst:1736
msgid ""
"The :meth:`pop` method's optional argument *i* defaults to ``-1``, so that "
"by default the last item is removed and returned."
msgstr ""

#: ../../library/stdtypes.rst:1740
msgid ""
"The :meth:`sort` and :meth:`reverse` methods modify the list in place for "
"economy of space when sorting or reversing a large list.  To remind you that"
" they operate by side effect, they don't return the sorted or reversed list."
msgstr ""

#: ../../library/stdtypes.rst:1745
msgid ""
"The :meth:`sort` method takes optional arguments for controlling the "
"comparisons."
msgstr ""

#: ../../library/stdtypes.rst:1748
msgid ""
"*cmp* specifies a custom comparison function of two arguments (list items) "
"which should return a negative, zero or positive number depending on whether"
" the first argument is considered smaller than, equal to, or larger than the"
" second argument: ``cmp=lambda x,y: cmp(x.lower(), y.lower())``.  The "
"default value is ``None``."
msgstr ""

#: ../../library/stdtypes.rst:1754
msgid ""
"*key* specifies a function of one argument that is used to extract a "
"comparison key from each list element: ``key=str.lower``.  The default value"
" is ``None``."
msgstr ""

#: ../../library/stdtypes.rst:1757
msgid ""
"*reverse* is a boolean value.  If set to ``True``, then the list elements "
"are sorted as if each comparison were reversed."
msgstr ""
"*reverse* é um valor booleano.  Se definido igual a ``True``, então os "
"elementos da lista são classificados como se cada comparação fosse reversa."

#: ../../library/stdtypes.rst:1760
msgid ""
"In general, the *key* and *reverse* conversion processes are much faster "
"than specifying an equivalent *cmp* function.  This is because *cmp* is "
"called multiple times for each list element while *key* and *reverse* touch "
"each element only once.  Use :func:`functools.cmp_to_key` to convert an old-"
"style *cmp* function to a *key* function."
msgstr ""

#: ../../library/stdtypes.rst:1766
msgid "Support for ``None`` as an equivalent to omitting *cmp* was added."
msgstr ""

#: ../../library/stdtypes.rst:1769
msgid "Support for *key* and *reverse* was added."
msgstr ""

#: ../../library/stdtypes.rst:1773
msgid ""
"Starting with Python 2.3, the :meth:`sort` method is guaranteed to be "
"stable.  A sort is stable if it guarantees not to change the relative order "
"of elements that compare equal --- this is helpful for sorting in multiple "
"passes (for example, sort by department, then by salary grade)."
msgstr ""

#: ../../library/stdtypes.rst:1781
msgid ""
"While a list is being sorted, the effect of attempting to mutate, or even "
"inspect, the list is undefined.  The C implementation of Python 2.3 and "
"newer makes the list appear empty for the duration, and raises "
":exc:`ValueError` if it can detect that the list has been mutated during a "
"sort."
msgstr ""

#: ../../library/stdtypes.rst:1788
msgid ""
"The value *n* is an integer, or an object implementing "
":meth:`~object.__index__`.  Zero and negative values of *n* clear the "
"sequence.  Items in the sequence are not copied; they are referenced "
"multiple times, as explained for ``s * n`` under :ref:`typesseq`."
msgstr ""

#: ../../library/stdtypes.rst:1797
msgid "Set Types --- :class:`set`, :class:`frozenset`"
msgstr "Tipo Set --- :class:`set`, :class:`frozenset`"

#: ../../library/stdtypes.rst:1801
msgid ""
"A :dfn:`set` object is an unordered collection of distinct :term:`hashable` "
"objects. Common uses include membership testing, removing duplicates from a "
"sequence, and computing mathematical operations such as intersection, union,"
" difference, and symmetric difference. (For other containers see the built "
"in :class:`dict`, :class:`list`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ""

#: ../../library/stdtypes.rst:1811
msgid ""
"Like other collections, sets support ``x in set``, ``len(set)``, and ``for x"
" in set``.  Being an unordered collection, sets do not record element "
"position or order of insertion.  Accordingly, sets do not support indexing, "
"slicing, or other sequence-like behavior."
msgstr ""
"Assim como outras coleções, sets suportam ``x in set``, ``len(set)``, e "
"``for x in set``. Sendo uma coleção não ordenada, sets não armazenam posição"
" de elementos ou ordem de inserção. Portanto, sets não suportam indexação, "
"slicing, ou outros comportamentos similares de sequências."

#: ../../library/stdtypes.rst:1816
msgid ""
"There are currently two built-in set types, :class:`set` and "
":class:`frozenset`. The :class:`set` type is mutable --- the contents can be"
" changed using methods like :meth:`~set.add` and :meth:`~set.remove`.  Since"
" it is mutable, it has no hash value and cannot be used as either a "
"dictionary key or as an element of another set.  The :class:`frozenset` type"
" is immutable and :term:`hashable` --- its contents cannot be altered after "
"it is created; it can therefore be used as a dictionary key or as an element"
" of another set."
msgstr ""
"Existem atualmente dois tipos de set embutidos, :class:`set` e "
":class:`frozenset`. O tipo :class:`set` é mutável --- o conteúdo pode ser "
"alterado usando métodos como :meth:`~set.add` e :meth:`~set.remove`. Como "
"ele é mutável, ele não tem valor hash e não pode ser usado como chave de "
"dicionário ou um elemento de um outro set. O tipo :class:`frozenset` é "
"imutável e :term:`hasheável <hashable>` --- seu conteúdo não pode ser "
"alterado depois de ter sido criado; ele pode então ser usado como chave de "
"dicionário ou como um elemento de outro set."

#: ../../library/stdtypes.rst:1824
msgid ""
"As of Python 2.7, non-empty sets (not frozensets) can be created by placing "
"a comma-separated list of elements within braces, for example: ``{'jack', "
"'sjoerd'}``, in addition to the :class:`set` constructor."
msgstr ""

#: ../../library/stdtypes.rst:1828
msgid "The constructors for both classes work the same:"
msgstr "Os construtores de ambas as classes funcionam da mesma forma:"

#: ../../library/stdtypes.rst:1833
msgid ""
"Return a new set or frozenset object whose elements are taken from "
"*iterable*.  The elements of a set must be :term:`hashable`.  To represent "
"sets of sets, the inner sets must be :class:`frozenset` objects.  If "
"*iterable* is not specified, a new empty set is returned."
msgstr ""
"Retorna um novo objeto set ou frozenset, cujos elementos são obtidos a "
"partir de um *iterable*. Os elementos de um set devem ser :term:`hasheável "
"<hashable>`. Para representar sets de sets, os sets internos devem ser "
"objetos :class:`frozenset`. Se *iterable* não for especificado, um novo set "
"vazio é retornado."

#: ../../library/stdtypes.rst:1839
msgid ""
"Instances of :class:`set` and :class:`frozenset` provide the following "
"operations:"
msgstr ""
"Instâncias de :class:`set` e :class:`frozenset` fornecem as seguintes "
"operações:"

#: ../../library/stdtypes.rst:1844
msgid "Return the number of elements in set *s* (cardinality of *s*)."
msgstr "Retorna o número de elementos no set *s* (cardinalidade de *s*)."

#: ../../library/stdtypes.rst:1848
msgid "Test *x* for membership in *s*."
msgstr "Testa se *x* pertence a *s*."

#: ../../library/stdtypes.rst:1852
msgid "Test *x* for non-membership in *s*."
msgstr "Testa se *x* não pertence a *s*."

#: ../../library/stdtypes.rst:1856
msgid ""
"Return ``True`` if the set has no elements in common with *other*.  Sets are"
" disjoint if and only if their intersection is the empty set."
msgstr ""
"Retorna ``True`` se o set não tem elementos em comum com *other*. Sets são "
"deslocados (disjoint) se e somente se a sua interseção é o conjunto vazio."

#: ../../library/stdtypes.rst:1864
msgid "Test whether every element in the set is in *other*."
msgstr "Testa se cada elemento do set está contido em *other*."

#: ../../library/stdtypes.rst:1868
msgid ""
"Test whether the set is a proper subset of *other*, that is, ``set <= other "
"and set != other``."
msgstr ""
"Testa se o set é um subconjunto próprio de *other*, isto é, ``set <= other "
"and set != other``."

#: ../../library/stdtypes.rst:1874
msgid "Test whether every element in *other* is in the set."
msgstr "Testa se cada elemento em *other* está contido no set."

#: ../../library/stdtypes.rst:1878
msgid ""
"Test whether the set is a proper superset of *other*, that is, ``set >= "
"other and set != other``."
msgstr ""
"Testa se o set é um superconjunto próprio de *other*, isto é, ``set >= other"
" and set != other``."

#: ../../library/stdtypes.rst:1884
msgid "Return a new set with elements from the set and all others."
msgstr ""
"Retorna um novo set com elementos do set e de todos que estão em others."

#: ../../library/stdtypes.rst:1886 ../../library/stdtypes.rst:1894
#: ../../library/stdtypes.rst:1902 ../../library/stdtypes.rst:1956
#: ../../library/stdtypes.rst:1964 ../../library/stdtypes.rst:1972
msgid "Accepts multiple input iterables."
msgstr ""

#: ../../library/stdtypes.rst:1892
msgid "Return a new set with elements common to the set and all others."
msgstr ""
"Retorna um novo set com elementos comuns ao set e todos que estão em others."

#: ../../library/stdtypes.rst:1900
msgid "Return a new set with elements in the set that are not in the others."
msgstr "Retorna um novo set com elementos no set que não estão em others."

#: ../../library/stdtypes.rst:1908
msgid ""
"Return a new set with elements in either the set or *other* but not both."
msgstr ""
"Retorna um novo set com elementos estejam ou no set ou em *other*, mas não "
"em ambos."

#: ../../library/stdtypes.rst:1912
msgid "Return a shallow copy of the set."
msgstr "Retorna uma cópia rasa do set."

#: ../../library/stdtypes.rst:1915
msgid ""
"Note, the non-operator versions of :meth:`union`, :meth:`intersection`, "
":meth:`difference`, and :meth:`symmetric_difference`, :meth:`issubset`, and "
":meth:`issuperset` methods will accept any iterable as an argument.  In "
"contrast, their operator based counterparts require their arguments to be "
"sets.  This precludes error-prone constructions like ``set('abc') & 'cbs'`` "
"in favor of the more readable ``set('abc').intersection('cbs')``."
msgstr ""
"Perceba que, as versões não-operador dos métodos :meth:`union`, "
":meth:`intersection`, :meth:`difference`, e :meth:`symmetric_difference`, "
":meth:`issubset`, e :meth:`issuperset` irão aceitar qualquer iterável como "
"um argumento. Em contraste, suas contrapartes baseadas em operadores exigem "
"que seus argumentos sejam conjuntos. Isso impede construções sucetíveis a "
"erros como ``set('abc') & 'cbs'`` e favorece a forma mais legível "
"``set('abc').intersection('cbs')``."

#: ../../library/stdtypes.rst:1922
msgid ""
"Both :class:`set` and :class:`frozenset` support set to set comparisons. Two"
" sets are equal if and only if every element of each set is contained in the"
" other (each is a subset of the other). A set is less than another set if "
"and only if the first set is a proper subset of the second set (is a subset,"
" but is not equal). A set is greater than another set if and only if the "
"first set is a proper superset of the second set (is a superset, but is not "
"equal)."
msgstr ""
"Tanto :class:`set` quanto :class:`frozenset` suportam comparar um set contra"
" outro set. Dois sets são iguais se e somente se, cada elemento de cada set "
"está contido no outro set (cada um é um subconjunto do outro). Um set é "
"menor que outro set se e somente se, o primeiro set é um subconjunto próprio"
" do segundo set (é um subconjunto, mas não é igual). Um set é maior que "
"outro set se e somente se, o primeiro set é um superconjunto próprio do "
"segundo set (é um superconjunto, mas não é igual)."

#: ../../library/stdtypes.rst:1929
msgid ""
"Instances of :class:`set` are compared to instances of :class:`frozenset` "
"based on their members.  For example, ``set('abc') == frozenset('abc')`` "
"returns ``True`` and so does ``set('abc') in set([frozenset('abc')])``."
msgstr ""
"Instâncias de :class:`set` são comparadas a instâncias de :class:`frozenset`"
" baseados nos seus membros. Por exemplo, ``set('abc') == frozenset('abc')`` "
"retorna ``True`` e assim como ``set('abc') in set([frozenset('abc')])``."

#: ../../library/stdtypes.rst:1933
msgid ""
"The subset and equality comparisons do not generalize to a total ordering "
"function.  For example, any two non-empty disjoint sets are not equal and "
"are not subsets of each other, so *all* of the following return ``False``: "
"``a<b``, ``a==b``, or ``a>b``. Accordingly, sets do not implement the "
":meth:`__cmp__` method."
msgstr ""

#: ../../library/stdtypes.rst:1939
msgid ""
"Since sets only define partial ordering (subset relationships), the output "
"of the :meth:`list.sort` method is undefined for lists of sets."
msgstr ""
"Como sets apenas definem ordenamento parcial (subset de relacionamentos), a "
"saída do método :meth:`list.sort` é indefinida para listas e sets."

#: ../../library/stdtypes.rst:1942
msgid "Set elements, like dictionary keys, must be :term:`hashable`."
msgstr ""
"Elementos set, assim como chaves de dicionário, devem ser :term:`hasheáveis "
"<hashable>`."

#: ../../library/stdtypes.rst:1944
msgid ""
"Binary operations that mix :class:`set` instances with :class:`frozenset` "
"return the type of the first operand.  For example: ``frozenset('ab') | "
"set('bc')`` returns an instance of :class:`frozenset`."
msgstr ""
"Operações binárias que misturam instâncias de :class:`set` com "
":class:`frozenset` retornam o tipo do primeiro operando. Por exemplo: "
"``frozenset('ab') | set('bc')`` retorna uma instância de :class:`frozenset`."

#: ../../library/stdtypes.rst:1948
msgid ""
"The following table lists operations available for :class:`set` that do not "
"apply to immutable instances of :class:`frozenset`:"
msgstr ""
"A seguinte tabela lista operações disponíveis para :class:`set` que não se "
"aplicam para instâncias imutáveis de :class:`frozenset`:"

#: ../../library/stdtypes.rst:1954
msgid "Update the set, adding elements from all others."
msgstr "Atualiza o set, adicionando elementos de others."

#: ../../library/stdtypes.rst:1962
msgid "Update the set, keeping only elements found in it and all others."
msgstr ""
"Atualiza o set, mantendo somente elementos encontrados nele e em others."

#: ../../library/stdtypes.rst:1970
msgid "Update the set, removing elements found in others."
msgstr "Atualiza o set, removendo elementos encontrados em others."

#: ../../library/stdtypes.rst:1978
msgid ""
"Update the set, keeping only elements found in either set, but not in both."
msgstr ""
"Atualiza o set, mantendo somente elementos encontrados em qualquer set, mas "
"não em ambos."

#: ../../library/stdtypes.rst:1982
msgid "Add element *elem* to the set."
msgstr "Adiciona o elemento *elem* ao set."

#: ../../library/stdtypes.rst:1986
msgid ""
"Remove element *elem* from the set.  Raises :exc:`KeyError` if *elem* is not"
" contained in the set."
msgstr ""
"Remove o elemento *elem* do set. Levanta :exc:`KeyError` se *elem* não "
"estiver contido no set."

#: ../../library/stdtypes.rst:1991
msgid "Remove element *elem* from the set if it is present."
msgstr "Remove o elemento *elem* do set se ele estiver presente."

#: ../../library/stdtypes.rst:1995
msgid ""
"Remove and return an arbitrary element from the set.  Raises :exc:`KeyError`"
" if the set is empty."
msgstr ""
"Remove e retorna um elemento arbitrário do set. Levanta :exc:`KeyError` se o"
" set estiver vazio."

#: ../../library/stdtypes.rst:2000
msgid "Remove all elements from the set."
msgstr "Remove todos os elementos do set."

#: ../../library/stdtypes.rst:2003
msgid ""
"Note, the non-operator versions of the :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, and "
":meth:`symmetric_difference_update` methods will accept any iterable as an "
"argument."
msgstr ""
"Perceba, as versões sem operator dos métodos :meth:`update`, "
":meth:`intersection_update`, :meth:`difference_update`, e "
":meth:`symmetric_difference_update` irão aceitar qualquer iterável como um "
"argumento."

#: ../../library/stdtypes.rst:2008
msgid ""
"Note, the *elem* argument to the :meth:`__contains__`, :meth:`remove`, and "
":meth:`discard` methods may be a set.  To support searching for an "
"equivalent frozenset, a temporary one is created from *elem*."
msgstr ""
"Perceba, o argumento *elem* para os métodos :meth:`__contains__`, "
":meth:`remove`, e :meth:`discard` pode ser um set. Para suportar pesquisas "
"por um frozenset equivalente, um frozenset temporário é criado a partir de "
"*elem*."

#: ../../library/stdtypes.rst:2015
msgid ":ref:`comparison-to-builtin-set`"
msgstr ""

#: ../../library/stdtypes.rst:2016
msgid "Differences between the :mod:`sets` module and the built-in set types."
msgstr ""

#: ../../library/stdtypes.rst:2022
msgid "Mapping Types --- :class:`dict`"
msgstr "Tipo de Mapeamento --- :class:`dict`"

#: ../../library/stdtypes.rst:2032
msgid ""
"A :term:`mapping` object maps :term:`hashable` values to arbitrary objects. "
"Mappings are mutable objects.  There is currently only one standard mapping "
"type, the :dfn:`dictionary`.  (For other containers see the built in "
":class:`list`, :class:`set`, and :class:`tuple` classes, and the "
":mod:`collections` module.)"
msgstr ""

#: ../../library/stdtypes.rst:2038
msgid ""
"A dictionary's keys are *almost* arbitrary values.  Values that are not "
":term:`hashable`, that is, values containing lists, dictionaries or other "
"mutable types (that are compared by value rather than by object identity) "
"may not be used as keys.  Numeric types used for keys obey the normal rules "
"for numeric comparison: if two numbers compare equal (such as ``1`` and "
"``1.0``) then they can be used interchangeably to index the same dictionary "
"entry.  (Note however, that since computers store floating-point numbers as "
"approximations it is usually unwise to use them as dictionary keys.)"
msgstr ""
"As chaves de um dicionário são *quase* valores arbitrários. Valores que não "
"são :term:`hasheáveis <hashable>`, isto é, valores contendo listas, "
"dicionários ou outros tipos mutáveis (que são comparados por valor ao invés "
"de por identidade do objeto) não devem ser usados como chaves. Tipos "
"numéricos usados para chaves obedecem as regras normais para comparação "
"numérica: se dois números comparados são iguais (tal como ``1`` e ``1.0``), "
"então eles podem ser usados intercambiavelmente para indexar a mesma entrada"
" no dicionário. (Perceba entretanto, que como computadores armazenam números"
" de ponto flutuante como aproximações, usualmente não é uma boa ideia "
"utilizá-los como chaves para dicionários.)"

#: ../../library/stdtypes.rst:2047
msgid ""
"Dictionaries can be created by placing a comma-separated list of ``key: "
"value`` pairs within braces, for example: ``{'jack': 4098, 'sjoerd': 4127}``"
" or ``{4098: 'jack', 4127: 'sjoerd'}``, or by the :class:`dict` constructor."
msgstr ""
"Dicionários podem ser criados posicionando uma lista de pares ``key: value``"
" separados por vírgula dentro de chaves, por exemplo: ``{'jack': 4098, "
"'sjoerd': 4127}`` ou ``{4098: 'jack', 4127: 'sjoerd'}``, ou usando o "
"construtor de :class:`dict`."

#: ../../library/stdtypes.rst:2055
msgid ""
"Return a new dictionary initialized from an optional positional argument and"
" a possibly empty set of keyword arguments."
msgstr ""
"Retorna um novo dicionário inicializado a partir de um argumento posicional "
"opcional, e um set de argumentos nomeados possivelmente vazio."

#: ../../library/stdtypes.rst:2058
msgid ""
"If no positional argument is given, an empty dictionary is created. If a "
"positional argument is given and it is a mapping object, a dictionary is "
"created with the same key-value pairs as the mapping object.  Otherwise, the"
" positional argument must be an :term:`iterable` object.  Each item in the "
"iterable must itself be an iterable with exactly two objects.  The first "
"object of each item becomes a key in the new dictionary, and the second "
"object the corresponding value.  If a key occurs more than once, the last "
"value for that key becomes the corresponding value in the new dictionary."
msgstr ""
"Se nenhum argumento posicional é fornecido, um dicionário vazio é criado. Se"
" um argumento posicional é fornecido e é um objeto de mapeamento, um "
"dicionário é criado com os mesmos pares de chave-valor que o objeto de "
"mapeamento. Caso contrário, o argumento posicional deve ser um objeto "
":term:`iterável <iterable>`. Cada item no iterável deve ser por si mesmo um "
"iterável com exatamente dois objetos. O primeiro objeto de cada item torna-"
"se a chave no novo dicionário, e o segundo objeto, o valor correspondente. "
"Se a chave ocorrer mais do que uma vez, o último valor para aquela chave "
"torna-se o valor correspondente no novo dicionário."

#: ../../library/stdtypes.rst:2068
msgid ""
"If keyword arguments are given, the keyword arguments and their values are "
"added to the dictionary created from the positional argument.  If a key "
"being added is already present, the value from the keyword argument replaces"
" the value from the positional argument."
msgstr ""
"Se argumentos nomeados são fornecidos, os argumentos nomeados e seus valores"
" são adicionados ao dicionário criado a partir do argumento posicional. Se "
"uma chave sendo adicionada já está presente, o valor do argumento nomeado "
"substitui o valor do argumento posicional."

#: ../../library/stdtypes.rst:2073
msgid ""
"To illustrate, the following examples all return a dictionary equal to "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"
msgstr ""
"Para ilustrar, os seguintes exemplos todos retornam um dicionário igual a "
"``{\"one\": 1, \"two\": 2, \"three\": 3}``::"

#: ../../library/stdtypes.rst:2084
msgid ""
"Providing keyword arguments as in the first example only works for keys that"
" are valid Python identifiers.  Otherwise, any valid keys can be used."
msgstr ""
"Fornecer argumentos nomeados conforme no primeiro exemplo somente funciona "
"para chaves que são identificadores válidos no Python. Caso contrário, "
"quaisquer chaves válidas podem ser usadas."

#: ../../library/stdtypes.rst:2089
msgid "Support for building a dictionary from keyword arguments added."
msgstr ""

#: ../../library/stdtypes.rst:2093
msgid ""
"These are the operations that dictionaries support (and therefore, custom "
"mapping types should support too):"
msgstr ""
"Estas são as operações que dicionários suportam (e portanto, tipos de "
"mapeamento personalizados devem suportar também):"

#: ../../library/stdtypes.rst:2098
msgid "Return the number of items in the dictionary *d*."
msgstr "Retorna o número de items no dicionário *d*."

#: ../../library/stdtypes.rst:2102
msgid ""
"Return the item of *d* with key *key*.  Raises a :exc:`KeyError` if *key* is"
" not in the map."
msgstr ""
"Retorna o item de *d* com a chave *key*. Levanta um :exc:`KeyError` se *key*"
" não estiver no mapeamento."

#: ../../library/stdtypes.rst:2107
msgid ""
"If a subclass of dict defines a method :meth:`__missing__` and *key* is not "
"present, the ``d[key]`` operation calls that method with the key *key* as "
"argument.  The ``d[key]`` operation then returns or raises whatever is "
"returned or raised by the ``__missing__(key)`` call. No other operations or "
"methods invoke :meth:`__missing__`. If :meth:`__missing__` is not defined, "
":exc:`KeyError` is raised. :meth:`__missing__` must be a method; it cannot "
"be an instance variable::"
msgstr ""
"Se uma subclasse de um dict define um método :meth:`__missing__` e *key* não"
" estiver presente, a operação ``d[key]`` chama aquele método com a chave "
"*key* como argumento. A operação ``d[key]`` então retorna ou levanta o que é"
" retornado ou levantado pela chamada de ``__missing__(key)``. Nenhuma "
"operação ou método invoca :meth:`__missing__`. Se :meth:`__missing__` não "
"for definido, então :exc:`KeyError` é levantado. :meth:`__missing__` deve "
"ser um método; ele não pode ser uma variável de instância::"

#: ../../library/stdtypes.rst:2125
msgid ""
"The example above shows part of the implementation of "
":class:`collections.Counter`.  A different ``__missing__`` method is used by"
" :class:`collections.defaultdict`."
msgstr ""
"O exemplo acima mostra parte da implementação de "
":class:`collections.Counter`. Um método ``__missing__`` diferente é usado "
"para :class:`collections.defaultdict`."

#: ../../library/stdtypes.rst:2129
msgid "Recognition of __missing__ methods of dict subclasses."
msgstr ""

#: ../../library/stdtypes.rst:2134
msgid "Set ``d[key]`` to *value*."
msgstr "Define ``d[key]`` para *value*."

#: ../../library/stdtypes.rst:2138
msgid ""
"Remove ``d[key]`` from *d*.  Raises a :exc:`KeyError` if *key* is not in the"
" map."
msgstr ""
"Remove ``d[key]`` desde o *d*.  Levanta uma exceção :exc:`KeyError` se *key*"
" não estiver em map."

#: ../../library/stdtypes.rst:2143
msgid "Return ``True`` if *d* has a key *key*, else ``False``."
msgstr "Retorna ``True`` se *d* tiver uma chave *key*, senão ``False``."

#: ../../library/stdtypes.rst:2149
msgid "Equivalent to ``not key in d``."
msgstr "Equivalente a ``not key in d``."

#: ../../library/stdtypes.rst:2155
msgid ""
"Return an iterator over the keys of the dictionary.  This is a shortcut for "
":meth:`iterkeys`."
msgstr ""

#: ../../library/stdtypes.rst:2160
msgid "Remove all items from the dictionary."
msgstr "Remove todos os itens do dicionário."

#: ../../library/stdtypes.rst:2164
msgid "Return a shallow copy of the dictionary."
msgstr "Retorna uma cópia superficial do dicionário."

#: ../../library/stdtypes.rst:2168
msgid ""
"Create a new dictionary with keys from *seq* and values set to *value*."
msgstr ""

#: ../../library/stdtypes.rst:2170
msgid ""
":func:`fromkeys` is a class method that returns a new dictionary. *value* "
"defaults to ``None``."
msgstr ""

#: ../../library/stdtypes.rst:2177
msgid ""
"Return the value for *key* if *key* is in the dictionary, else *default*. If"
" *default* is not given, it defaults to ``None``, so that this method never "
"raises a :exc:`KeyError`."
msgstr ""
"Retorna o valor para *key* se *key* está no dicionário, caso contrário "
"*default*. Se *default* não é fornecido, será usado o valor padrão ``None``,"
" de tal forma que este método nunca levanta um :exc:`KeyError`."

#: ../../library/stdtypes.rst:2183
msgid ""
"Test for the presence of *key* in the dictionary.  :meth:`has_key` is "
"deprecated in favor of ``key in d``."
msgstr ""

#: ../../library/stdtypes.rst:2188
msgid "Return a copy of the dictionary's list of ``(key, value)`` pairs."
msgstr ""

#: ../../library/stdtypes.rst:2192
msgid ""
"Keys and values are listed in an arbitrary order which is non-random, varies"
" across Python implementations, and depends on the dictionary's history of "
"insertions and deletions."
msgstr ""

#: ../../library/stdtypes.rst:2196
msgid ""
"If :meth:`items`, :meth:`keys`, :meth:`values`, :meth:`iteritems`, "
":meth:`iterkeys`, and :meth:`itervalues` are called with no intervening "
"modifications to the dictionary, the lists will directly correspond.  This "
"allows the creation of ``(value, key)`` pairs using :func:`zip`: ``pairs = "
"zip(d.values(), d.keys())``.  The same relationship holds for the "
":meth:`iterkeys` and :meth:`itervalues` methods: ``pairs = "
"zip(d.itervalues(), d.iterkeys())`` provides the same value for ``pairs``. "
"Another way to create the same list is ``pairs = [(v, k) for (k, v) in "
"d.iteritems()]``."
msgstr ""

#: ../../library/stdtypes.rst:2208
msgid ""
"Return an iterator over the dictionary's ``(key, value)`` pairs.  See the "
"note for :meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2211
msgid ""
"Using :meth:`iteritems` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:2218
msgid ""
"Return an iterator over the dictionary's keys.  See the note for "
":meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2221
msgid ""
"Using :meth:`iterkeys` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:2228
msgid ""
"Return an iterator over the dictionary's values.  See the note for "
":meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2231
msgid ""
"Using :meth:`itervalues` while adding or deleting entries in the dictionary "
"may raise a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""

#: ../../library/stdtypes.rst:2239
msgid ""
"Return a copy of the dictionary's list of keys.  See the note for "
":meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2244
msgid ""
"If *key* is in the dictionary, remove it and return its value, else return "
"*default*.  If *default* is not given and *key* is not in the dictionary, a "
":exc:`KeyError` is raised."
msgstr ""
"Se *key* está no dicionário, remove a mesma e retorna o seu valor, caso "
"contrário retorna *default*. Se *default* não foi fornecido e *key* não está"
" no dicionário, um :exc:`KeyError` é levantado."

#: ../../library/stdtypes.rst:2252
msgid ""
"Remove and return an arbitrary ``(key, value)`` pair from the dictionary."
msgstr ""

#: ../../library/stdtypes.rst:2254
msgid ""
":func:`popitem` is useful to destructively iterate over a dictionary, as "
"often used in set algorithms.  If the dictionary is empty, calling "
":func:`popitem` raises a :exc:`KeyError`."
msgstr ""

#: ../../library/stdtypes.rst:2260
msgid ""
"If *key* is in the dictionary, return its value.  If not, insert *key* with "
"a value of *default* and return *default*.  *default* defaults to ``None``."
msgstr ""
"Se *key* está no dicionário, retorna o seu valor. Se não, insere *key* com o"
" valor *default* e retorna *default*.  *default* por padrão usa o valor "
"``None``."

#: ../../library/stdtypes.rst:2266
msgid ""
"Update the dictionary with the key/value pairs from *other*, overwriting "
"existing keys.  Return ``None``."
msgstr ""
"Atualiza o dicionário com os pares chave/valor existente em *other*, "
"sobrescrevendo chaves existentes. Retorna ``None``."

#: ../../library/stdtypes.rst:2269
msgid ""
":func:`update` accepts either another dictionary object or an iterable of "
"key/value pairs (as tuples or other iterables of length two).  If keyword "
"arguments are specified, the dictionary is then updated with those key/value"
" pairs: ``d.update(red=1, blue=2)``."
msgstr ""

#: ../../library/stdtypes.rst:2274
msgid ""
"Allowed the argument to be an iterable of key/value pairs and allowed "
"keyword arguments."
msgstr ""

#: ../../library/stdtypes.rst:2280
msgid ""
"Return a copy of the dictionary's list of values.  See the note for "
":meth:`dict.items`."
msgstr ""

#: ../../library/stdtypes.rst:2285
msgid ""
"Return a new view of the dictionary's items (``(key, value)`` pairs).  See "
"below for documentation of view objects."
msgstr ""

#: ../../library/stdtypes.rst:2292
msgid ""
"Return a new view of the dictionary's keys.  See below for documentation of "
"view objects."
msgstr ""

#: ../../library/stdtypes.rst:2299
msgid ""
"Return a new view of the dictionary's values.  See below for documentation "
"of view objects."
msgstr ""

#: ../../library/stdtypes.rst:2304
msgid ""
"Dictionaries compare equal if and only if they have the same ``(key, "
"value)`` pairs."
msgstr ""

#: ../../library/stdtypes.rst:2311
msgid "Dictionary view objects"
msgstr "Objetos de visão de dicionário"

#: ../../library/stdtypes.rst:2313
msgid ""
"The objects returned by :meth:`dict.viewkeys`, :meth:`dict.viewvalues` and "
":meth:`dict.viewitems` are *view objects*.  They provide a dynamic view on "
"the dictionary's entries, which means that when the dictionary changes, the "
"view reflects these changes."
msgstr ""

#: ../../library/stdtypes.rst:2318
msgid ""
"Dictionary views can be iterated over to yield their respective data, and "
"support membership tests:"
msgstr ""
"Visões de dicionários podem ser iteradas para apresentar seus respectivos "
"dados, e suportar testes de existência:"

#: ../../library/stdtypes.rst:2323
msgid "Return the number of entries in the dictionary."
msgstr "Retorna o número de entradas no dicionário."

#: ../../library/stdtypes.rst:2327
msgid ""
"Return an iterator over the keys, values or items (represented as tuples of "
"``(key, value)``) in the dictionary."
msgstr ""
"Retorna um iterador sobre as chaves, valores ou items (representados como "
"tuplas de ``(key, value)``) no dicionário."

#: ../../library/stdtypes.rst:2330
msgid ""
"Keys and values are iterated over in an arbitrary order which is non-random,"
" varies across Python implementations, and depends on the dictionary's "
"history of insertions and deletions. If keys, values and items views are "
"iterated over with no intervening modifications to the dictionary, the order"
" of items will directly correspond.  This allows the creation of ``(value, "
"key)`` pairs using :func:`zip`: ``pairs = zip(d.values(), d.keys())``.  "
"Another way to create the same list is ``pairs = [(v, k) for (k, v) in "
"d.items()]``."
msgstr ""

#: ../../library/stdtypes.rst:2338
msgid ""
"Iterating views while adding or deleting entries in the dictionary may raise"
" a :exc:`RuntimeError` or fail to iterate over all entries."
msgstr ""
"Iterar sobre visões enquanto adiciona ou deleta entradas no dicionário pode "
"levantar um :exc:`RuntimeError` ou falhar a iteração sobre todas as "
"entradas."

#: ../../library/stdtypes.rst:2343
msgid ""
"Return ``True`` if *x* is in the underlying dictionary's keys, values or "
"items (in the latter case, *x* should be a ``(key, value)`` tuple)."
msgstr ""
"Retorna ``True`` se *x* está nas chaves, valores ou items do dicionário "
"subjacente (no último caso, *x* deve ser uma tupla de ``(key, value)``)."

#: ../../library/stdtypes.rst:2347
msgid ""
"Keys views are set-like since their entries are unique and hashable.  If all"
" values are hashable, so that (key, value) pairs are unique and hashable, "
"then the items view is also set-like.  (Values views are not treated as set-"
"like since the entries are generally not unique.)  Then these set operations"
" are available (\"other\" refers either to another view or a set):"
msgstr ""

#: ../../library/stdtypes.rst:2355
msgid ""
"Return the intersection of the dictview and the other object as a new set."
msgstr ""

#: ../../library/stdtypes.rst:2359
msgid "Return the union of the dictview and the other object as a new set."
msgstr ""

#: ../../library/stdtypes.rst:2363
msgid ""
"Return the difference between the dictview and the other object (all "
"elements in *dictview* that aren't in *other*) as a new set."
msgstr ""

#: ../../library/stdtypes.rst:2368
msgid ""
"Return the symmetric difference (all elements either in *dictview* or "
"*other*, but not in both) of the dictview and the other object as a new set."
msgstr ""

#: ../../library/stdtypes.rst:2372
msgid "An example of dictionary view usage::"
msgstr "Um exemplo da utilização da visualização de dicionário::"

#: ../../library/stdtypes.rst:2405
msgid "File Objects"
msgstr "Objetos File"

#: ../../library/stdtypes.rst:2413
msgid ""
"File objects are implemented using C's ``stdio`` package and can be created "
"with the built-in :func:`open` function.  File objects are also returned by "
"some other built-in functions and methods, such as :func:`os.popen` and "
":func:`os.fdopen` and the :meth:`makefile` method of socket objects. "
"Temporary files can be created using the :mod:`tempfile` module, and high-"
"level file operations such as copying, moving, and deleting files and "
"directories can be achieved with the :mod:`shutil` module."
msgstr ""

#: ../../library/stdtypes.rst:2422
msgid ""
"When a file operation fails for an I/O-related reason, the exception "
":exc:`IOError` is raised.  This includes situations where the operation is "
"not defined for some reason, like :meth:`seek` on a tty device or writing a "
"file opened for reading."
msgstr ""

#: ../../library/stdtypes.rst:2427
msgid "Files have the following methods:"
msgstr ""

#: ../../library/stdtypes.rst:2432
msgid ""
"Close the file.  A closed file cannot be read or written any more. Any "
"operation which requires that the file be open will raise a "
":exc:`ValueError` after the file has been closed.  Calling :meth:`close` "
"more than once is allowed."
msgstr ""

#: ../../library/stdtypes.rst:2436
msgid ""
"As of Python 2.5, you can avoid having to call this method explicitly if you"
" use the :keyword:`with` statement.  For example, the following code will "
"automatically close *f* when the :keyword:`with` block is exited::"
msgstr ""

#: ../../library/stdtypes.rst:2446
msgid ""
"In older versions of Python, you would have needed to do this to get the "
"same effect::"
msgstr ""

#: ../../library/stdtypes.rst:2458
msgid ""
"Not all \"file-like\" types in Python support use as a context manager for "
"the :keyword:`with` statement.  If your code is intended to work with any "
"file-like object, you can use the function :func:`contextlib.closing` "
"instead of using the object directly."
msgstr ""

#: ../../library/stdtypes.rst:2466
msgid ""
"Flush the internal buffer, like ``stdio``'s :c:func:`fflush`.  This may be a"
" no-op on some file-like objects."
msgstr ""

#: ../../library/stdtypes.rst:2471
msgid ""
":meth:`flush` does not necessarily write the file's data to disk.  Use "
":meth:`flush` followed by :func:`os.fsync` to ensure this behavior."
msgstr ""

#: ../../library/stdtypes.rst:2481
msgid ""
"Return the integer \"file descriptor\" that is used by the underlying "
"implementation to request I/O operations from the operating system.  This "
"can be useful for other, lower level interfaces that use file descriptors, "
"such as the :mod:`fcntl` module or :func:`os.read` and friends."
msgstr ""

#: ../../library/stdtypes.rst:2488
msgid ""
"File-like objects which do not have a real file descriptor should *not* "
"provide this method!"
msgstr ""

#: ../../library/stdtypes.rst:2494
msgid ""
"Return ``True`` if the file is connected to a tty(-like) device, else "
"``False``."
msgstr ""

#: ../../library/stdtypes.rst:2498
msgid ""
"If a file-like object is not associated with a real file, this method should"
" *not* be implemented."
msgstr ""

#: ../../library/stdtypes.rst:2504
msgid ""
"A file object is its own iterator, for example ``iter(f)`` returns *f* "
"(unless *f* is closed).  When a file is used as an iterator, typically in a "
":keyword:`for` loop (for example, ``for line in f: print line.strip()``), "
"the :meth:`~file.next` method is called repeatedly.  This method returns the"
" next input line, or raises :exc:`StopIteration` when EOF is hit when the "
"file is open for reading (behavior is undefined when the file is open for "
"writing).  In order to make a :keyword:`for` loop the most efficient way of "
"looping over the lines of a file (a very common operation), the "
":meth:`~file.next` method uses a hidden read-ahead buffer.  As a consequence"
" of using a read-ahead buffer, combining :meth:`~file.next` with other file "
"methods (like :meth:`~file.readline`) does not work right.  However, using "
":meth:`seek` to reposition the file to an absolute position will flush the "
"read-ahead buffer."
msgstr ""

#: ../../library/stdtypes.rst:2522
msgid ""
"Read at most *size* bytes from the file (less if the read hits EOF before "
"obtaining *size* bytes).  If the *size* argument is negative or omitted, "
"read all data until EOF is reached.  The bytes are returned as a string "
"object.  An empty string is returned when EOF is encountered immediately.  "
"(For certain files, like ttys, it makes sense to continue reading after an "
"EOF is hit.)  Note that this method may call the underlying C function "
":c:func:`fread` more than once in an effort to acquire as close to *size* "
"bytes as possible. Also note that when in non-blocking mode, less data than "
"was requested may be returned, even if no *size* parameter was given."
msgstr ""

#: ../../library/stdtypes.rst:2533
msgid ""
"This function is simply a wrapper for the underlying :c:func:`fread` C "
"function, and will behave the same in corner cases, such as whether the EOF "
"value is cached."
msgstr ""

#: ../../library/stdtypes.rst:2540
msgid ""
"Read one entire line from the file.  A trailing newline character is kept in"
" the string (but may be absent when a file ends with an incomplete line). "
"[6]_ If the *size* argument is present and non-negative, it is a maximum "
"byte count (including the trailing newline) and an incomplete line may be "
"returned. When *size* is not 0, an empty string is returned *only* when EOF "
"is encountered immediately."
msgstr ""

#: ../../library/stdtypes.rst:2549
msgid ""
"Unlike ``stdio``'s :c:func:`fgets`, the returned string contains null "
"characters (``'\\0'``) if they occurred in the input."
msgstr ""

#: ../../library/stdtypes.rst:2555
msgid ""
"Read until EOF using :meth:`~file.readline` and return a list containing the"
" lines thus read.  If the optional *sizehint* argument is present, instead "
"of reading up to EOF, whole lines totalling approximately *sizehint* bytes "
"(possibly after rounding up to an internal buffer size) are read.  Objects "
"implementing a file-like interface may choose to ignore *sizehint* if it "
"cannot be implemented, or cannot be implemented efficiently."
msgstr ""

#: ../../library/stdtypes.rst:2565
msgid "This method returns the same thing as ``iter(f)``."
msgstr ""

#: ../../library/stdtypes.rst:2569
msgid "Use ``for line in file`` instead."
msgstr ""

#: ../../library/stdtypes.rst:2575
msgid ""
"Set the file's current position, like ``stdio``'s :c:func:`fseek`. The "
"*whence* argument is optional and defaults to  ``os.SEEK_SET`` or ``0`` "
"(absolute file positioning); other values are ``os.SEEK_CUR`` or ``1`` (seek"
" relative to the current position) and ``os.SEEK_END`` or ``2``  (seek "
"relative to the file's end).  There is no return value."
msgstr ""

#: ../../library/stdtypes.rst:2581
msgid ""
"For example, ``f.seek(2, os.SEEK_CUR)`` advances the position by two and "
"``f.seek(-3, os.SEEK_END)`` sets the position to the third to last."
msgstr ""

#: ../../library/stdtypes.rst:2584
msgid ""
"Note that if the file is opened for appending (mode ``'a'`` or ``'a+'``), "
"any :meth:`seek` operations will be undone at the next write.  If the file "
"is only opened for writing in append mode (mode ``'a'``), this method is "
"essentially a no-op, but it remains useful for files opened in append mode "
"with reading enabled (mode ``'a+'``).  If the file is opened in text mode "
"(without ``'b'``), only offsets returned by :meth:`tell` are legal.  Use of "
"other offsets causes undefined behavior."
msgstr ""

#: ../../library/stdtypes.rst:2592
msgid "Note that not all file objects are seekable."
msgstr ""

#: ../../library/stdtypes.rst:2594
msgid "Passing float values as offset has been deprecated."
msgstr ""

#: ../../library/stdtypes.rst:2600
msgid "Return the file's current position, like ``stdio``'s :c:func:`ftell`."
msgstr ""

#: ../../library/stdtypes.rst:2604
msgid ""
"On Windows, :meth:`tell` can return illegal values (after an "
":c:func:`fgets`) when reading files with Unix-style line-endings. Use binary"
" mode (``'rb'``) to circumvent this problem."
msgstr ""

#: ../../library/stdtypes.rst:2611
msgid ""
"Truncate the file's size.  If the optional *size* argument is present, the "
"file is truncated to (at most) that size.  The size defaults to the current "
"position. The current file position is not changed.  Note that if a "
"specified size exceeds the file's current size, the result is platform-"
"dependent:  possibilities include that the file may remain unchanged, "
"increase to the specified size as if zero-filled, or increase to the "
"specified size with undefined new content. Availability:  Windows, many Unix"
" variants."
msgstr ""

#: ../../library/stdtypes.rst:2622
msgid ""
"Write a string to the file.  There is no return value.  Due to buffering, "
"the string may not actually show up in the file until the :meth:`flush` or "
":meth:`close` method is called."
msgstr ""

#: ../../library/stdtypes.rst:2629
msgid ""
"Write a sequence of strings to the file.  The sequence can be any iterable "
"object producing strings, typically a list of strings. There is no return "
"value. (The name is intended to match :meth:`readlines`; :meth:`writelines` "
"does not add line separators.)"
msgstr ""

#: ../../library/stdtypes.rst:2634
msgid ""
"Files support the iterator protocol.  Each iteration returns the same result"
" as :meth:`~file.readline`, and iteration ends when the "
":meth:`~file.readline` method returns an empty string."
msgstr ""

#: ../../library/stdtypes.rst:2638
msgid ""
"File objects also offer a number of other interesting attributes. These are "
"not required for file-like objects, but should be implemented if they make "
"sense for the particular object."
msgstr ""

#: ../../library/stdtypes.rst:2645
msgid ""
"bool indicating the current state of the file object.  This is a read-only "
"attribute; the :meth:`close` method changes the value. It may not be "
"available on all file-like objects."
msgstr ""

#: ../../library/stdtypes.rst:2652
msgid ""
"The encoding that this file uses. When Unicode strings are written to a "
"file, they will be converted to byte strings using this encoding. In "
"addition, when the file is connected to a terminal, the attribute gives the "
"encoding that the terminal is likely to use (that  information might be "
"incorrect if the user has misconfigured the  terminal). The attribute is "
"read-only and may not be present on all file-like objects. It may also be "
"``None``, in which case the file uses the system default encoding for "
"converting Unicode strings."
msgstr ""

#: ../../library/stdtypes.rst:2665
msgid "The Unicode error handler used along with the encoding."
msgstr ""

#: ../../library/stdtypes.rst:2672
msgid ""
"The I/O mode for the file.  If the file was created using the :func:`open` "
"built-in function, this will be the value of the *mode* parameter.  This is "
"a read-only attribute and may not be present on all file-like objects."
msgstr ""

#: ../../library/stdtypes.rst:2679
msgid ""
"If the file object was created using :func:`open`, the name of the file. "
"Otherwise, some string that indicates the source of the file object, of the "
"form ``<...>``.  This is a read-only attribute and may not be present on all"
" file-like objects."
msgstr ""

#: ../../library/stdtypes.rst:2690
msgid ""
"If Python was built with :term:`universal newlines` enabled (the default) "
"this read-only attribute exists, and for files opened in universal newline "
"read mode it keeps track of the types of newlines encountered while reading "
"the file. The values it can take are ``'\\r'``, ``'\\n'``, ``'\\r\\n'``, "
"``None`` (unknown, no newlines read yet) or a tuple containing all the "
"newline types seen, to indicate that multiple newline conventions were "
"encountered. For files not opened in universal newlines read mode the value "
"of this attribute will be ``None``."
msgstr ""

#: ../../library/stdtypes.rst:2702
msgid ""
"Boolean that indicates whether a space character needs to be printed before "
"another value when using the :keyword:`print` statement. Classes that are "
"trying to simulate a file object should also have a writable "
":attr:`softspace` attribute, which should be initialized to zero.  This will"
" be automatic for most classes implemented in Python (care may be needed for"
" objects that override attribute access); types implemented in C will have "
"to provide a writable :attr:`softspace` attribute."
msgstr ""

#: ../../library/stdtypes.rst:2712
msgid ""
"This attribute is not used to control the :keyword:`print` statement, but to"
" allow the implementation of :keyword:`print` to keep track of its internal "
"state."
msgstr ""

#: ../../library/stdtypes.rst:2720
msgid "memoryview type"
msgstr ""

#: ../../library/stdtypes.rst:2724
msgid ""
":class:`memoryview` objects allow Python code to access the internal data of"
" an object that supports the buffer protocol without copying.  Memory is "
"generally interpreted as simple bytes."
msgstr ""

#: ../../library/stdtypes.rst:2730
msgid ""
"Create a :class:`memoryview` that references *obj*.  *obj* must support the "
"buffer protocol.  Built-in objects that support the buffer protocol include "
":class:`str` and :class:`bytearray` (but not :class:`unicode`)."
msgstr ""

#: ../../library/stdtypes.rst:2734
msgid ""
"A :class:`memoryview` has the notion of an *element*, which is the atomic "
"memory unit handled by the originating object *obj*.  For many simple types "
"such as :class:`str` and :class:`bytearray`, an element is a single byte, "
"but other third-party types may expose larger elements."
msgstr ""

#: ../../library/stdtypes.rst:2739
msgid ""
"``len(view)`` returns the total number of elements in the memoryview, "
"*view*.  The :class:`~memoryview.itemsize` attribute will give you the "
"number of bytes in a single element."
msgstr ""

#: ../../library/stdtypes.rst:2743
msgid ""
"A :class:`memoryview` supports slicing to expose its data.  Taking a single "
"index will return a single element as a :class:`str` object.  Full slicing "
"will result in a subview::"
msgstr ""

#: ../../library/stdtypes.rst:2757
msgid ""
"If the object the memoryview is over supports changing its data, the "
"memoryview supports slice assignment::"
msgstr ""

#: ../../library/stdtypes.rst:2775
msgid "Notice how the size of the memoryview object cannot be changed."
msgstr ""

#: ../../library/stdtypes.rst:2777
msgid ":class:`memoryview` has two methods:"
msgstr ""

#: ../../library/stdtypes.rst:2781
msgid ""
"Return the data in the buffer as a bytestring (an object of class "
":class:`str`). ::"
msgstr ""

#: ../../library/stdtypes.rst:2790
msgid "Return the data in the buffer as a list of integers. ::"
msgstr ""

#: ../../library/stdtypes.rst:2795
msgid "There are also several readonly attributes available:"
msgstr "Existem também diversos atributos somente leitura disponíveis:"

#: ../../library/stdtypes.rst:2799
msgid ""
"A string containing the format (in :mod:`struct` module style) for each "
"element in the view.  This defaults to ``'B'``, a simple bytestring."
msgstr ""

#: ../../library/stdtypes.rst:2804
msgid "The size in bytes of each element of the memoryview."
msgstr ""

#: ../../library/stdtypes.rst:2808
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the shape of the "
"memory as an N-dimensional array."
msgstr ""
"Uma tupla de inteiros de comprimento :attr:`ndim` dando a forma da memória "
"como uma matriz N-dimensional."

#: ../../library/stdtypes.rst:2813
msgid ""
"An integer indicating how many dimensions of a multi-dimensional array the "
"memory represents."
msgstr ""
"Um número inteiro que indica quantas dimensões de uma matriz "
"multidimensional a memória representa."

#: ../../library/stdtypes.rst:2818
msgid ""
"A tuple of integers the length of :attr:`ndim` giving the size in bytes to "
"access each element for each dimension of the array."
msgstr ""
"Uma tupla de inteiros de comprimento de :attr:`ndim` dando o tamanho em "
"bytes para acessar cada elemento de cada dimensão da matriz."

#: ../../library/stdtypes.rst:2823
msgid "A bool indicating whether the memory is read only."
msgstr "Um bool que indica se a memória é somente leitura."

#: ../../library/stdtypes.rst:2831
msgid "Context Manager Types"
msgstr "Tipos de Gerenciador de Contexto"

#: ../../library/stdtypes.rst:2840
msgid ""
"Python's :keyword:`with` statement supports the concept of a runtime context"
" defined by a context manager.  This is implemented using two separate "
"methods that allow user-defined classes to define a runtime context that is "
"entered before the statement body is executed and exited when the statement "
"ends."
msgstr ""

#: ../../library/stdtypes.rst:2845
msgid ""
"The :dfn:`context management protocol` consists of a pair of methods that "
"need to be provided for a context manager object to define a runtime "
"context:"
msgstr ""

#: ../../library/stdtypes.rst:2851
msgid ""
"Enter the runtime context and return either this object or another object "
"related to the runtime context. The value returned by this method is bound "
"to the identifier in the :keyword:`as` clause of :keyword:`with` statements "
"using this context manager."
msgstr ""

#: ../../library/stdtypes.rst:2856
msgid ""
"An example of a context manager that returns itself is a file object. File "
"objects return themselves from __enter__() to allow :func:`open` to be used "
"as the context expression in a :keyword:`with` statement."
msgstr ""

#: ../../library/stdtypes.rst:2860
msgid ""
"An example of a context manager that returns a related object is the one "
"returned by :func:`decimal.localcontext`. These managers set the active "
"decimal context to a copy of the original decimal context and then return "
"the copy. This allows changes to be made to the current decimal context in "
"the body of the :keyword:`with` statement without affecting code outside the"
" :keyword:`with` statement."
msgstr ""

#: ../../library/stdtypes.rst:2870
msgid ""
"Exit the runtime context and return a Boolean flag indicating if any "
"exception that occurred should be suppressed. If an exception occurred while"
" executing the body of the :keyword:`with` statement, the arguments contain "
"the exception type, value and traceback information. Otherwise, all three "
"arguments are ``None``."
msgstr ""
"Sai do contexto em tempo de execução e retorna um flag Booleano indicando se"
" qualquer exceção que ocorreu deve ser suprimida. Se uma exceção ocorreu "
"enquanto era executado o corpo da instrução :keyword:`with`, os argumentos "
"contém o tipo da exceção, valor e informação da pilha de execução. Caso "
"contrário, os tres argumentos são ``None``."

#: ../../library/stdtypes.rst:2875
msgid ""
"Returning a true value from this method will cause the :keyword:`with` "
"statement to suppress the exception and continue execution with the "
"statement immediately following the :keyword:`with` statement. Otherwise the"
" exception continues propagating after this method has finished executing. "
"Exceptions that occur during execution of this method will replace any "
"exception that occurred in the body of the :keyword:`with` statement."
msgstr ""

#: ../../library/stdtypes.rst:2882
msgid ""
"The exception passed in should never be reraised explicitly - instead, this "
"method should return a false value to indicate that the method completed "
"successfully and does not want to suppress the raised exception. This allows"
" context management code (such as ``contextlib.nested``) to easily detect "
"whether or not an :meth:`__exit__` method has actually failed."
msgstr ""

#: ../../library/stdtypes.rst:2888
msgid ""
"Python defines several context managers to support easy thread "
"synchronisation, prompt closure of files or other objects, and simpler "
"manipulation of the active decimal arithmetic context. The specific types "
"are not treated specially beyond their implementation of the context "
"management protocol. See the :mod:`contextlib` module for some examples."
msgstr ""
"Python define diversos genreciadores de contexto para suportar facilmente "
"sincronização de threads, solicita fechamento de arquivos ou outros "
"objectos, e manipulação simples do contexto ativo de aritmética decimal. Os "
"tipos especificados não são tratados especialmente além da sua implementação"
" do protocolo do gerenciador de contexto. Veja o módulo :mod:`contextlib` "
"para alguns exemplos."

#: ../../library/stdtypes.rst:2894
msgid ""
"Python's :term:`generator`\\s and the ``contextlib.contextmanager`` "
":term:`decorator` provide a convenient way to implement these protocols.  If"
" a generator function is decorated with the ``contextlib.contextmanager`` "
"decorator, it will return a context manager implementing the necessary "
":meth:`__enter__` and :meth:`__exit__` methods, rather than the iterator "
"produced by an undecorated generator function."
msgstr ""

#: ../../library/stdtypes.rst:2901
msgid ""
"Note that there is no specific slot for any of these methods in the type "
"structure for Python objects in the Python/C API. Extension types wanting to"
" define these methods must provide them as a normal Python accessible "
"method. Compared to the overhead of setting up the runtime context, the "
"overhead of a single class dictionary lookup is negligible."
msgstr ""
"Perceba que não existe nenhum slot específico para qualquer um desses "
"métodos no tipo structure para objetos Python na API do Python/C. Tipos de "
"extensão que desejam definir estes métodos devem fornecê-los como um método "
"acessível normal do Python. Comparado com a sobrecarga de configurar o "
"contexto em tempo de execução, a sobrecarga na pesquisa de dicionário em uma"
" única classe é negligenciável."

#: ../../library/stdtypes.rst:2911
msgid "Other Built-in Types"
msgstr "Outros tipos embutidos"

#: ../../library/stdtypes.rst:2913
msgid ""
"The interpreter supports several other kinds of objects. Most of these "
"support only one or two operations."
msgstr ""
"O interpretador suporta diversos outros tipos de objetos. Maior parte "
"desses, suporta apenas uma ou duas operações."

#: ../../library/stdtypes.rst:2920
msgid "Modules"
msgstr "Módulos"

#: ../../library/stdtypes.rst:2922
msgid ""
"The only special operation on a module is attribute access: ``m.name``, "
"where *m* is a module and *name* accesses a name defined in *m*'s symbol "
"table. Module attributes can be assigned to.  (Note that the "
":keyword:`import` statement is not, strictly speaking, an operation on a "
"module object; ``import foo`` does not require a module object named *foo* "
"to exist, rather it requires an (external) *definition* for a module named "
"*foo* somewhere.)"
msgstr ""
"A única operação especial em um módulo é o acesso a um atributo: ``m.nome``,"
" onde *m* é um módulo e *nome* acessa o nome defino na tabela de símbolos de"
" *m*. Atributos de módulo podem receber atribuição. (Perceba que a instrução"
" :keyword:`import` não é, estritamente falando, uma operação em um objeto do"
" módulo; ``import foo`` não requer que um objeto do módulo chamado *foo* "
"exista, ao invés disso requer uma *definição* (externa) de um módulo chamado"
" *foo* em algum lugar.)"

#: ../../library/stdtypes.rst:2929
msgid ""
"A special attribute of every module is :attr:`~object.__dict__`. This is the"
" dictionary containing the module's symbol table. Modifying this dictionary "
"will actually change the module's symbol table, but direct assignment to the"
" :attr:`~object.__dict__` attribute is not possible (you can write "
"``m.__dict__['a'] = 1``, which defines ``m.a`` to be ``1``, but you can't "
"write ``m.__dict__ = {}``).  Modifying :attr:`~object.__dict__` directly is "
"not recommended."
msgstr ""
"Um atributo especial de cada módulo é :attr:`~object.__dict__`. Este é o "
"dicionário contendo a tabela de símbolos do modulo. Modificar este "
"dicionário vai na verdade modificar a tabela de símbolos do módulo, mas "
"atribuição direta para o atributo :attr:`~object.__dict__` não é possível "
"(você pode escrever ``m.__dict__['a'] = 1``, o qual define ``m.a`` para ser "
"``1``, mas você não consegue escrever ``m.__dict__ = {}``). Modificar "
":attr:`~object.__dict__` diretamente não é recomendado."

#: ../../library/stdtypes.rst:2937
msgid ""
"Modules built into the interpreter are written like this: ``<module 'sys' "
"(built-in)>``.  If loaded from a file, they are written as ``<module 'os' "
"from '/usr/local/lib/pythonX.Y/os.pyc'>``."
msgstr ""
"Módulos embutidos no interpretador são escritos desta forma: ``<module 'sys'"
" (built-in)>``. Se carregados a partir de um arquivo, eles são escritos como"
" ``<module 'os' from '/usr/local/lib/pythonX.Y/os.pyc'>``."

#: ../../library/stdtypes.rst:2945
msgid "Classes and Class Instances"
msgstr "Classes e Instâncias de Classes"

#: ../../library/stdtypes.rst:2947
msgid "See :ref:`objects` and :ref:`class` for these."
msgstr "Veja :ref:`objects` e :ref:`class` para estes."

#: ../../library/stdtypes.rst:2953
msgid "Functions"
msgstr "Funções"

#: ../../library/stdtypes.rst:2955
msgid ""
"Function objects are created by function definitions.  The only operation on"
" a function object is to call it: ``func(argument-list)``."
msgstr ""
"Objetos de funções são criados através da definição de funções. A única "
"operação que pode ser feita em um objeto de função é chamá-la: ``func(lista-"
"de-argumentos)``."

#: ../../library/stdtypes.rst:2958
msgid ""
"There are really two flavors of function objects: built-in functions and "
"user-defined functions.  Both support the same operation (to call the "
"function), but the implementation is different, hence the different object "
"types."
msgstr ""
"Existem na verdade duas possibilidades de objetos de função: funções "
"embutidas e funções definidas pelo usuário. Ambas suportam a mesma operação "
"(chamar a função), mas a implementação é diferente, portanto os diferentes "
"tipos de objetos."

#: ../../library/stdtypes.rst:2962
msgid "See :ref:`function` for more information."
msgstr "Veja a funçao :ref:`function` para maiores informações."

#: ../../library/stdtypes.rst:2968
msgid "Methods"
msgstr "Métodos"

#: ../../library/stdtypes.rst:2972
msgid ""
"Methods are functions that are called using the attribute notation. There "
"are two flavors: built-in methods (such as :meth:`append` on lists) and "
"class instance methods.  Built-in methods are described with the types that "
"support them."
msgstr ""
"Métodos são funções que são chamadas usando a notação de atributo. Existem "
"duas opções: métodos embutidos (tal como :meth:`append` em listas) e métodos"
" de instância de classe. Métodos embutidos são descritos com os tipos que "
"suportam eles."

#: ../../library/stdtypes.rst:2977
msgid ""
"The implementation adds two special read-only attributes to class instance "
"methods: ``m.im_self`` is the object on which the method operates, and "
"``m.im_func`` is the function implementing the method.  Calling ``m(arg-1, "
"arg-2, ..., arg-n)`` is completely equivalent to calling "
"``m.im_func(m.im_self, arg-1, arg-2, ..., arg-n)``."
msgstr ""

#: ../../library/stdtypes.rst:2983
msgid ""
"Class instance methods are either *bound* or *unbound*, referring to whether"
" the method was accessed through an instance or a class, respectively.  When"
" a method is unbound, its ``im_self`` attribute will be ``None`` and if "
"called, an explicit ``self`` object must be passed as the first argument.  "
"In this case, ``self`` must be an instance of the unbound method's class (or"
" a subclass of that class), otherwise a :exc:`TypeError` is raised."
msgstr ""

#: ../../library/stdtypes.rst:2990
msgid ""
"Like function objects, methods objects support getting arbitrary attributes."
" However, since method attributes are actually stored on the underlying "
"function object (``meth.im_func``), setting method attributes on either "
"bound or unbound methods is disallowed.  Attempting to set an attribute on a"
" method results in an :exc:`AttributeError` being raised.  In order to set a"
" method attribute, you need to explicitly set it on the underlying function "
"object::"
msgstr ""

#: ../../library/stdtypes.rst:3011 ../../library/stdtypes.rst:3039
msgid "See :ref:`types` for more information."
msgstr "Veja o tipo :ref:`types` para maiores informações."

#: ../../library/stdtypes.rst:3019
msgid "Code Objects"
msgstr "Objetos de Código"

#: ../../library/stdtypes.rst:3025
msgid ""
"Code objects are used by the implementation to represent \"pseudo-compiled\""
" executable Python code such as a function body. They differ from function "
"objects because they don't contain a reference to their global execution "
"environment.  Code objects are returned by the built-in :func:`compile` "
"function and can be extracted from function objects through their "
":attr:`func_code` attribute. See also the :mod:`code` module."
msgstr ""

#: ../../library/stdtypes.rst:3036
msgid ""
"A code object can be executed or evaluated by passing it (instead of a "
"source string) to the :keyword:`exec` statement or the built-in :func:`eval`"
" function."
msgstr ""

#: ../../library/stdtypes.rst:3045
msgid "Type Objects"
msgstr "Objetos de tipo"

#: ../../library/stdtypes.rst:3051
msgid ""
"Type objects represent the various object types.  An object's type is "
"accessed by the built-in function :func:`type`.  There are no special "
"operations on types.  The standard module :mod:`types` defines names for all"
" standard built-in types."
msgstr ""
"Objetos de tipos representam os vários tipos de objetos. Um tipo de um "
"objeto é acessado pela função embutida :func:`type`. Não existem operações "
"especiais sobre tipos. O módulo padrão :mod:`types` define nomes para todos "
"os tipos padrão embutidos."

#: ../../library/stdtypes.rst:3056
msgid "Types are written like this: ``<type 'int'>``."
msgstr ""

#: ../../library/stdtypes.rst:3062
msgid "The Null Object"
msgstr "O objeto Null"

#: ../../library/stdtypes.rst:3064
msgid ""
"This object is returned by functions that don't explicitly return a value.  "
"It supports no special operations.  There is exactly one null object, named "
"``None`` (a built-in name)."
msgstr ""

#: ../../library/stdtypes.rst:3068
msgid "It is written as ``None``."
msgstr "Ele é escrito como ``None``."

#: ../../library/stdtypes.rst:3074
msgid "The Ellipsis Object"
msgstr "O Objeto Ellipsis"

#: ../../library/stdtypes.rst:3076
msgid ""
"This object is used by extended slice notation (see :ref:`slicings`).  It "
"supports no special operations.  There is exactly one ellipsis object, named"
" :const:`Ellipsis` (a built-in name)."
msgstr ""

#: ../../library/stdtypes.rst:3080
msgid ""
"It is written as ``Ellipsis``.  When in a subscript, it can also be written "
"as ``...``, for example ``seq[...]``."
msgstr ""

#: ../../library/stdtypes.rst:3085
msgid "The NotImplemented Object"
msgstr "O Objeto NotImplemented"

#: ../../library/stdtypes.rst:3087
msgid ""
"This object is returned from comparisons and binary operations when they are"
" asked to operate on types they don't support. See :ref:`comparisons` for "
"more information."
msgstr ""

#: ../../library/stdtypes.rst:3091
msgid "It is written as ``NotImplemented``."
msgstr "Está escrito como ``NotImplemented``."

#: ../../library/stdtypes.rst:3095
msgid "Boolean Values"
msgstr "Valores Booleanos"

#: ../../library/stdtypes.rst:3097
msgid ""
"Boolean values are the two constant objects ``False`` and ``True``.  They "
"are used to represent truth values (although other values can also be "
"considered false or true).  In numeric contexts (for example when used as "
"the argument to an arithmetic operator), they behave like the integers 0 and"
" 1, respectively. The built-in function :func:`bool` can be used to convert "
"any value to a Boolean, if the value can be interpreted as a truth value "
"(see section :ref:`truth` above)."
msgstr ""
"Valores Booleanos são os dois objetos constantes ``False`` e ``True``. Eles "
"são usados para representar valores verdadeiros (apesar que outros valores "
"também podem ser considerados falso ou verdadeiro). Em contextos numéricos "
"(por exemplo quando usados como argumentos para um operator aritmético), "
"eles se comportam como os inteiros 0 e 1, respectivamente. A função embutida"
" :func:`bool` pode ser usada para converter qualquer valor para um Boolean, "
"se o valor puder ser interpretado como um valor verdadeiro (veja a seção "
":ref:`truth` acima)."

#: ../../library/stdtypes.rst:3110
msgid "They are written as ``False`` and ``True``, respectively."
msgstr "Eles são escritos como ``False`` e ``True``, respectivamente."

#: ../../library/stdtypes.rst:3116
msgid "Internal Objects"
msgstr "Objetos Internos"

#: ../../library/stdtypes.rst:3118
msgid ""
"See :ref:`types` for this information.  It describes stack frame objects, "
"traceback objects, and slice objects."
msgstr ""
"Veja :ref:`a hierarquia de tipos padrão <types>` para esta informação. Ela "
"descreve objetos de stack frame, objetos de traceback, e fatias de objetos."

#: ../../library/stdtypes.rst:3125
msgid "Special Attributes"
msgstr "Atributos Especiais"

#: ../../library/stdtypes.rst:3127
msgid ""
"The implementation adds a few special read-only attributes to several object"
" types, where they are relevant.  Some of these are not reported by the "
":func:`dir` built-in function."
msgstr ""
"A implementação adiciona alguns atributos especiais somente-leitura para "
"diversos tipos de objetos, onde eles são relevantes. Alguns desses não são "
"reportados pela função embutida :func:`dir`."

#: ../../library/stdtypes.rst:3134
msgid ""
"A dictionary or other mapping object used to store an object's (writable) "
"attributes."
msgstr ""
"Um dicionário ou outro objeto de mapeamento usado para armazenar os "
"atributos (graváveis) de um objeto."

#: ../../library/stdtypes.rst:3140 ../../library/stdtypes.rst:3147
msgid ""
"Use the built-in function :func:`dir` to get a list of an object's "
"attributes. This attribute is no longer available."
msgstr ""

#: ../../library/stdtypes.rst:3154
msgid "The class to which a class instance belongs."
msgstr "A classe à qual pertence uma instância de classe."

#: ../../library/stdtypes.rst:3159
msgid "The tuple of base classes of a class object."
msgstr "A tupla de classes base de um objeto classe."

#: ../../library/stdtypes.rst:3164
msgid ""
"The name of the class, type, function, method, descriptor, or generator "
"instance."
msgstr ""

#: ../../library/stdtypes.rst:3168
msgid ""
"The following attributes are only supported by :term:`new-style class`\\ es."
msgstr ""

#: ../../library/stdtypes.rst:3172
msgid ""
"This attribute is a tuple of classes that are considered when looking for "
"base classes during method resolution."
msgstr ""
"Este atributo é uma tupla de classes que são consideradas ao procurar por "
"classes bases durante resolução de métodos."

#: ../../library/stdtypes.rst:3178
msgid ""
"This method can be overridden by a metaclass to customize the method "
"resolution order for its instances.  It is called at class instantiation, "
"and its result is stored in :attr:`~class.__mro__`."
msgstr ""
"Este método pode ser substituído por uma metaclasse para customizar a ordem "
"de resolução de métodos para suas instâncias. Ele é chamado na instanciação "
"da classe, e o seu resultado é armazenado em :attr:`~class.__mro__`."

#: ../../library/stdtypes.rst:3185
msgid ""
"Each new-style class keeps a list of weak references to its immediate "
"subclasses.  This method returns a list of all those references still alive."
" Example::"
msgstr ""

#: ../../library/stdtypes.rst:3194
msgid "Footnotes"
msgstr "Notas de Rodapé"

#: ../../library/stdtypes.rst:3195
msgid ""
"Additional information on these special methods may be found in the Python "
"Reference Manual (:ref:`customization`)."
msgstr ""
"Informações adicionais sobre esses métodos especiais podem ser encontradas "
"no Manual de Referência do Python (:ref:`Customização básica "
"<customization>`)."

#: ../../library/stdtypes.rst:3198
msgid ""
"As a consequence, the list ``[1, 2]`` is considered equal to ``[1.0, 2.0]``,"
" and similarly for tuples."
msgstr ""
"Como uma consequência, a lista ``[1, 2]`` é considerada igual a ``[1.0, "
"2.0]``, e similarmente para tuplas."

#: ../../library/stdtypes.rst:3201
msgid "They must have since the parser can't tell the type of the operands."
msgstr ""
"Eles precisam ter, já que o analisador sintático não consegue dizer o tipo "
"dos operandos."

#: ../../library/stdtypes.rst:3203
msgid ""
"Cased characters are those with general category property being one of "
"\"Lu\" (Letter, uppercase), \"Ll\" (Letter, lowercase), or \"Lt\" (Letter, "
"titlecase)."
msgstr ""
"Caracteres que possuem maiúsculo e minúsculo são aqueles com a propriedade "
"de categoria geral igual a \"Lu\" (Letra, maiúscula), \"Ll\" (Letra, "
"minúscula), ou \"Lt\" (Letra, em formato de título)."

#: ../../library/stdtypes.rst:3206
msgid ""
"To format only a tuple you should therefore provide a singleton tuple whose "
"only element is the tuple to be formatted."
msgstr ""
"Para formatar apenas uma tupla, você deve portanto fornecer uma tupla "
"singleton, cujo único elemento é a tupla a ser formatada."

#: ../../library/stdtypes.rst:3209
msgid ""
"The advantage of leaving the newline on is that returning an empty string is"
" then an unambiguous EOF indication.  It is also possible (in cases where it"
" might matter, for example, if you want to make an exact copy of a file "
"while scanning its lines) to tell whether the last line of a file ended in a"
" newline or not (yes this happens!)."
msgstr ""
