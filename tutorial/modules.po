# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:46+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: Hildeberto Abreu Magalhães <hildeberto@gmail.com>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/python-doc/"
"python-27/language/pt_BR/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/modules.rst:5
msgid "Modules"
msgstr "Módulos"

#: ../../tutorial/modules.rst:7
msgid ""
"If you quit from the Python interpreter and enter it again, the definitions "
"you have made (functions and variables) are lost. Therefore, if you want to "
"write a somewhat longer program, you are better off using a text editor to "
"prepare the input for the interpreter and running it with that file as input "
"instead.  This is known as creating a *script*.  As your program gets "
"longer, you may want to split it into several files for easier maintenance.  "
"You may also want to use a handy function that you've written in several "
"programs without copying its definition into each program."
msgstr ""
"Se você sair do interpretador do Python e entrar novamente, as definições "
"(funções\n"
"e variáveis) que você havia feito estarão perdidas. Portanto, se você quer "
"escrever\n"
"um programa um pouco mais longo, você se sairá melhor usando um editor de "
"texto\n"
"para criar e salvar o programa em um arquivo, usando depois esse arquivo "
"como\n"
"entrada para a execução do interpretador. Isso é conhecido como gerar um "
"*script*.\n"
"A medida que seus programas crescem, pode ser desejável dividi-los em "
"vários\n"
"arquivos para facilitar a manutenção. Você também pode querer reutilizar "
"uma\n"
"função sem copiar sua definição a cada novo programa."

#: ../../tutorial/modules.rst:16
msgid ""
"To support this, Python has a way to put definitions in a file and use them "
"in a script or in an interactive instance of the interpreter. Such a file is "
"called a *module*; definitions from a module can be *imported* into other "
"modules or into the *main* module (the collection of variables that you have "
"access to in a script executed at the top level and in calculator mode)."
msgstr ""
"Para permitir isso, Python tem uma maneira de colocar definições em um "
"arquivo e\n"
"e então usá-las em um script ou em uma execução interativa no interpretador. "
"Tal\n"
"arquivo é chamado de \"módulo\"; definições de um módulo podem ser "
"*importadas*\n"
"em outros módulos ou no módulo *principal* (a coleção de variáveis a que "
"você\n"
"tem acesso no nível mais externo de um script executado como um programa, ou "
"no\n"
"modo calculadora)."

#: ../../tutorial/modules.rst:22
msgid ""
"A module is a file containing Python definitions and statements.  The file "
"name is the module name with the suffix :file:`.py` appended.  Within a "
"module, the module's name (as a string) is available as the value of the "
"global variable ``__name__``.  For instance, use your favorite text editor "
"to create a file called :file:`fibo.py` in the current directory with the "
"following contents::"
msgstr ""
"Um módulo é um arquivo Python contendo definições e instruções. O nome do "
"arquivo\n"
"é o módulo com o sufixo :file:`.py` adicionado. Dentro de um módulo, o nome "
"do\n"
"módulo (como uma string) está disponível na variável global ``__name__``. "
"Por\n"
"exemplo, use seu editor de texto favorito para criar um arquivo chamado\n"
":file:`fibo.py` no diretório atual com o seguinte conteúdo::"

#: ../../tutorial/modules.rst:44
msgid ""
"Now enter the Python interpreter and import this module with the following "
"command::"
msgstr ""
"Agora, entre no interpretador Python e importe esse módulo com o seguinte\n"
"comando::"

#: ../../tutorial/modules.rst:49
msgid ""
"This does not enter the names of the functions defined in ``fibo``  directly "
"in the current symbol table; it only enters the module name ``fibo`` there. "
"Using the module name you can access the functions::"
msgstr ""
"Isso não coloca os nomes das funções definidas em ``fibo`` diretamente na "
"tabela\n"
"de símbolos atual; isso coloca somente o nome do módulo ``fibo``. Usando o "
"nome\n"
"do módulo você pode acessar as funções."

#: ../../tutorial/modules.rst:60
msgid ""
"If you intend to use a function often you can assign it to a local name::"
msgstr ""
"Se pretendes usar uma função frequentemente, pode associá-la a um nome "
"local::"

#: ../../tutorial/modules.rst:70
msgid "More on Modules"
msgstr "Mais sobre Módulos"

#: ../../tutorial/modules.rst:72
msgid ""
"A module can contain executable statements as well as function definitions. "
"These statements are intended to initialize the module. They are executed "
"only the *first* time the module name is encountered in an import statement. "
"[#]_ (They are also run if the file is executed as a script.)"
msgstr ""
"Um módulo pode conter tanto comandos quanto definições de funções e "
"classes.\n"
"Esses comandos servem para inicializar o módulo. Eles são executados somente "
"na\n"
"*primeira* vez que o módulo é importado em algum lugar. [#]_"

#: ../../tutorial/modules.rst:77
msgid ""
"Each module has its own private symbol table, which is used as the global "
"symbol table by all functions defined in the module. Thus, the author of a "
"module can use global variables in the module without worrying about "
"accidental clashes with a user's global variables. On the other hand, if you "
"know what you are doing you can touch a module's global variables with the "
"same notation used to refer to its functions, ``modname.itemname``."
msgstr ""
"Cada módulo tem sua própria tabela de símbolos privada, que é usada como\n"
"tabela de símbolos global para todas as funções definidas no módulo. Assim, "
"o\n"
"autor de um módulo pode usar variáveis globais no seu módulo sem se "
"preocupar\n"
"com conflitos acidentais com as variáveis globais do usuário. Por outro "
"lado,\n"
"se você precisar usar uma variável global de um módulo, poderá fazê-lo com "
"a\n"
"mesma notação usada para se referir às suas funções,\n"
"``nome_do_modulo.nome_do_item``."

#: ../../tutorial/modules.rst:84
msgid ""
"Modules can import other modules.  It is customary but not required to place "
"all :keyword:`import` statements at the beginning of a module (or script, "
"for that matter).  The imported module names are placed in the importing "
"module's global symbol table."
msgstr ""
"Módulos podem importar outros módulos. É costume, porém não obrigatório, "
"colocar\n"
"todos os comandos :keyword:`import` no início do módulo (ou script).\n"
"se preferir). As definições do módulo importado são colocadas na tabela\n"
"de símbolos global do módulo que faz a importação."

#: ../../tutorial/modules.rst:89
msgid ""
"There is a variant of the :keyword:`import` statement that imports names "
"from a module directly into the importing module's symbol table.  For "
"example::"
msgstr ""
"Existe uma variante do comando :keyword:`import` que importa definições de "
"um\n"
"módulo diretamente para a tabela de símbolos do módulo importador. Por "
"exemplo::"

#: ../../tutorial/modules.rst:96
msgid ""
"This does not introduce the module name from which the imports are taken in "
"the local symbol table (so in the example, ``fibo`` is not defined)."
msgstr ""
"Isso não coloca o nome do módulo de onde foram feitas as importações para a\n"
"tabela de símbolos local (assim, no exemplo, ``fibo`` não está definido)."

#: ../../tutorial/modules.rst:99
msgid "There is even a variant to import all names that a module defines::"
msgstr ""
"Existe ainda uma variante que importa todos os nomes definidos em um módulo::"

#: ../../tutorial/modules.rst:105
msgid ""
"This imports all names except those beginning with an underscore (``_``)."
msgstr ""
"Isso importa todos as declarações de nomes, exceto aqueles que iniciam com "
"um\n"
"sublinhado (``_``). Na maioria dos casos, programadores Python não usam "
"esta\n"
"facilidade porque ela introduz um conjunto desconhecido de nomes no "
"ambiente,\n"
"podendo esconder outros nomes previamente definidos."

#: ../../tutorial/modules.rst:107
msgid ""
"Note that in general the practice of importing ``*`` from a module or "
"package is frowned upon, since it often causes poorly readable code. "
"However, it is okay to use it to save typing in interactive sessions."
msgstr ""
"Note que, em geral, a prática do ``import *`` de um módulo ou pacote é\n"
"desaprovada, uma vez que muitas vezes dificulta a leitura do código. "
"Contudo,\n"
"é aceitável para diminuir a digitação em sessões interativas."

#: ../../tutorial/modules.rst:111
msgid ""
"If the module name is followed by :keyword:`as`, then the name following :"
"keyword:`as` is bound directly to the imported module."
msgstr ""

#: ../../tutorial/modules.rst:120
msgid ""
"This is effectively importing the module in the same way that ``import "
"fibo`` will do, with the only difference of it being available as ``fib``."
msgstr ""
"Isto efetivamente importa o módulo, da mesma maneira que ``import fibo`` "
"fará, com a única diferença de estar disponível com o nome ``fib``."

#: ../../tutorial/modules.rst:123
msgid ""
"It can also be used when utilising :keyword:`from` with similar effects::"
msgstr ""
"Também pode ser utilizado com a palavra-chave :keyword:`from`, com efeitos "
"similares::"

#: ../../tutorial/modules.rst:132
msgid ""
"For efficiency reasons, each module is only imported once per interpreter "
"session.  Therefore, if you change your modules, you must restart the "
"interpreter -- or, if it's just one module you want to test interactively, "
"use :func:`reload`, e.g. ``reload(modulename)``."
msgstr ""
"Por razões de eficiência, cada módulo é importado somente uma vez por "
"sessão\n"
" do interpretador. Portanto, se você alterar seus módulos, você deve "
"reiniciar\n"
" o interpretador -- ou, se é somente um módulo que você quer testar\n"
" interativamente, use :func:`reload`, ex. ``reload(nome_do_modulo)``."

#: ../../tutorial/modules.rst:141
msgid "Executing modules as scripts"
msgstr "Executando módulos como scripts"

#: ../../tutorial/modules.rst:143
msgid "When you run a Python module with ::"
msgstr "Quando você executa um módulo Python assim::"

#: ../../tutorial/modules.rst:147
msgid ""
"the code in the module will be executed, just as if you imported it, but "
"with the ``__name__`` set to ``\"__main__\"``.  That means that by adding "
"this code at the end of your module::"
msgstr ""
"o código no módulo será executado, da mesma forma como você estivesse apenas "
"importado, mas com a variável global ``__name__`` com o valor ``\"__main__"
"\"``. Isso significa que você pode acrescentar este código no fim do seu "
"módulo::"

#: ../../tutorial/modules.rst:155
msgid ""
"you can make the file usable as a script as well as an importable module, "
"because the code that parses the command line only runs if the module is "
"executed as the \"main\" file:"
msgstr ""
"você pode tornar o arquivo utilizável tanto como script quanto como um "
"módulo importável, porque o código que analisa a linha de comando só roda se "
"o módulo é executado como arquivo \"principal\":"

#: ../../tutorial/modules.rst:164
msgid "If the module is imported, the code is not run::"
msgstr "Se o módulo é importado, o código não é executado::"

#: ../../tutorial/modules.rst:169
msgid ""
"This is often used either to provide a convenient user interface to a "
"module, or for testing purposes (running the module as a script executes a "
"test suite)."
msgstr ""
"Isso é frequentemente usado para fornecer interface de usuário conveniente "
"para um módulo, ou para realizar testes (rodando o módulo como um script, "
"uma suíte de testes é executada)."

#: ../../tutorial/modules.rst:176
msgid "The Module Search Path"
msgstr "O caminho de busca dos módulos"

#: ../../tutorial/modules.rst:180
msgid ""
"When a module named :mod:`spam` is imported, the interpreter first searches "
"for a built-in module with that name. If not found, it then searches for a "
"file named :file:`spam.py` in a list of directories given by the variable :"
"data:`sys.path`.  :data:`sys.path` is initialized from these locations:"
msgstr ""
"Quando um módulo chamado :mod:`spam` é importado, o interpretador procura "
"um\n"
"módulo embutido com este nome. Se não existe, procura um arquivo chamado\n"
":file:`spam.py` em uma lista de diretórios incluídos na variável\n"
":data:`sys.path`, que é inicializada com estes locais:"

#: ../../tutorial/modules.rst:185
msgid "the directory containing the input script (or the current directory)."
msgstr "* o diretório que contém o script importador (ou o diretório atual)."

#: ../../tutorial/modules.rst:186
msgid ""
":envvar:`PYTHONPATH` (a list of directory names, with the same syntax as the "
"shell variable :envvar:`PATH`)."
msgstr ""
"* a variável de ambiente :envvar:`PYTHONPATH` (uma lista de nomes de\n"
" diretórios, com a mesma sintaxe da variável de ambiente :envvar:`PATH`)."

#: ../../tutorial/modules.rst:188
msgid "the installation-dependent default."
msgstr "* um caminho default que depende da instalação do Python."

#: ../../tutorial/modules.rst:190
msgid ""
"After initialization, Python programs can modify :data:`sys.path`.  The "
"directory containing the script being run is placed at the beginning of the "
"search path, ahead of the standard library path. This means that scripts in "
"that directory will be loaded instead of modules of the same name in the "
"library directory. This is an error unless the replacement is intended.  See "
"section :ref:`tut-standardmodules` for more information."
msgstr ""
"Após a inicialização, programas Python podem modificar :data:`sys.path`. O\n"
"diretório que contém o script sendo executado é colocado no início da lista\n"
"de caminhos, à frente do caminho da biblioteca padrão. Isto significa que\n"
"módulos nesse diretório serão carregados no lugar de módulos com o mesmo "
"nome\n"
"na biblioteca padrão. Isso costuma ser um erro, a menos que seja "
"intencional.\n"
"Veja a seção :ref:`tut-standardmodules` para mais informações."

#: ../../tutorial/modules.rst:199
msgid "\"Compiled\" Python files"
msgstr "Arquivos Python \"compilados\""

#: ../../tutorial/modules.rst:201
msgid ""
"As an important speed-up of the start-up time for short programs that use a "
"lot of standard modules, if a file called :file:`spam.pyc` exists in the "
"directory where :file:`spam.py` is found, this is assumed to contain an "
"already-\"byte-compiled\" version of the module :mod:`spam`. The "
"modification time of the version of :file:`spam.py` used to create :file:"
"`spam.pyc` is recorded in :file:`spam.pyc`, and the :file:`.pyc` file is "
"ignored if these don't match."
msgstr ""
"Para acelerar a inicialização de programas curtos que usam muitos módulos "
"da\n"
"biblioteca padrão, sempre que existe um arquivo chamado :file:`spam.pyc` no\n"
"mesmo diretório de :file:`spam.py`, o interpretador assume que aquele "
"arquivo\n"
"contém uma versão \"byte-compilada\" de :mod:`spam`. O horário de "
"modificação da\n"
"versão de :file:`spam.py` a partir da qual :file:`spam.pyc` foi gerado\n"
"é armazenada no arquivo compilado, e o :file:`.pyc` não é utilizado se o\n"
"horário não confere."

#: ../../tutorial/modules.rst:208
msgid ""
"Normally, you don't need to do anything to create the :file:`spam.pyc` file. "
"Whenever :file:`spam.py` is successfully compiled, an attempt is made to "
"write the compiled version to :file:`spam.pyc`.  It is not an error if this "
"attempt fails; if for any reason the file is not written completely, the "
"resulting :file:`spam.pyc` file will be recognized as invalid and thus "
"ignored later.  The contents of the :file:`spam.pyc` file are platform "
"independent, so a Python module directory can be shared by machines of "
"different architectures."
msgstr ""
"Normalmente, não é preciso fazer nada para gerar o arquivo :file:`spam."
"pyc`.\n"
"Sempre que :file:`spam.py` é compilado com sucesso, o interpretador tenta\n"
"salvar a versão compilada em :file:`spam.pyc`. Não há geração de um erro se\n"
"essa tentativa falhar; se por alguma razão o arquivo compilado não for\n"
"inteiramente gravado, o arquivo :file:`spam.pyc` resultante será "
"reconhecido\n"
"como inválido e, portanto, ignorado. O conteúdo do arquivo :file:`spam.pyc` "
"é\n"
"independente de plataforma, assim um diretório de módulos Python pode ser\n"
"compartilhado por máquinas de diferentes arquiteturas."

#: ../../tutorial/modules.rst:216
msgid "Some tips for experts:"
msgstr "Algumas dicas para os experts:"

#: ../../tutorial/modules.rst:218
msgid ""
"When the Python interpreter is invoked with the :option:`-O` flag, optimized "
"code is generated and stored in :file:`.pyo` files.  The optimizer currently "
"doesn't help much; it only removes :keyword:`assert` statements.  When :"
"option:`-O` is used, *all* :term:`bytecode` is optimized; ``.pyc`` files are "
"ignored and ``.py`` files are compiled to optimized bytecode."
msgstr ""
"* Quando o interpretador Python é invocado com a opção :option:`-O`, é "
"gerado\n"
" um código otimizado, armazenado em arquivos :file:`.pyo`. O otimizador "
"atual\n"
" não faz muita coisa; ele apenas remove instruções :keyword:`assert`. "
"Quando\n"
" :option:`-O` é utilizada, *todo* :term:`bytecode` é otimizado; arquivos\n"
" ``.pyc`` são ignorados e os arquivos ``.py`` são compilados para bytecode\n"
" otimizado."

#: ../../tutorial/modules.rst:224
msgid ""
"Passing two :option:`-O` flags to the Python interpreter (:option:`-OO`) "
"will cause the bytecode compiler to perform optimizations that could in some "
"rare cases result in malfunctioning programs.  Currently only ``__doc__`` "
"strings are removed from the bytecode, resulting in more compact :file:`."
"pyo` files.  Since some programs may rely on having these available, you "
"should only use this option if you know what you're doing."
msgstr ""
"* Passar duas opções :option:`-O` para o interpretador Python (:option:`-"
"OO`)\n"
" fará com que o compilador realize otimizações mais arriscadas, que em "
"alguns\n"
" casos raros podem acarretar o mal funcionamento de programas. Atualmente\n"
" apenas strings ``__doc__`` são removidas do bytecode, resultando em "
"arquivos\n"
" :file:`.pyo` mais compactos. Uma vez que alguns programas podem contar com "
"a\n"
" existência dessas docstrings, use essa opção somente se você souber o que\n"
" está fazendo."

#: ../../tutorial/modules.rst:231
msgid ""
"A program doesn't run any faster when it is read from a :file:`.pyc` or :"
"file:`.pyo` file than when it is read from a :file:`.py` file; the only "
"thing that's faster about :file:`.pyc` or :file:`.pyo` files is the speed "
"with which they are loaded."
msgstr ""
"* Um programa não executa mais rápido quando é lido de um arquivo :file:`."
"pyc` ou\n"
" :file:`.pyo` em comparação a quando é lido de um arquivo :file:`.py`. A "
"única\n"
" diferença é que nos dois primeiros casos o tempo de inicialização do "
"programa\n"
" é menor."

#: ../../tutorial/modules.rst:236
msgid ""
"When a script is run by giving its name on the command line, the bytecode "
"for the script is never written to a :file:`.pyc` or :file:`.pyo` file.  "
"Thus, the startup time of a script may be reduced by moving most of its code "
"to a module and having a small bootstrap script that imports that module.  "
"It is also possible to name a :file:`.pyc` or :file:`.pyo` file directly on "
"the command line."
msgstr ""
"* Quando um script é executado diretamente a partir o seu nome da linha de\n"
" comando, não são geradas as formas compiladas deste script em formato\n"
" :file:`.pyc` ou :file:`.pyo`. Portanto, o tempo de carga de um script pode\n"
" ser melhorado se transferirmos a maior parte de seu código para um módulo "
"e\n"
" utilizarmos o script menor apenas para inicialização. Também é possível\n"
" fornecer um arquivo :file:`.pyc` ou :file:`.pyo` diretamente para execução\n"
" do interpretador, passando seu nome na linha de comando."

#: ../../tutorial/modules.rst:243
msgid ""
"It is possible to have a file called :file:`spam.pyc` (or :file:`spam.pyo` "
"when :option:`-O` is used) without a file :file:`spam.py` for the same "
"module. This can be used to distribute a library of Python code in a form "
"that is moderately hard to reverse engineer."
msgstr ""
"* Na presença das formas compiladas (:file:`spam.pyc` e :file:`spam.pyo`) de "
"um\n"
" script, não há necessidade do código fonte (:file:`spam.py`). Isto\n"
" é útil na para se distribuir bibliotecas Python de uma forma que dificulta\n"
" moderadamente a engenharia reversa."

#: ../../tutorial/modules.rst:250
msgid ""
"The module :mod:`compileall` can create :file:`.pyc` files (or :file:`.pyo` "
"files when :option:`-O` is used) for all modules in a directory."
msgstr ""
"* O módulo :mod:`compileall` pode criar arquivos :file:`.pyc` (ou\n"
" :file:`.pyo` quando :option:`-O` é usada) para todos os módulos em um dado\n"
" diretório."

#: ../../tutorial/modules.rst:257
msgid "Standard Modules"
msgstr "Módulos padrão"

#: ../../tutorial/modules.rst:261
msgid ""
"Python comes with a library of standard modules, described in a separate "
"document, the Python Library Reference (\"Library Reference\" hereafter).  "
"Some modules are built into the interpreter; these provide access to "
"operations that are not part of the core of the language but are "
"nevertheless built in, either for efficiency or to provide access to "
"operating system primitives such as system calls.  The set of such modules "
"is a configuration option which also depends on the underlying platform.  "
"For example, the :mod:`winreg` module is only provided on Windows systems. "
"One particular module deserves some attention: :mod:`sys`, which is built "
"into every Python interpreter.  The variables ``sys.ps1`` and ``sys.ps2`` "
"define the strings used as primary and secondary prompts::"
msgstr ""
"Python possui uma biblioteca padrão de módulos, descrita em um documento em\n"
"separado, a Python Library Reference (doravante “Library Reference”). "
"Alguns\n"
"módulos estão embutidos no interpretador; estes possibilitam acesso a\n"
"operações que não são parte do núcleo da linguagem, mas estão no "
"interpretador\n"
"seja por eficiência ou para permitir o acesso a chamadas do sistema\n"
"operacional. O conjunto destes módulos é uma opção de configuração que "
"depende\n"
"também da plataforma subjacente. Por exemplo, o módulo :mod:`winreg` só "
"está\n"
"disponível em sistemas Windows. Existe um módulo que requer especial "
"atenção:\n"
":mod:`sys`, que é embutido em qualquer interpretador Python. As variáveis\n"
"``sys.ps1`` e ``sys.ps2`` definem as strings utilizadas como prompt primário "
"e\n"
"secundário::"

#: ../../tutorial/modules.rst:284
msgid ""
"These two variables are only defined if the interpreter is in interactive "
"mode."
msgstr ""
"Essas variáveis só estão definidas se o interpretador está em modo "
"interativo."

#: ../../tutorial/modules.rst:286
msgid ""
"The variable ``sys.path`` is a list of strings that determines the "
"interpreter's search path for modules. It is initialized to a default path "
"taken from the environment variable :envvar:`PYTHONPATH`, or from a built-in "
"default if :envvar:`PYTHONPATH` is not set.  You can modify it using "
"standard list operations::"
msgstr ""
"A variável ``sys.path`` contém uma lista de strings que determina os "
"caminhos\n"
"de busca de módulos conhecidos pelo interpretador. Ela é inicializada para "
"um\n"
"caminho padrão determinado pela variável de ambiente :envvar:`PYTHONPATH`, "
"ou\n"
"por um valor default interno se a variável não estiver definida. Você pode\n"
"modificar ``sys.path`` com as operações típicas de lista, por exemplo::"

#: ../../tutorial/modules.rst:299
msgid "The :func:`dir` Function"
msgstr "A função :func:`dir`"

#: ../../tutorial/modules.rst:301
msgid ""
"The built-in function :func:`dir` is used to find out which names a module "
"defines.  It returns a sorted list of strings::"
msgstr ""
"A função embutida :func:`dir` é usada para se descobrir quais nomes são\n"
"definidos por um módulo. Ela devolve uma lista ordenada de strings::"

#: ../../tutorial/modules.rst:324
msgid ""
"Without arguments, :func:`dir` lists the names you have defined currently::"
msgstr "Sem argumentos, :func:`dir` lista os nomes atualmente definidos:"

#: ../../tutorial/modules.rst:332
msgid ""
"Note that it lists all types of names: variables, modules, functions, etc."
msgstr ""
"Observe que ela lista todo tipo de nomes: variáveis, módulos, funções, etc."

#: ../../tutorial/modules.rst:336
msgid ""
":func:`dir` does not list the names of built-in functions and variables.  If "
"you want a list of those, they are defined in the standard module :mod:"
"`__builtin__`::"
msgstr ""
":func:`dir` não lista nomes de funções ou variáveis embutidas. Se quiser\n"
"conhecê-las, seus nomes estão definidos no módulo padrão :mod:`__builtin__`::"

#: ../../tutorial/modules.rst:373
msgid "Packages"
msgstr "Pacotes"

#: ../../tutorial/modules.rst:375
msgid ""
"Packages are a way of structuring Python's module namespace by using "
"\"dotted module names\".  For example, the module name :mod:`A.B` designates "
"a submodule named ``B`` in a package named ``A``.  Just like the use of "
"modules saves the authors of different modules from having to worry about "
"each other's global variable names, the use of dotted module names saves the "
"authors of multi-module packages like NumPy or Pillow from having to worry "
"about each other's module names."
msgstr ""
"Os pacotes são uma maneira de estruturar o \"espaço de nomes\" dos módulos "
"Python, usando \"nomes de módulo com pontos\". Por exemplo, o nome do "
"módulo :mod:`A.B` designa um sub-módulo chamado ``B``, em um pacote chamado "
"``A``. Assim como o uso de módulos evita que os autores de módulos "
"diferentes tenham que se preocupar com nomes de variáveis globais, o uso de "
"nomes de módulos com pontos evita que os autores de pacotes com muitos "
"módulos, como NumPy ou Pillow, tenham que se preocupar com os nomes dos "
"módulos uns dos outros."

#: ../../tutorial/modules.rst:383
msgid ""
"Suppose you want to design a collection of modules (a \"package\") for the "
"uniform handling of sound files and sound data.  There are many different "
"sound file formats (usually recognized by their extension, for example: :"
"file:`.wav`, :file:`.aiff`, :file:`.au`), so you may need to create and "
"maintain a growing collection of modules for the conversion between the "
"various file formats. There are also many different operations you might "
"want to perform on sound data (such as mixing, adding echo, applying an "
"equalizer function, creating an artificial stereo effect), so in addition "
"you will be writing a never-ending stream of modules to perform these "
"operations.  Here's a possible structure for your package (expressed in "
"terms of a hierarchical filesystem):"
msgstr ""
"Suponha que você queira projetar uma coleção de módulos (um \"pacote\") para "
"o\n"
"gerenciamento uniforme de arquivos de som. Existem muitos formatos "
"diferentes\n"
"(normalmente identificados pela extensão do nome de arquivo, por exemplo.\n"
":file:`.wav`, :file:`.aiff`, :file:`.au`), de forma que você pode precisar\n"
"criar e manter uma crescente coleção de módulos de conversão entre "
"formatos.\n"
"Ainda podem existir muitas operações diferentes passíveis de aplicação "
"sobre\n"
"os arquivos de som (mixagem, eco, equalização, efeito stereo artificial).\n"
"Logo, possivelmente você também estará escrevendo uma coleção sempre "
"crescente\n"
"de módulos para aplicar estas operações. Eis uma possível estrutura para\n"
"o seu pacote (expressa em termos de um sistema de arquivos hierárquico)::"

#: ../../tutorial/modules.rst:420
msgid ""
"When importing the package, Python searches through the directories on ``sys."
"path`` looking for the package subdirectory."
msgstr ""
"Ao importar esse pacote, Python busca pelo subdiretório com mesmo nome nos "
"diretórios\n"
"listados em ``sys.path``."

#: ../../tutorial/modules.rst:423
msgid ""
"The :file:`__init__.py` files are required to make Python treat the "
"directories as containing packages; this is done to prevent directories with "
"a common name, such as ``string``, from unintentionally hiding valid modules "
"that occur later on the module search path. In the simplest case, :file:"
"`__init__.py` can just be an empty file, but it can also execute "
"initialization code for the package or set the ``__all__`` variable, "
"described later."
msgstr ""
"Os arquivos :file:`__init__.py` são necessários para que Python trate os\n"
"diretórios como pacotes; isso foi feito para evitar que diretórios com "
"nomes\n"
"comuns, como ``string``, inadvertidamente ocultassem módulos válidos que\n"
"ocorram depois no caminho de busca. No caso mais simples, :file:`__init__."
"py`\n"
"pode ser um arquivo vazio. Porém, ele pode conter código de inicialização "
"para\n"
"o pacote ou definir a variável ``__all__``, que será descrita depois."

#: ../../tutorial/modules.rst:430
msgid ""
"Users of the package can import individual modules from the package, for "
"example::"
msgstr "Usuários do pacote podem importar módulos individuais, por exemplo::"

#: ../../tutorial/modules.rst:435
msgid ""
"This loads the submodule :mod:`sound.effects.echo`.  It must be referenced "
"with its full name. ::"
msgstr ""
"Isso carrega o submódulo :mod:`sound.effects.echo`. Ele deve ser "
"referenciado com\n"
"seu nome completo, como em::"

#: ../../tutorial/modules.rst:440
msgid "An alternative way of importing the submodule is::"
msgstr "Uma maneira alternativa para a importação desse módulo é::"

#: ../../tutorial/modules.rst:444
msgid ""
"This also loads the submodule :mod:`echo`, and makes it available without "
"its package prefix, so it can be used as follows::"
msgstr ""
"Isso carrega o submódulo :mod:`echo` sem necessidade de mencionar o prefixo "
"do\n"
"pacote no momento da utilização, assim::"

#: ../../tutorial/modules.rst:449
msgid ""
"Yet another variation is to import the desired function or variable "
"directly::"
msgstr "Também é possível importar diretamente uma única variável ou função::"

#: ../../tutorial/modules.rst:453
msgid ""
"Again, this loads the submodule :mod:`echo`, but this makes its function :"
"func:`echofilter` directly available::"
msgstr ""
"Novamente, isso carrega o submódulo :mod:`echo`, mas a função :func:"
"`echofilter`\n"
"está acessível diretamente sem prefixo::"

#: ../../tutorial/modules.rst:458
msgid ""
"Note that when using ``from package import item``, the item can be either a "
"submodule (or subpackage) of the package, or some  other name defined in the "
"package, like a function, class or variable.  The ``import`` statement first "
"tests whether the item is defined in the package; if not, it assumes it is a "
"module and attempts to load it.  If it fails to find it, an :exc:"
"`ImportError` exception is raised."
msgstr ""
"Observe que ao utilizar ``from package import item``, o item pode ser um "
"subpacote,\n"
"submódulo, classe, função ou variável. O comando ``import`` primeiro testa "
"se o\n"
"item está definido no pacote, senão assume que é um módulo e tenta carregá-"
"lo. Se\n"
"falhar em encontrar o módulo uma exceção :exc:`ImportError` é lançada."

#: ../../tutorial/modules.rst:465
msgid ""
"Contrarily, when using syntax like ``import item.subitem.subsubitem``, each "
"item except for the last must be a package; the last item can be a module or "
"a package but can't be a class or function or variable defined in the "
"previous item."
msgstr ""
"Em oposição, em uma construção como ``import item.subitem.subsubitem``, cada "
"item,\n"
"com exceção do último, deve ser um pacote. O último pode ser também um "
"pacote ou\n"
"módulo, mas nunca uma classe, função ou variável contida em um módulo."

#: ../../tutorial/modules.rst:474
msgid "Importing \\* From a Package"
msgstr "Importando \\* de um pacote"

#: ../../tutorial/modules.rst:478
msgid ""
"Now what happens when the user writes ``from sound.effects import *``?  "
"Ideally, one would hope that this somehow goes out to the filesystem, finds "
"which submodules are present in the package, and imports them all.  This "
"could take a long time and importing sub-modules might have unwanted side-"
"effects that should only happen when the sub-module is explicitly imported."
msgstr ""
"Agora, o que acontece quando um usuário escreve ``from sound.effects import\n"
"*`` ? Idealmente, poderia se esperar que este comando vasculhasse o sistema "
"de\n"
"arquivos, encontrasse todos submódulos presentes no pacote, e os "
"importassem.\n"
"Isso pode demorar muito e a importação de submódulos pode ocasionar efeitos\n"
"colaterais que somente deveriam ocorrer quando o submódulo é explicitamente\n"
"importado."

#: ../../tutorial/modules.rst:484
msgid ""
"The only solution is for the package author to provide an explicit index of "
"the package.  The :keyword:`import` statement uses the following convention: "
"if a package's :file:`__init__.py` code defines a list named ``__all__``, it "
"is taken to be the list of module names that should be imported when ``from "
"package import *`` is encountered.  It is up to the package author to keep "
"this list up-to-date when a new version of the package is released.  Package "
"authors may also decide not to support it, if they don't see a use for "
"importing \\* from their package.  For example, the file :file:`sound/"
"effects/__init__.py` could contain the following code::"
msgstr ""
"A única solução é o autor do pacote fornecer um índice explícito do pacote. "
"O\n"
"comando :keyword:`import` usa a seguinte convenção: se o arquivo\n"
":file:`__init__.py` do pacote define uma lista chamada ``__all__``, então "
"esta\n"
"lista indica os nomes dos módulos a serem importados quando o comando "
"``from\n"
"pacote import *`` é acionado. Fica a cargo do autor do pacote manter esta\n"
"lista atualizada, inclusive fica a seu critério excluir inteiramente o "
"suporte\n"
"a importação direta de todo o pacote através de ``from pacote import *``. "
"Por\n"
"exemplo, o arquivo :file:`sounds/effects/__init__.py` poderia conter apenas::"

#: ../../tutorial/modules.rst:496
msgid ""
"This would mean that ``from sound.effects import *`` would import the three "
"named submodules of the :mod:`sound` package."
msgstr ""
"Isso significaria que ``from sound.effects import *`` importaria apenas os\n"
"três submódulos especificados no pacote :mod:`sound`."

#: ../../tutorial/modules.rst:499
msgid ""
"If ``__all__`` is not defined, the statement ``from sound.effects import *`` "
"does *not* import all submodules from the package :mod:`sound.effects` into "
"the current namespace; it only ensures that the package :mod:`sound.effects` "
"has been imported (possibly running any initialization code in :file:"
"`__init__.py`) and then imports whatever names are defined in the package.  "
"This includes any names defined (and submodules explicitly loaded) by :file:"
"`__init__.py`.  It also includes any submodules of the package that were "
"explicitly loaded by previous :keyword:`import` statements.  Consider this "
"code::"
msgstr ""
"Se ``__all__`` não estiver definido, o comando ``from sound.effects import "
"*``\n"
"não importa todos os submódulos do pacote :mod:`sound.effects` no espaço de\n"
"nomes atual. Há apenas garantia que o pacote :mod:`sound.effects` foi\n"
"importado (possivelmente executando qualquer código de inicialização em\n"
":file:`__init__.py`) juntamente com os nomes definidos no pacote. Isso "
"inclui\n"
"todo nome definido em :file:`__init__.py` bem como em qualquer submódulo\n"
"importado a partir deste. Também inclui quaisquer submódulos do pacote que\n"
"tenham sido carregados explicitamente por comandos :keyword:`import`\n"
"anteriores. Considere o código abaixo::"

#: ../../tutorial/modules.rst:512
msgid ""
"In this example, the :mod:`echo` and :mod:`surround` modules are imported in "
"the current namespace because they are defined in the :mod:`sound.effects` "
"package when the ``from...import`` statement is executed.  (This also works "
"when ``__all__`` is defined.)"
msgstr ""
"Nesse exemplo, os nomes :mod:`echo` e :mod:`surround` são importados no "
"espaço\n"
"de nomes atual no momento em que o comando ``from ... import`` é executado,\n"
"pois estão definidos no pacote :mod:`sound.effects`. (Isso também funciona\n"
"quando ``__all__`` estiver definida.)"

#: ../../tutorial/modules.rst:517
msgid ""
"Although certain modules are designed to export only names that follow "
"certain patterns when you use ``import *``, it is still considered bad "
"practice in production code."
msgstr ""
"Apesar de que certos módulos são projetados para exportar apenas nomes\n"
"conforme algum critério quando se faz ``import *``, ainda assim essa "
"sintaxe\n"
"é considerada uma prática ruim em código de produção."

#: ../../tutorial/modules.rst:521
msgid ""
"Remember, there is nothing wrong with using ``from package import "
"specific_submodule``!  In fact, this is the recommended notation unless the "
"importing module needs to use submodules with the same name from different "
"packages."
msgstr ""
"Lembre-se, não há nada errado em usar ``from package import "
"specific_submodule``! De fato, essa é a notação recomendada, a menos que o "
"módulo importado necessite usar sub-módulos com o mesmo nome, de diferentes "
"pacotes."

#: ../../tutorial/modules.rst:528
msgid "Intra-package References"
msgstr "Referências em um mesmo pacote"

#: ../../tutorial/modules.rst:530
msgid ""
"The submodules often need to refer to each other.  For example, the :mod:"
"`surround` module might use the :mod:`echo` module.  In fact, such "
"references are so common that the :keyword:`import` statement first looks in "
"the containing package before looking in the standard module search path. "
"Thus, the :mod:`surround` module can simply use ``import echo`` or ``from "
"echo import echofilter``.  If the imported module is not found in the "
"current package (the package of which the current module is a submodule), "
"the :keyword:`import` statement looks for a top-level module with the given "
"name."
msgstr ""
"Os submódulos frequentemente precisam referenciar uns aos outros. Por "
"exemplo, o\n"
"módulo :mod:`surround` talvez precise utilizar o módulo :mod:`echo`. De "
"fato, tais\n"
"referências são tão comuns que o comando :keyword:`import` primeiro busca "
"módulos\n"
"dentro do pacote antes de utilizar o caminho de busca padrão. Portanto, o "
"módulo\n"
":mod:`surround` pode usar simplesmente ``import echo`` ou ``from echo "
"import\n"
"echofilter``. Se o módulo importado não for encontrado no pacote atual (o "
"pacote\n"
"do qual o módulo atual é submódulo), então o comando :keyword:`import`\n"
"procura por um módulo de mesmo nome fora do pacote (nos locais definidos em\n"
"``sys.path``)."

#: ../../tutorial/modules.rst:539
msgid ""
"When packages are structured into subpackages (as with the :mod:`sound` "
"package in the example), you can use absolute imports to refer to submodules "
"of siblings packages.  For example, if the module :mod:`sound.filters."
"vocoder` needs to use the :mod:`echo` module in the :mod:`sound.effects` "
"package, it can use ``from sound.effects import echo``."
msgstr ""
"Quando pacotes são estruturados em subpacotes (como no pacote :mod:`sound` "
"do\n"
"exemplo), pode ser usar a sintaxe de um :keyword:`import` absoluto para se\n"
"referir aos submódulos de pacotes irmãos (o que na prática é uma forma de\n"
"fazer um import relativo, a partir da base do pacote). Por exemplo, se o\n"
"módulo :mod:`sound.filters.vocoder` precisa usar o módulo :mod:`echo` do\n"
"pacote :mod:`sound.effects`, é preciso importá-lo com ``from sound.effects\n"
"import echo``."

#: ../../tutorial/modules.rst:545
msgid ""
"Starting with Python 2.5, in addition to the implicit relative imports "
"described above, you can write explicit relative imports with the ``from "
"module import name`` form of import statement. These explicit relative "
"imports use leading dots to indicate the current and parent packages "
"involved in the relative import. From the :mod:`surround` module for "
"example, you might use::"
msgstr ""
"A partir do Python 2.5, em adição à importação relativa implícita descrita\n"
"acima, você pode usar importação relativa explícita na forma ``from "
"import``.\n"
"Essas importações relativas explícitas usam prefixos com pontos indicar os\n"
"pacotes atuais e seus pais envolvidos na importação. A partir do módulo\n"
":mod:`surround` por exemplo, pode-se usar::"

#: ../../tutorial/modules.rst:555
msgid ""
"Note that both explicit and implicit relative imports are based on the name "
"of the current module. Since the name of the main module is always ``"
"\"__main__\"``, modules intended for use as the main module of a Python "
"application should always use absolute imports."
msgstr ""
"Note que tanto a importação relativa explícita quanto a implícita baseiam-"
"se\n"
"no nome do módulo atual. Uma vez que o nome do módulo principal é sempre\n"
"``\"__main__\"``, módulos que serão o módulo principal de uma aplicação "
"Python\n"
"devem sempre usar importações absolutas."

#: ../../tutorial/modules.rst:562
msgid "Packages in Multiple Directories"
msgstr "Pacotes em múltiplos diretórios"

#: ../../tutorial/modules.rst:564
msgid ""
"Packages support one more special attribute, :attr:`__path__`.  This is "
"initialized to be a list containing the name of the directory holding the "
"package's :file:`__init__.py` before the code in that file is executed.  "
"This variable can be modified; doing so affects future searches for modules "
"and subpackages contained in the package."
msgstr ""
"Pacotes possuem mais um atributo especial, :attr:`__path__`. Ele é\n"
"inicializado como uma lista contendo o nome do diretório onde está o "
"arquivo\n"
":file:`__init__.py` do pacote, antes do código naquele arquivo ser "
"executado.\n"
"Esta variável pode ser modificada; isso afeta a busca futura de módulos e\n"
"subpacotes contidos no pacote."

#: ../../tutorial/modules.rst:570
msgid ""
"While this feature is not often needed, it can be used to extend the set of "
"modules found in a package."
msgstr ""
"Apesar de não ser muito usado, esse mecanismo permite estender o conjunto "
"de\n"
"módulos encontrados em um pacote."

#: ../../tutorial/modules.rst:575
msgid "Footnotes"
msgstr "Notas de Rodapé"

#: ../../tutorial/modules.rst:576
msgid ""
"In fact function definitions are also 'statements' that are 'executed'; the "
"execution of a module-level function definition enters the function name in "
"the module's global symbol table."
msgstr ""
"[#] Na verdade, definições de funções também são 'comandos' que são\n"
" 'executados'; a execução da definição de uma função coloca o nome da\n"
" função na tabela de símbolos global do módulo."
