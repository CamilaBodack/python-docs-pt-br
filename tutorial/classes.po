# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:46+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: Hildeberto Abreu Magalhães <hildeberto@gmail.com>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/python-doc/"
"python-27/language/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/classes.rst:5
msgid "Classes"
msgstr "Classes"

#: ../../tutorial/classes.rst:7
msgid ""
"Compared with other programming languages, Python's class mechanism adds "
"classes with a minimum of new syntax and semantics.  It is a mixture of the "
"class mechanisms found in C++ and Modula-3.  Python classes provide all the "
"standard features of Object Oriented Programming: the class inheritance "
"mechanism allows multiple base classes, a derived class can override any "
"methods of its base class or classes, and a method can call the method of a "
"base class with the same name.  Objects can contain arbitrary amounts and "
"kinds of data.  As is true for modules, classes partake of the dynamic "
"nature of Python: they are created at runtime, and can be modified further "
"after creation."
msgstr ""
"Em comparação com outras linguagens, o mecanismo de classes de Python "
"introduz a programação orientada a objetos sem acrescentar muitas novidades "
"de sintaxe ou semântica. É uma mistura de mecanismos equivalentes "
"encontrados em C++ e Modula-3. As classes em Python oferecem todas as "
"características tradicionais da programação a orientada a objetos: o "
"mecanismo de herança permite múltiplas classes base (herança múltipla), uma "
"classe derivada pode sobrescrever quaisquer métodos de uma classe ancestral, "
"e um método pode invocar outro método homônimo de uma classe ancestral. "
"Objetos podem armazenar uma quantidade arbitrária de dados de qualquer tipo. "
"Assim como acontece com os módulos, as classes fazem parte da natureza "
"dinâmica de Python: são criadas em tempo de execução, e podem ser alteradas "
"após sua criação."

#: ../../tutorial/classes.rst:17
msgid ""
"In C++ terminology, normally class members (including the data members) are "
"*public* (except see below :ref:`tut-private`), and all member functions are "
"*virtual*.  As in Modula-3, there are no shorthands for referencing the "
"object's members from its methods: the method function is declared with an "
"explicit first argument representing the object, which is provided "
"implicitly by the call.  As in Smalltalk, classes themselves are objects.  "
"This provides semantics for importing and renaming.  Unlike C++ and "
"Modula-3, built-in types can be used as base classes for extension by the "
"user.  Also, like in C++, most built-in operators with special syntax "
"(arithmetic operators, subscripting etc.) can be redefined for class "
"instances."
msgstr ""
"Usando a terminologia de C++, todos os membros de uma classe (incluindo "
"dados) são públicos, e todos as funções membro são virtuais. Como em "
"Modula-3, não existem atalhos para referenciar membros do objeto de dentro "
"dos seus métodos. Um método (função definida em uma classe) é declarado com "
"um primeiro argumento explícito representando o objeto (instância da "
"classe), que é fornecido implicitamente pela invocação. Como em Smalltalk, "
"classes são objetos. Isso fornece uma semântica para importar e renomear. Ao "
"contrário de C++ ou Modula-3, tipos pré-definidos podem ser utilizados como "
"classes base para extensões de usuário por herança. Como em C++, mas "
"diferentemente de Modula-3, a maioria dos operadores (aritméticos, indexação,"
"etc) podem ser redefinidos para instâncias de classe."

#: ../../tutorial/classes.rst:28
msgid ""
"(Lacking universally accepted terminology to talk about classes, I will make "
"occasional use of Smalltalk and C++ terms.  I would use Modula-3 terms, "
"since its object-oriented semantics are closer to those of Python than C++, "
"but I expect that few readers have heard of it.)"
msgstr ""
"(Na falta de uma terminologia universalmente aceita para falar sobre "
"classes, ocasionalmente farei uso de termos comuns em Smalltalk ou C++. Eu "
"usaria termos de Modula-3, já que sua semântica é mais próxima a de Python, "
"mas creio que poucos leitores já ouviram falar dessa linguagem.)"

#: ../../tutorial/classes.rst:37
msgid "A Word About Names and Objects"
msgstr "Uma palavra sobre nomes e objetos"

#: ../../tutorial/classes.rst:39
msgid ""
"Objects have individuality, and multiple names (in multiple scopes) can be "
"bound to the same object.  This is known as aliasing in other languages.  "
"This is usually not appreciated on a first glance at Python, and can be "
"safely ignored when dealing with immutable basic types (numbers, strings, "
"tuples).  However, aliasing has a possibly surprising effect on the "
"semantics of Python code involving mutable objects such as lists, "
"dictionaries, and most other types. This is usually used to the benefit of "
"the program, since aliases behave like pointers in some respects.  For "
"example, passing an object is cheap since only a pointer is passed by the "
"implementation; and if a function modifies an object passed as an argument, "
"the caller will see the change --- this eliminates the need for two "
"different argument passing mechanisms as in Pascal."
msgstr ""
"Objetos têm individualidade, e vários nomes (inclusive em diferentes "
"escopos) podem estar vinculados a um mesmo objeto. Isso é chamado de "
"*aliasing* em outras linguagens. (N.d.T. *aliasing* é, literalmente, "
"\"apelidamento\": um mesmo objeto pode ter vários apelidos.) À primeira "
"vista, esta característica não é muito apreciada, e pode ser seguramente "
"ignorada ao lidar com tipos imutáveis (números, strings, tuplas). "
"Entretanto, aliasing pode ter um efeito inesperado sobre a semântica de "
"código Python envolvendo objetos mutáveis como listas, dicionários e a "
"maioria dos outros tipos. Isso pode ser usado em benefício do programa, "
"porque os *aliases* (apelidos) funcionam de certa forma como ponteiros. Por "
"exemplo, passar um objeto como argumento é barato, pois só um ponteiro é "
"passado na implementação; e se uma função modifica um objeto passado como "
"argumento, o invocador verá a mudança --- isso elimina a necessidade de ter "
"dois mecanismos de passagem de parâmetros como em Pascal.  \n"
"\n"
"N.d.T. Na terminologia de C++ e Java, o que o parágrafo acima denomina\n"
"\"apelidos\" são identificadores de referências (variáveis de referência), e "
"os\n"
"ponteiros são as próprias referências. Se uma variável ``a`` está associada "
"a\n"
"um objeto qualquer, informalmente dizemos que a variável \"contém\" o "
"objeto,\n"
"mas na realidade o objeto existe independente da variável, e o conteúdo da\n"
"variável é apenas uma referência (um ponteiro) para o objeto. O *aliasing*\n"
"ocorre quando existem diversas variáveis, digamos ``a``, ``b`` e ``c``,\n"
"apontando para o mesmo objeto."

#: ../../tutorial/classes.rst:55
msgid "Python Scopes and Namespaces"
msgstr "Escopos e Namespaces"

#: ../../tutorial/classes.rst:57
msgid ""
"Before introducing classes, I first have to tell you something about "
"Python's scope rules.  Class definitions play some neat tricks with "
"namespaces, and you need to know how scopes and namespaces work to fully "
"understand what's going on. Incidentally, knowledge about this subject is "
"useful for any advanced Python programmer."
msgstr ""
"Antes de introduzir classes, é preciso falar das regras de escopo em Python. "
"Definições de classe fazem alguns truques com *namespaces* (espaços de "
"nomes). Portanto, primeiro é preciso entender claramente como escopos e "
"*namespaces* funcionam. Esse conhecimento é muito útil para o programador "
"avançado em Python."

#: ../../tutorial/classes.rst:63
msgid "Let's begin with some definitions."
msgstr "Vamos começar com algumas definições."

#: ../../tutorial/classes.rst:65
msgid ""
"A *namespace* is a mapping from names to objects.  Most namespaces are "
"currently implemented as Python dictionaries, but that's normally not "
"noticeable in any way (except for performance), and it may change in the "
"future.  Examples of namespaces are: the set of built-in names (containing "
"functions such as :func:`abs`, and built-in exception names); the global "
"names in a module; and the local names in a function invocation.  In a sense "
"the set of attributes of an object also form a namespace.  The important "
"thing to know about namespaces is that there is absolutely no relation "
"between names in different namespaces; for instance, two different modules "
"may both define a function ``maximize`` without confusion --- users of the "
"modules must prefix it with the module name."
msgstr ""
"Um *namespace* (ou espaço de nomes) é um mapeamento que associa nomes a "
"objetos. Atualmente, são implementados como dicionários em Python, mas isso "
"não é perceptível (a não ser pelo desempenho), e pode mudar no futuro. "
"Exemplos de espaços de nomes são: o conjunto de nomes pré-definidos (funções "
"como :func:`abs` e as exceções embutidas); nomes globais em um módulo; e "
"nomes\n"
"locais na invocação de uma função. De uma certa forma, os atributos de um "
"objeto também formam um espaço de nomes. O mais importante é saber que não "
"existe nenhuma relação entre nomes em espaços distintos. Por exemplo, dois "
"módulos podem definir uma função de nome ``maximize`` sem confusão --- "
"usuários dos módulos devem prefixar a função com o nome do módulo para "
"evitar colisão."

#: ../../tutorial/classes.rst:76
msgid ""
"By the way, I use the word *attribute* for any name following a dot --- for "
"example, in the expression ``z.real``, ``real`` is an attribute of the "
"object ``z``.  Strictly speaking, references to names in modules are "
"attribute references: in the expression ``modname.funcname``, ``modname`` is "
"a module object and ``funcname`` is an attribute of it.  In this case there "
"happens to be a straightforward mapping between the module's attributes and "
"the global names defined in the module: they share the same namespace!  [#]_"
msgstr ""
"A propósito, utilizo a palavra *atributo* para qualquer nome depois de um "
"ponto. Na expressão ``z.real``, por exemplo, ``real`` é um atributo do "
"objeto ``z``. Estritamente falando, referências para nomes em módulos são "
"atributos: na expressão ``nomemod.nomefunc``, ``nomemod`` é um objeto módulo "
"e ``nomefunc`` é um de seus atributos. Neste caso, existe um mapeamento "
"direto entre os atributos de um módulo e os nomes globais definidos no "
"módulo: eles compartilham o mesmo espaço de nomes! [#]_"

#: ../../tutorial/classes.rst:84
msgid ""
"Attributes may be read-only or writable.  In the latter case, assignment to "
"attributes is possible.  Module attributes are writable: you can write "
"``modname.the_answer = 42``.  Writable attributes may also be deleted with "
"the :keyword:`del` statement.  For example, ``del modname.the_answer`` will "
"remove the attribute :attr:`the_answer` from the object named by ``modname``."
msgstr ""
"Atributos podem ser somente para leitura ou para leitura e escrita. No "
"segundo caso, é possível atribuir um novo valor ao atributo. (N.d.T. Também "
"é possível criar novos atributos.) Atributos de módulos são passíveis de "
"atribuição: você pode escrever ``nomemod.a_reposta = 42``. Atributos que "
"aceitam escrita também podem ser apagados através do comando :keyword:`del`. "
"Por exemplo, ``del nomemod.a_reposta`` remove o atributo :attr:`a_resposta` "
"do objeto referenciado por ``nomemod``."

#: ../../tutorial/classes.rst:90
msgid ""
"Namespaces are created at different moments and have different lifetimes.  "
"The namespace containing the built-in names is created when the Python "
"interpreter starts up, and is never deleted.  The global namespace for a "
"module is created when the module definition is read in; normally, module "
"namespaces also last until the interpreter quits.  The statements executed "
"by the top-level invocation of the interpreter, either read from a script "
"file or interactively, are considered part of a module called :mod:"
"`__main__`, so they have their own global namespace.  (The built-in names "
"actually also live in a module; this is called :mod:`__builtin__`.)"
msgstr ""
"Espaços de nomes são criados em momentos diferentes e possuem diferentes "
"ciclos de vida. O espaço de nomes que contém os nomes embutidos é criado "
"quando o interpretador inicializa e nunca é removido. O espaço de nomes "
"global de um módulo é criado quando a definição do módulo é lida, e "
"normalmente duram até a terminação do interpretador. Os comandos executados "
"pela invocação do\n"
"interpretador, pela leitura de um script com programa principal, ou "
"interativamente, são parte do módulo chamado :mod:`__main__`, e portanto "
"possuem seu próprio espaço de nomes. (Os nomes embutidos possuem seu próprio "
"espaço de nomes no módulo chamado :mod:`__builtin__`.)."

#: ../../tutorial/classes.rst:100
msgid ""
"The local namespace for a function is created when the function is called, "
"and deleted when the function returns or raises an exception that is not "
"handled within the function.  (Actually, forgetting would be a better way to "
"describe what actually happens.)  Of course, recursive invocations each have "
"their own local namespace."
msgstr ""
"O espaço de nomes local de uma função é criado quando a função é invocada, e "
"apagado quando a função retorna ou levanta uma exceção que não é tratada na "
"própria função. (Na verdade, uma forma melhor de descrever o que realmente "
"acontece é que o espaço de nomes local é \"esquecido\" quando a função "
"termina.) Naturalmente, cada invocação recursiva de uma função tem seu "
"próprio espaço de nomes."

#: ../../tutorial/classes.rst:106
msgid ""
"A *scope* is a textual region of a Python program where a namespace is "
"directly accessible.  \"Directly accessible\" here means that an unqualified "
"reference to a name attempts to find the name in the namespace."
msgstr ""
"Um *escopo* (*scope*) é uma região textual de um programa Python onde um "
"espaço de nomes é diretamente acessível. Aqui, \"diretamente acessível\" "
"significa que uma referência sem um prefixo qualificador permite o acesso ao "
"nome."

#: ../../tutorial/classes.rst:110
msgid ""
"Although scopes are determined statically, they are used dynamically. At any "
"time during execution, there are at least three nested scopes whose "
"namespaces are directly accessible:"
msgstr ""
"Ainda que escopos sejam determinados estaticamente, eles são usados "
"dinamicamente. A qualquer momento durante a execução, existem no mínimo três "
"escopos diretamente acessíveis:"

#: ../../tutorial/classes.rst:114
msgid "the innermost scope, which is searched first, contains the local names"
msgstr ""
"* o escopo mais interno (que é acessado primeiro) contendo nomes locais;"

#: ../../tutorial/classes.rst:115
msgid ""
"the scopes of any enclosing functions, which are searched starting with the "
"nearest enclosing scope, contains non-local, but also non-global names"
msgstr ""
"* os escopos das funções que envolvem a função atual, que são acessados a "
"partir do escopo mias próximo, contém nomes não-locais mas também não-"
"globais;"

#: ../../tutorial/classes.rst:117
msgid "the next-to-last scope contains the current module's global names"
msgstr "* o penúltimo escopo contém os nomes globais do módulo atual;"

#: ../../tutorial/classes.rst:118
msgid ""
"the outermost scope (searched last) is the namespace containing built-in "
"names"
msgstr ""
"* e o escopo mais externo (acessado por último) contém os nomes das funções "
"embutidas e demais objetos pré-definidos do interpretador."

#: ../../tutorial/classes.rst:120
msgid ""
"If a name is declared global, then all references and assignments go "
"directly to the middle scope containing the module's global names. "
"Otherwise, all variables found outside of the innermost scope are read-only "
"(an attempt to write to such a variable will simply create a *new* local "
"variable in the innermost scope, leaving the identically named outer "
"variable unchanged)."
msgstr ""
"Se um nome é declarado no escopo global, então todas as referências e "
"atribuições valores vão diretamente para o escopo intermediário que contém "
"os nomes globais do módulo. Caso contrário, todas as variáveis encontradas "
"fora do escopo mais interno são apenas para leitura (a tentativa de atribuir "
"valores a essas variáveis irá simplesmente criar uma *nova* variável local, "
"no escopo interno, não alterando nada na variável de nome idêntico fora "
"dele)."

#: ../../tutorial/classes.rst:126
msgid ""
"Usually, the local scope references the local names of the (textually) "
"current function.  Outside functions, the local scope references the same "
"namespace as the global scope: the module's namespace. Class definitions "
"place yet another namespace in the local scope."
msgstr ""
"Normalmente, o escopo local referencia os nomes locais da função corrente no "
"texto do programa. Fora de funções, o escopo local referencia os nomes do "
"escopo global: espaço de nomes do módulo. Definições de classes adicionam um "
"outro espaço de nomes ao escopo local."

#: ../../tutorial/classes.rst:131
msgid ""
"It is important to realize that scopes are determined textually: the global "
"scope of a function defined in a module is that module's namespace, no "
"matter from where or by what alias the function is called.  On the other "
"hand, the actual search for names is done dynamically, at run time --- "
"however, the language definition is evolving towards static name resolution, "
"at \"compile\" time, so don't rely on dynamic name resolution!  (In fact, "
"local variables are already determined statically.)"
msgstr ""
"É importante perceber que escopos são determinados estaticamente, pelo texto "
"do código fonte: o escopo global de uma função definida em um módulo é o "
"espaço de nomes deste módulo, sem importar de onde ou por qual apelido a "
"função é invocada. Por outro lado, a busca de nomes é dinâmica, ocorrendo "
"durante a execução. Porém, a evolução da linguagem está caminhando para uma "
"resolução de nomes estática, em \"tempo de compilação\" (N.d.T. quando um "
"módulo é carregado ele é compilado em memória), portanto não conte com a "
"resolução dinâmica de nomes! (De fato, variáveis locais já são resolvidas "
"estaticamente.)"

#: ../../tutorial/classes.rst:139
msgid ""
"A special quirk of Python is that -- if no :keyword:`global` statement is in "
"effect -- assignments to names always go into the innermost scope.  "
"Assignments do not copy data --- they just bind names to objects.  The same "
"is true for deletions: the statement ``del x`` removes the binding of ``x`` "
"from the namespace referenced by the local scope.  In fact, all operations "
"that introduce new names use the local scope: in particular, :keyword:"
"`import` statements and function definitions bind the module or function "
"name in the local scope.  (The :keyword:`global` statement can be used to "
"indicate that particular variables live in the global scope.)"
msgstr ""
"Uma peculiaridade de Python é que atribuições ocorrem sempre no escopo mais "
"interno, exceto quando o comando :keyword:`global` é usado. Atribuições não "
"copiam dados, apenas associam nomes a objetos. O mesmo vale para remoções: o "
"comando ``del x`` remove o vínculo de ``x`` do espaço de nomes do escopo "
"local. De fato, todas as operações que introduzem novos nomes usam o escopo "
"local. Em particular, instruções :keyword:`import` e definições de funções "
"associam o nome módulo ou da função ao escopo local. (A palavra reservada :"
"keyword:`global` pode ser usada para indicar que certas variáveis residem no "
"escopo global ao invés do local.)"

#: ../../tutorial/classes.rst:153
msgid "A First Look at Classes"
msgstr "Primeiro contato com classes"

#: ../../tutorial/classes.rst:155
msgid ""
"Classes introduce a little bit of new syntax, three new object types, and "
"some new semantics."
msgstr ""
"Classes introduzem novidades sintáticas, três novos tipos de objetos, e "
"também alguma semântica nova."

#: ../../tutorial/classes.rst:162
msgid "Class Definition Syntax"
msgstr "Sintaxe de definição de classe"

#: ../../tutorial/classes.rst:164
msgid "The simplest form of class definition looks like this::"
msgstr "A forma mais simples de definir uma classe é::"

#: ../../tutorial/classes.rst:173
msgid ""
"Class definitions, like function definitions (:keyword:`def` statements) "
"must be executed before they have any effect.  (You could conceivably place "
"a class definition in a branch of an :keyword:`if` statement, or inside a "
"function.)"
msgstr ""
"Definições de classes, assim como definições de funções (instruções :keyword:"
"`def`), precisam ser executados antes que tenham qualquer efeito. (Por "
"exemplo, você pode colocar uma definição de classe dentro de teste "
"condicional :keyword:`if` ou dentro de uma função.)"

#: ../../tutorial/classes.rst:177
msgid ""
"In practice, the statements inside a class definition will usually be "
"function definitions, but other statements are allowed, and sometimes useful "
"--- we'll come back to this later.  The function definitions inside a class "
"normally have a peculiar form of argument list, dictated by the calling "
"conventions for methods --- again, this is explained later."
msgstr ""
"Na prática, as declarações dentro da definição de classe geralmente serão "
"definições de função, mas outras declarações são permitidas e, por vezes, "
"úteis --- falaremos sobre isso mais tarde. As definições de função dentro de "
"uma classe normalmente têm uma forma peculiar de lista de argumentos, ditada "
"pelas convenções de chamada para métodos --- novamente, isso abordado mais "
"tarde."

#: ../../tutorial/classes.rst:183
msgid ""
"When a class definition is entered, a new namespace is created, and used as "
"the local scope --- thus, all assignments to local variables go into this "
"new namespace.  In particular, function definitions bind the name of the new "
"function here."
msgstr ""
"Quando se inicia a definição de classe, um novo namespace é criado, e usado "
"como escopo local --- assim, todas atribuições a variáveis locais ocorrem "
"nesse namespace. Em particular, funções definidas aqui são vinculadas a "
"nomes nesse escopo."

#: ../../tutorial/classes.rst:188
msgid ""
"When a class definition is left normally (via the end), a *class object* is "
"created.  This is basically a wrapper around the contents of the namespace "
"created by the class definition; we'll learn more about class objects in the "
"next section.  The original local scope (the one in effect just before the "
"class definition was entered) is reinstated, and the class object is bound "
"here to the class name given in the class definition header (:class:"
"`ClassName` in the example)."
msgstr ""
"Quando o processamento de uma definição de classe é completado (normalmente, "
"sem erros), um *objeto classe* é criado. Este objeto encapsula o conteúdo do "
"espaço de nomes criado pela definição da classe; aprenderemos mais sobre "
"objetos classe na próxima seção. O escopo local que estava vigente antes da "
"definição da classe é reativado, e o objeto classe é vinculado ao "
"identificador da classe nesse escopo (no exemplo acima, :class:"
"`NomeDaClasse` é o identificador da classe)."

#: ../../tutorial/classes.rst:200
msgid "Class Objects"
msgstr "Objetos de Classe"

#: ../../tutorial/classes.rst:202
msgid ""
"Class objects support two kinds of operations: attribute references and "
"instantiation."
msgstr ""
"Objetos classe suportam dois tipos de operações: *referências a atributos* e "
"*instanciação*."

#: ../../tutorial/classes.rst:205
msgid ""
"*Attribute references* use the standard syntax used for all attribute "
"references in Python: ``obj.name``.  Valid attribute names are all the names "
"that were in the class's namespace when the class object was created.  So, "
"if the class definition looked like this::"
msgstr ""
"*Referências a atributos* de classe utilizam a sintaxe padrão utilizada para "
"quaisquer referências a atributos em Python: ``obj.nome``. Atributos válidos "
"são todos os nomes presentes dentro do namespace da classe quando o objeto "
"classe foi criado. Portanto, se a definição da classe foi assim::"

#: ../../tutorial/classes.rst:217
msgid ""
"then ``MyClass.i`` and ``MyClass.f`` are valid attribute references, "
"returning an integer and a function object, respectively. Class attributes "
"can also be assigned to, so you can change the value of ``MyClass.i`` by "
"assignment. :attr:`__doc__` is also a valid attribute, returning the "
"docstring belonging to the class: ``\"A simple example class\"``."
msgstr ""
"então ``MinhaClasse.i`` e ``MinhaClasse.f`` são referências válidas, que "
"acessam, respectivamente, um inteiro e um objeto função. É possível mudar os "
"valores dos atributos da classe, ou mesmo criar novos atributos, fazendo uma "
"atribuição simples assim: ``MinhaClasse.i = 10``. O nome ``__doc__`` "
"identifica outro atributo válido da classe, referenciando a *docstring* "
"associada à ela: ``\"Um exemplo simples de classe\"``."

#: ../../tutorial/classes.rst:223
msgid ""
"Class *instantiation* uses function notation.  Just pretend that the class "
"object is a parameterless function that returns a new instance of the class. "
"For example (assuming the above class)::"
msgstr ""
"Para *instanciar* uma classe, usa-se a sintaxe de invocar uma função. Apenas "
"finja que o objeto classe do exemplo é uma função sem parâmetros, que "
"devolve uma nova instância da classe. Por exemplo (continuando o exemplo "
"acima)::"

#: ../../tutorial/classes.rst:229
msgid ""
"creates a new *instance* of the class and assigns this object to the local "
"variable ``x``."
msgstr ""
"cria uma nova *instância* da classe e atribui o objeto resultante à variável "
"local ``x``."

#: ../../tutorial/classes.rst:232
msgid ""
"The instantiation operation (\"calling\" a class object) creates an empty "
"object. Many classes like to create objects with instances customized to a "
"specific initial state. Therefore a class may define a special method named :"
"meth:`__init__`, like this::"
msgstr ""
"A operação de instanciação (\"invocar\" um objeto classe) cria um objeto "
"vazio. Muitas classes preferem criar novos objetos com um estado inicial "
"predeterminado. Para tanto, a classe pode definir um método especial "
"chamado :meth:`__init__`, assim::"

#: ../../tutorial/classes.rst:240
msgid ""
"When a class defines an :meth:`__init__` method, class instantiation "
"automatically invokes :meth:`__init__` for the newly-created class "
"instance.  So in this example, a new, initialized instance can be obtained "
"by::"
msgstr ""
"Quando uma classe define um método :meth:`__init__`, o processo de "
"instanciação automaticamente invoca :meth:`__init__` sobre a instância recém "
"criada. Em nosso exemplo, uma nova instância já inicializada pode ser obtida "
"desta maneira::"

#: ../../tutorial/classes.rst:246
msgid ""
"Of course, the :meth:`__init__` method may have arguments for greater "
"flexibility.  In that case, arguments given to the class instantiation "
"operator are passed on to :meth:`__init__`.  For example, ::"
msgstr ""
"Naturalmente, o método :meth:`__init__` pode ter parâmetros para maior "
"flexibilidade. Neste caso, os argumentos fornecidos na invocação da classe "
"serão passados para o método :meth:`__init__`. Por exemplo::"

#: ../../tutorial/classes.rst:263
msgid "Instance Objects"
msgstr "Objetos de Instância"

#: ../../tutorial/classes.rst:265
msgid ""
"Now what can we do with instance objects?  The only operations understood by "
"instance objects are attribute references.  There are two kinds of valid "
"attribute names, data attributes and methods."
msgstr ""
"Agora, o que podemos fazer com instâncias? As únicas operações reconhecidas "
"por instâncias são referências a atributos. Existem dois tipos de nomes de "
"atributos válidos: atributos de dados (*data attributes*) e métodos."

#: ../../tutorial/classes.rst:269
msgid ""
"*data attributes* correspond to \"instance variables\" in Smalltalk, and to "
"\"data members\" in C++.  Data attributes need not be declared; like local "
"variables, they spring into existence when they are first assigned to.  For "
"example, if ``x`` is the instance of :class:`MyClass` created above, the "
"following piece of code will print the value ``16``, without leaving a "
"trace::"
msgstr ""
"Atributos de dados correspondem a \"variáveis de instância\" em Smalltalk, e "
"a \"data members\" em C++. Atributos de dados não precisam ser declarados. "
"Assim como variáveis locais, eles passam a existir na primeira vez em que é "
"feita uma atribuição. Por exemplo, se ``x`` é uma instância da :class:"
"`MinhaClasse` criada acima, o próximo trecho de código irá exibir o valor "
"``16``, sem deixar nenhum rastro na instância (por causa do uso de :keyword:"
"`del`)::"

#: ../../tutorial/classes.rst:281
msgid ""
"The other kind of instance attribute reference is a *method*. A method is a "
"function that \"belongs to\" an object.  (In Python, the term method is not "
"unique to class instances: other object types can have methods as well.  For "
"example, list objects have methods called append, insert, remove, sort, and "
"so on. However, in the following discussion, we'll use the term method "
"exclusively to mean methods of class instance objects, unless explicitly "
"stated otherwise.)"
msgstr ""
"O outro tipo de referências a atributos são métodos. Um método é uma função "
"que \"pertence\" a uma instância. (Em Python, o termo método não é aplicado "
"exclusivamente a instâncias de classes definidas pelo usuário: outros tipos "
"de objetos também podem ter métodos. Por exemplo, listas possuem os métodos "
"append, insert, remove, sort, etc. Porém, na discussão a seguir usaremos o "
"termo método apenas para se referir a métodos de classes definidas pelo "
"usuário. Seremos explícitos ao falar de outros métodos.)"

#: ../../tutorial/classes.rst:290
msgid ""
"Valid method names of an instance object depend on its class.  By "
"definition, all attributes of a class that are function  objects define "
"corresponding methods of its instances.  So in our example, ``x.f`` is a "
"valid method reference, since ``MyClass.f`` is a function, but ``x.i`` is "
"not, since ``MyClass.i`` is not.  But ``x.f`` is not the same thing as "
"``MyClass.f`` --- it is a *method object*, not a function object."
msgstr ""
"Nomes de métodos válidos de uma instância dependem de sua classe. Por "
"definição, cada atributo de uma classe que é uma função corresponde a um "
"método das instâncias. Em nosso exemplo, ``x.f`` é uma referência de método "
"válida já que ``MinhaClasse.f`` é uma função, enquanto ``x.i`` não é, já que "
"``MinhaClasse.i`` não é uma função. Entretanto, ``x.f`` não é o mesmo que "
"``MinhaClasse.f``. A referência ``x.f`` acessa um objeto método (*method "
"object*), e a ``MinhaClasse.f`` acessa um objeto função."

#: ../../tutorial/classes.rst:301
msgid "Method Objects"
msgstr "Objetos Métodos"

#: ../../tutorial/classes.rst:303
msgid "Usually, a method is called right after it is bound::"
msgstr "Normalmente, um método é invocado imediatamente após ser acessado::"

#: ../../tutorial/classes.rst:307
msgid ""
"In the :class:`MyClass` example, this will return the string ``'hello "
"world'``. However, it is not necessary to call a method right away: ``x.f`` "
"is a method object, and can be stored away and called at a later time.  For "
"example::"
msgstr ""
"No exemplo :class:`MinhaClasse` o resultado da expressão acima será a string "
"``'olá, mundo'``. No entanto, não é obrigatório invocar o método "
"imediatamente: como ``x.f`` é também um objeto (um objeto método), ele pode "
"atribuído a uma variável invocado depois. Por exemplo:"

#: ../../tutorial/classes.rst:315
msgid "will continue to print ``hello world`` until the end of time."
msgstr "esse código exibirá o texto ``'olá, mundo'`` até o mundo acabar."

#: ../../tutorial/classes.rst:317
msgid ""
"What exactly happens when a method is called?  You may have noticed that ``x."
"f()`` was called without an argument above, even though the function "
"definition for :meth:`f` specified an argument.  What happened to the "
"argument? Surely Python raises an exception when a function that requires an "
"argument is called without any --- even if the argument isn't actually "
"used..."
msgstr ""
"O que ocorre precisamente quando um método é invocado? Você deve ter notado "
"que ``x.f()`` foi chamado sem nenhum parâmetro, porém a definição da função :"
"meth:`f` especificava um parâmetro. O que aconteceu com esse parâmetro? "
"Certamente Python levanta uma exceção quando uma função que declara um "
"parâmetro é invocada sem nenhum argumento --- mesmo que o argumento não seja "
"usado no corpo da função..."

#: ../../tutorial/classes.rst:323
msgid ""
"Actually, you may have guessed the answer: the special thing about methods "
"is that the object is passed as the first argument of the function.  In our "
"example, the call ``x.f()`` is exactly equivalent to ``MyClass.f(x)``.  In "
"general, calling a method with a list of *n* arguments is equivalent to "
"calling the corresponding function with an argument list that is created by "
"inserting the method's object before the first argument."
msgstr ""
"Talvez você já tenha adivinhado a resposta: o que os métodos têm de especial "
"é que eles passam o objeto (ao qual o método está vinculado) como primeiro "
"argumento da função definida na classe. No nosso exemplo, a chamada ``x."
"f()`` equivale exatamente ``MinhaClasse.f(x)``. Em geral, chamar um método "
"com uma lista de *n* argumentos é equivalente a chamar a função na classe "
"correspondente passando a instância como o primeiro argumento antes dos "
"demais *n* argumentos."

#: ../../tutorial/classes.rst:330
msgid ""
"If you still don't understand how methods work, a look at the implementation "
"can perhaps clarify matters.  When a non-data attribute of an instance is "
"referenced, the instance's class is searched.  If the name denotes a valid "
"class attribute that is a function object, a method object is created by "
"packing (pointers to) the instance object and the function object just found "
"together in an abstract object: this is the method object.  When the method "
"object is called with an argument list, a new argument list is constructed "
"from the instance object and the argument list, and the function object is "
"called with this new argument list."
msgstr ""
"Se você ainda não entende como os métodos funcionam, dê uma olhada na "
"implementação para  esclarecer as coisas. Quando um atributo de uma "
"instância, não relacionado a dados,  é referenciado, a classe da instância é "
"pesquisada. Se o nome é um atributo de classe válido,  e é o nome de uma "
"função, um método é criado, empacotando a instância e a função, que estão "
"juntos num objeto abstrato: este é o método. Quando o método é chamado com "
"uma lista de argumentos, uma nova lista de argumentos é construída a partir "
"da instância e da lista de argumentos, e a função é chamada com essa nova "
"lista de argumentos."

#: ../../tutorial/classes.rst:344
msgid "Class and Instance Variables"
msgstr "Variáveis de Classe e Instância"

#: ../../tutorial/classes.rst:346
msgid ""
"Generally speaking, instance variables are for data unique to each instance "
"and class variables are for attributes and methods shared by all instances "
"of the class::"
msgstr ""
"De forma geral, variáveis de instância são as variáveis que indicam dados "
"que são únicos a cada instância, em nível individual, e variáveis de classe "
"são as variáveis de atributos e de métodos que são comuns a todas as "
"instâncias de uma determinada classe::"

#: ../../tutorial/classes.rst:368
msgid ""
"As discussed in :ref:`tut-object`, shared data can have possibly surprising "
"effects with involving :term:`mutable` objects such as lists and "
"dictionaries. For example, the *tricks* list in the following code should "
"not be used as a class variable because just a single list would be shared "
"by all *Dog* instances::"
msgstr ""
"Conforme discutido em :ref:`tut-object`, o compartilhamento de dados pode "
"implicar em efeitos inesperados quando envolve objetos mutáveis (em inglês: :"
"term:`mutable` objects), tais como as listas ou dicionários. Por exemplo, a "
"lista *tricks* no código a seguir não deveria ser usada como uma variável de "
"classe, pois assim apenas uma única lista seria comum a toda e qualquer "
"instância de *Dog*::"

#: ../../tutorial/classes.rst:391
msgid "Correct design of the class should use an instance variable instead::"
msgstr ""
"O design correto da classe deve usar uma variável de instância em ao invés "
"disso aqui::"

#: ../../tutorial/classes.rst:415
msgid "Random Remarks"
msgstr "Observações Aleatórias"

#: ../../tutorial/classes.rst:419
msgid ""
"Data attributes override method attributes with the same name; to avoid "
"accidental name conflicts, which may cause hard-to-find bugs in large "
"programs, it is wise to use some kind of convention that minimizes the "
"chance of conflicts.  Possible conventions include capitalizing method "
"names, prefixing data attribute names with a small unique string (perhaps "
"just an underscore), or using verbs for methods and nouns for data "
"attributes."
msgstr ""
"Atributos de dados sobrescrevem atributos métodos homônimos. Para evitar "
"conflitos de nome acidentais, que podem gerar bugs de difícil rastreio em "
"programas extensos, é sábio adotar algum tipo de convenção que minimize a "
"chance de conflitos. Convenções comuns incluem: definir nomes de métodos com "
"inicial maiúscula, prefixar atributos de dados com uma string única (quem "
"sabe \"_\" [*underscore* ou sublinhado]), ou usar sempre verbos para nomear "
"métodos e substantivos para atributos de dados. "

#: ../../tutorial/classes.rst:426
msgid ""
"Data attributes may be referenced by methods as well as by ordinary users "
"(\"clients\") of an object.  In other words, classes are not usable to "
"implement pure abstract data types.  In fact, nothing in Python makes it "
"possible to enforce data hiding --- it is all based upon convention.  (On "
"the other hand, the Python implementation, written in C, can completely hide "
"implementation details and control access to an object if necessary; this "
"can be used by extensions to Python written in C.)"
msgstr ""
"Atributos de dados podem ser referenciados por métodos da própria instância, "
"bem como por qualquer outro usuário do objeto (também chamados \"clientes\" "
"do objeto). Em outras palavras, classes não servem para implementar tipos "
"puramente abstratos de dados. De fato, nada em Python torna possível "
"assegurar o encapsulamento de dados --- tudo é convenção. (Por outro lado, a "
"implementação de Python, escrita em C, pode esconder completamente detalhes "
"de um objeto ou controlar seu acesso, se necessário; isto pode ser utilizado "
"por extensões de Python escritas em C.)"

#: ../../tutorial/classes.rst:434
msgid ""
"Clients should use data attributes with care --- clients may mess up "
"invariants maintained by the methods by stamping on their data attributes.  "
"Note that clients may add data attributes of their own to an instance object "
"without affecting the validity of the methods, as long as name conflicts are "
"avoided --- again, a naming convention can save a lot of headaches here."
msgstr ""
"Clientes devem utilizar atributos de dados com cuidado, pois podem bagunçar "
"invariantes assumidas pelos métodos ao esbarrar em seus atributos de dados. "
"Note que clientes podem adicionar à vontade atributos de dados a uma "
"instância sem afetar a validade dos métodos, desde que seja evitado o "
"conflito de nomes. Novamente, uma convenção de nomenclatura poupa muita dor "
"de cabeça."

#: ../../tutorial/classes.rst:440
msgid ""
"There is no shorthand for referencing data attributes (or other methods!) "
"from within methods.  I find that this actually increases the readability of "
"methods: there is no chance of confusing local variables and instance "
"variables when glancing through a method."
msgstr ""
"Não existe atalho para referenciar atributos de dados (ou outros métodos!) "
"de dentro de um método: sempre é preciso fazer referência explícita ao "
"``self.`` para acessar qualquer atributo da instância. Em minha opinião isso "
"aumenta a legibilidade dos métodos: não há como confundir uma variável local "
"com um atributo da instância quando lemos rapidamente um método desconhecido."

#: ../../tutorial/classes.rst:445
msgid ""
"Often, the first argument of a method is called ``self``.  This is nothing "
"more than a convention: the name ``self`` has absolutely no special meaning "
"to Python.  Note, however, that by not following the convention your code "
"may be less readable to other Python programmers, and it is also conceivable "
"that a *class browser* program might be written that relies upon such a "
"convention."
msgstr ""
"Frequentemente, o primeiro argumento de um método é chamado ``self``. Isso "
"não\n"
"passa de uma convenção: o identificador ``self`` não é uma palavra "
"reservada\n"
"nem possui qualquer significado especial em Python. Mas note que, ao seguir\n"
"essa convenção, seu código se torna legível por uma grande comunidade de\n"
"desenvolvedores Python e é possível que alguma *IDE* dependa dessa "
"convenção\n"
"para analisar seu código."

#: ../../tutorial/classes.rst:451
msgid ""
"Any function object that is a class attribute defines a method for instances "
"of that class.  It is not necessary that the function definition is "
"textually enclosed in the class definition: assigning a function object to a "
"local variable in the class is also ok.  For example::"
msgstr ""
"Qualquer objeto função que é atributo de uma classe, define um método para "
"as instâncias desta classe. Não é necessário que a definição da função "
"esteja textualmente embutida na definição da classe. Atribuir um objeto "
"função a uma variável local da classe é válido. Por exemplo::"

#: ../../tutorial/classes.rst:468
msgid ""
"Now ``f``, ``g`` and ``h`` are all attributes of class :class:`C` that refer "
"to function objects, and consequently they are all methods of instances of :"
"class:`C` --- ``h`` being exactly equivalent to ``g``.  Note that this "
"practice usually only serves to confuse the reader of a program."
msgstr ""
"Agora ``f``, ``g`` e ``h`` são todos atributos da classe :class:`C` que "
"referenciam funções, e consequentemente são todos métodos de instâncias da "
"classe :class:`C`, onde ``h`` é equivalente a ``g``. No entanto, essa "
"prática serve apenas para confundir o leitor do programa."

#: ../../tutorial/classes.rst:473
msgid ""
"Methods may call other methods by using method attributes of the ``self`` "
"argument::"
msgstr ""
"Métodos podem chamar outros métodos como atributos do argumento ``self``::"

#: ../../tutorial/classes.rst:487
msgid ""
"Methods may reference global names in the same way as ordinary functions.  "
"The global scope associated with a method is the module containing its "
"definition.  (A class is never used as a global scope.)  While one rarely "
"encounters a good reason for using global data in a method, there are many "
"legitimate uses of the global scope: for one thing, functions and modules "
"imported into the global scope can be used by methods, as well as functions "
"and classes defined in it.  Usually, the class containing the method is "
"itself defined in this global scope, and in the next section we'll find some "
"good reasons why a method would want to reference its own class."
msgstr ""
"Métodos podem referenciar nomes globais da mesma forma que funções comuns. O "
"escopo global associado a um método é o módulo contendo sua a definição de "
"sua classe (a classe propriamente dita nunca é usada como escopo global!). "
"Ainda que seja raro justificar o uso de dados globais em um método, há "
"diversos usos legítimos do escopo global. Por exemplo, funções e módulos "
"importados no escopo global podem ser usados por métodos, bem como as "
"funções e classes definidas no próprio escopo global. Provavelmente, a "
"classe contendo o método em questão também foi definida neste escopo global. "
"Na próxima seção veremos razões pelas quais um método pode querer "
"referenciar sua própria classe."

#: ../../tutorial/classes.rst:497
msgid ""
"Each value is an object, and therefore has a *class* (also called its "
"*type*). It is stored as ``object.__class__``."
msgstr ""
"Todo valor em Python é um objeto, e portanto tem uma *classe* (também "
"conhecida como seu tipo, ou *type*). A classe de um objeto pode ser "
"referenciada como ``objeto.__class__``."

#: ../../tutorial/classes.rst:504
msgid "Inheritance"
msgstr "Herança"

#: ../../tutorial/classes.rst:506
msgid ""
"Of course, a language feature would not be worthy of the name \"class\" "
"without supporting inheritance.  The syntax for a derived class definition "
"looks like this::"
msgstr ""
"Obviamente, uma característica não seria digna do nome \"classe\" se não "
"suportasse herança. A sintaxe para uma classe derivada é assim::"

#: ../../tutorial/classes.rst:517
msgid ""
"The name :class:`BaseClassName` must be defined in a scope containing the "
"derived class definition.  In place of a base class name, other arbitrary "
"expressions are also allowed.  This can be useful, for example, when the "
"base class is defined in another module::"
msgstr ""
"O identificador :class:`NomeClasseBase` deve estar definido no escopo que "
"contém a definição da classe derivada. No lugar do nome da classe base, "
"também são aceitas outras expressões. Isso é muito útil, por exemplo, quando "
"a classe base é definida em outro módulo::"

#: ../../tutorial/classes.rst:524
msgid ""
"Execution of a derived class definition proceeds the same as for a base "
"class. When the class object is constructed, the base class is remembered.  "
"This is used for resolving attribute references: if a requested attribute is "
"not found in the class, the search proceeds to look in the base class.  This "
"rule is applied recursively if the base class itself is derived from some "
"other class."
msgstr ""
"A execução de uma definição de classe derivada procede da mesma forma que a "
"de uma classe base. Quando o objeto classe é construído, a classe base é "
"lembrada. Isso é utilizado para resolver referências a atributos. Se um "
"atributo requisitado não for encontrado na classe, ele é procurado na classe "
"base. Essa regra é aplicada recursivamente se a classe base por sua vez for "
"derivada de outra."

#: ../../tutorial/classes.rst:530
msgid ""
"There's nothing special about instantiation of derived classes: "
"``DerivedClassName()`` creates a new instance of the class.  Method "
"references are resolved as follows: the corresponding class attribute is "
"searched, descending down the chain of base classes if necessary, and the "
"method reference is valid if this yields a function object."
msgstr ""
"Não há nada de especial sobre instanciação de classes derivadas. "
"``NomeClasseDerivada()`` cria uma nova instância da classe. Referências a "
"métodos são resolvidas da seguinte forma: o atributo correspondente é "
"procurado através da cadeia de classes base, e referências a métodos são "
"válidas desde se essa procura produza um objeto função."

#: ../../tutorial/classes.rst:536
msgid ""
"Derived classes may override methods of their base classes.  Because methods "
"have no special privileges when calling other methods of the same object, a "
"method of a base class that calls another method defined in the same base "
"class may end up calling a method of a derived class that overrides it.  "
"(For C++ programmers: all methods in Python are effectively ``virtual``.)"
msgstr ""
"Classes derivadas podem sobrescrever métodos das suas classes base. Uma vez "
"que métodos não possuem privilégios especiais quando invocam outros métodos "
"no mesmo objeto, um método na classe base que invocava um outro método da "
"mesma classe base, pode efetivamente acabar invocando um método sobreposto "
"por uma classe derivada. (Para programadores C++ isso significa que todos os "
"métodos em Python são realmente virtuais.)"

#: ../../tutorial/classes.rst:542
msgid ""
"An overriding method in a derived class may in fact want to extend rather "
"than simply replace the base class method of the same name. There is a "
"simple way to call the base class method directly: just call ``BaseClassName."
"methodname(self, arguments)``.  This is occasionally useful to clients as "
"well.  (Note that this only works if the base class is accessible as "
"``BaseClassName`` in the global scope.)"
msgstr ""
"Um método sobrescrito em uma classe derivada, de fato, pode querer estender "
"em vez de simplesmente substituir o método da classe base, de mesmo nome. "
"Existe uma maneira simples de chamar diretamente o método da classe base: "
"apenas chame `` BaseClassName.methodname (self, arguments) ``. Isso é "
"geralmente útil para os clientes também. (Note que isto só funciona se a "
"classe base estiver acessível como `` BaseClassName`` no escopo global)."

#: ../../tutorial/classes.rst:549
msgid "Python has two built-in functions that work with inheritance:"
msgstr "Python tem duas funções embutidas que trabalham com herança:"

#: ../../tutorial/classes.rst:551
msgid ""
"Use :func:`isinstance` to check an instance's type: ``isinstance(obj, int)`` "
"will be ``True`` only if ``obj.__class__`` is :class:`int` or some class "
"derived from :class:`int`."
msgstr ""
"* Use :func:`isinstance` para verificar o tipo de uma instância:\n"
" ``isinstance(obj, int)`` será ``True`` somente se ``obj.__class__`` é\n"
" a classe :class:`int` ou alguma classe derivada de :class:`int`."

#: ../../tutorial/classes.rst:555
msgid ""
"Use :func:`issubclass` to check class inheritance: ``issubclass(bool, int)`` "
"is ``True`` since :class:`bool` is a subclass of :class:`int`.  However, "
"``issubclass(unicode, str)`` is ``False`` since :class:`unicode` is not a "
"subclass of :class:`str` (they only share a common ancestor, :class:"
"`basestring`)."
msgstr ""

#: ../../tutorial/classes.rst:566
msgid "Multiple Inheritance"
msgstr "Herança Múltipla"

#: ../../tutorial/classes.rst:568
msgid ""
"Python supports a limited form of multiple inheritance as well.  A class "
"definition with multiple base classes looks like this::"
msgstr ""
"Python também suporta uma forma limitada de herança múltipla. Uma definição "
"de classe com várias classes base tem esta forma::"

#: ../../tutorial/classes.rst:578
msgid ""
"For old-style classes, the only rule is depth-first, left-to-right.  Thus, "
"if an attribute is not found in :class:`DerivedClassName`, it is searched "
"in :class:`Base1`, then (recursively) in the base classes of :class:`Base1`, "
"and only if it is not found there, it is searched in :class:`Base2`, and so "
"on."
msgstr ""

#: ../../tutorial/classes.rst:583
msgid ""
"(To some people breadth first --- searching :class:`Base2` and :class:"
"`Base3` before the base classes of :class:`Base1` --- looks more natural.  "
"However, this would require you to know whether a particular attribute of :"
"class:`Base1` is actually defined in :class:`Base1` or in one of its base "
"classes before you can figure out the consequences of a name conflict with "
"an attribute of :class:`Base2`.  The depth-first rule makes no differences "
"between direct and inherited attributes of :class:`Base1`.)"
msgstr ""

#: ../../tutorial/classes.rst:591
msgid ""
"For :term:`new-style class`\\es, the method resolution order changes "
"dynamically to support cooperative calls to :func:`super`.  This approach is "
"known in some other multiple-inheritance languages as call-next-method and "
"is more powerful than the super call found in single-inheritance languages."
msgstr ""

#: ../../tutorial/classes.rst:596
msgid ""
"With new-style classes, dynamic ordering is necessary because all  cases of "
"multiple inheritance exhibit one or more diamond relationships (where at "
"least one of the parent classes can be accessed through multiple paths from "
"the bottommost class).  For example, all new-style classes inherit from :"
"class:`object`, so any case of multiple inheritance provides more than one "
"path to reach :class:`object`.  To keep the base classes from being accessed "
"more than once, the dynamic algorithm linearizes the search order in a way "
"that preserves the left-to-right ordering specified in each class, that "
"calls each parent only once, and that is monotonic (meaning that a class can "
"be subclassed without affecting the precedence order of its parents).  Taken "
"together, these properties make it possible to design reliable and "
"extensible classes with multiple inheritance.  For more detail, see https://"
"www.python.org/download/releases/2.3/mro/."
msgstr ""

#: ../../tutorial/classes.rst:614
msgid "Private Variables and Class-local References"
msgstr ""

#: ../../tutorial/classes.rst:616
msgid ""
"\"Private\" instance variables that cannot be accessed except from inside an "
"object don't exist in Python.  However, there is a convention that is "
"followed by most Python code: a name prefixed with an underscore (e.g. "
"``_spam``) should be treated as a non-public part of the API (whether it is "
"a function, a method or a data member).  It should be considered an "
"implementation detail and subject to change without notice."
msgstr ""
"Variáveis instância \"privadas\", que não podem ser acessados ​​exceto em "
"métodos do próprio objeto não existem em Python. No entanto, existe uma "
"convenção que é seguida pela maioria dos programas em Python: um nome "
"prefixado com um sublinhado (por exemplo: ``_spam`` ) deve ser tratado como "
"uma parte não-pública da API (seja ele uma função, um método ou um atributo "
"de dados). Tais nomes devem ser considerados um detalhe de implementação e "
"sujeito a alteração sem aviso prévio."

#: ../../tutorial/classes.rst:626
msgid ""
"Since there is a valid use-case for class-private members (namely to avoid "
"name clashes of names with names defined by subclasses), there is limited "
"support for such a mechanism, called :dfn:`name mangling`.  Any identifier "
"of the form ``__spam`` (at least two leading underscores, at most one "
"trailing underscore) is textually replaced with ``_classname__spam``, where "
"``classname`` is the current class name with leading underscore(s) "
"stripped.  This mangling is done without regard to the syntactic position of "
"the identifier, as long as it occurs within the definition of a class."
msgstr ""
"Uma vez que existe um caso de uso válido para a definição de atributos "
"privados em classes (especificamente para evitar conflitos com nomes "
"definidos em subclasses), existe um suporte limitado a identificadores "
"privados em classes, chamado :dfn:`name mangling` (literalmente: "
"desfiguração de nomes). Qualquer identificador no formato ``__spam`` (no "
"mínimo dois underscores ``_`` no prefixo e no máximo um sufixo) é "
"substituído por ``_nomeclasse__spam``, onde ``nomeclasse`` é o nome da "
"classe corrente (exceto quando o nome da classe é prefixado com um ou mais "
"underscores ``_``; nesse caso eles são omitidos). Essa desfiguração "
"independe da posição sintática do identificador, desde que ele apareça "
"dentro da definição de uma classe."

#: ../../tutorial/classes.rst:635
msgid ""
"Name mangling is helpful for letting subclasses override methods without "
"breaking intraclass method calls.  For example::"
msgstr ""
"A desfiguração de nomes é útil para que subclasses possam sobrescrever "
"métodos sem quebrar invocações de métodos dentro de outra classe. Por "
"exemplo::"

#: ../../tutorial/classes.rst:657
msgid ""
"The above example would work even if ``MappingSubclass`` were to introduce a "
"``__update`` identifier since it is replaced with ``_Mapping__update`` in "
"the ``Mapping`` class  and ``_MappingSubclass__update`` in the "
"``MappingSubclass`` class respectively."
msgstr ""
"O exemplo acima deve funcionar mesmo que ``MappingSubclass`` introduzisse um "
"identificador  ``__update`` uma vez que é substituído por "
"``_Mapping__update`` na classe ``Mapping`` e ``_MappingSubclass__update`` na "
"classe ``MappingSubclass``, respectivamente."

#: ../../tutorial/classes.rst:662
msgid ""
"Note that the mangling rules are designed mostly to avoid accidents; it "
"still is possible to access or modify a variable that is considered "
"private.  This can even be useful in special circumstances, such as in the "
"debugger."
msgstr ""
"Note que as regras de desfiguração de nomes foram projetadas para evitar "
"acidentes; ainda é possível acessar e alterar intencionalmente variáveis "
"protegidas por esse mecanismo. De fato isso pode ser útil em certas "
"circunstâncias, por exemplo, durante uma sessão com o :mod:`pdb`, o "
"depurador interativo do Python."

#: ../../tutorial/classes.rst:666
msgid ""
"Notice that code passed to ``exec``, ``eval()`` or ``execfile()`` does not "
"consider the classname of the invoking  class to be the current class; this "
"is similar to the effect of the  ``global`` statement, the effect of which "
"is likewise restricted to  code that is byte-compiled together.  The same "
"restriction applies to ``getattr()``, ``setattr()`` and ``delattr()``, as "
"well as when referencing ``__dict__`` directly."
msgstr ""
"Código passado para ``exec``, ``eval()`` ou ``execfile()`` não considera o "
"nome da classe que invocou como sendo a classe corrente; isso é semelhante "
"ao funcionamento da declaração :keyword:`global`, cujo efeito se aplica "
"somente ao código que é byte-compilado junto. A mesma restrição se aplica as "
"funções ``getattr()``, ``setattr()`` e ``delattr()``, e quando acessamos "
"diretamente o ``__dict__`` da classe: lá as chaves já estão desfiguradas."

#: ../../tutorial/classes.rst:677
msgid "Odds and Ends"
msgstr "Odds e Ends"

#: ../../tutorial/classes.rst:679
msgid ""
"Sometimes it is useful to have a data type similar to the Pascal \"record\" "
"or C \"struct\", bundling together a few named data items.  An empty class "
"definition will do nicely::"
msgstr ""
"Às vezes, é útil ter um tipo semelhante ao \"record\" de Pascal ou ao "
"\"struct\" de C, para agrupar alguns itens de dados. Uma definição de classe "
"vazia funciona bem para este fim::"

#: ../../tutorial/classes.rst:693
msgid ""
"A piece of Python code that expects a particular abstract data type can "
"often be passed a class that emulates the methods of that data type "
"instead.  For instance, if you have a function that formats some data from a "
"file object, you can define a class with methods :meth:`read` and :meth:`!"
"readline` that get the data from a string buffer instead, and pass it as an "
"argument."
msgstr ""
"Um trecho de código Python que espera um tipo abstrato de dado em "
"particular, pode receber, ao invés disso, um objeto que emula os métodos que "
"aquele tipo suporta. Por exemplo, se você tem uma função que formata dados "
"obtidos de um objeto arquivo, pode passar como argumento para essa função "
"uma instância de uma classe que implemente os métodos :meth:`read` e :meth:"
"`readline` que obtém os dados lendo um buffer ao invés de ler um arquivo "
"real. (N.d.T. isso é um exemplo de \"duck typing\" [#]_\\ .)"

#: ../../tutorial/classes.rst:704
msgid ""
"Instance method objects have attributes, too: ``m.im_self`` is the instance "
"object with the method :meth:`m`, and ``m.im_func`` is the function object "
"corresponding to the method."
msgstr ""
"Objetos método têm seus próprios atributos: ``m.im_self`` é uma referência à "
"instância vinculada ao método :meth:`m`, e ``m.im_func`` é o objeto função "
"(atributo da classe) que corresponde ao método."

#: ../../tutorial/classes.rst:712
msgid "Exceptions Are Classes Too"
msgstr "Exceções também são classes"

#: ../../tutorial/classes.rst:714
msgid ""
"User-defined exceptions are identified by classes as well.  Using this "
"mechanism it is possible to create extensible hierarchies of exceptions."
msgstr ""
"Exceções definidas pelo usuário são identificadas por classes. Através deste "
"mecanismo é possível criar hierarquias extensíveis de exceções."

#: ../../tutorial/classes.rst:717
msgid ""
"There are two new valid (semantic) forms for the :keyword:`raise` statement::"
msgstr ""
"Há duas novas formas semanticamente válidas para o comando :keyword:`raise`::"

#: ../../tutorial/classes.rst:723
msgid ""
"In the first form, ``instance`` must be an instance of :class:`Class` or of "
"a class derived from it.  The second form is a shorthand for::"
msgstr ""
"Na primeira forma, ``instancia`` deve ser uma instância de :class:`Classe` "
"ou de uma classe derivada dela. A segunda forma é um atalho para::"

#: ../../tutorial/classes.rst:728
msgid ""
"A class in an :keyword:`except` clause is compatible with an exception if it "
"is the same class or a base class thereof (but not the other way around --- "
"an except clause listing a derived class is not compatible with a base "
"class).  For example, the following code will print B, C, D in that order::"
msgstr ""
"Em uma cláusula :keyword:`except`, uma classe é compatível com a exceção "
"levantada se é a mesma classe ou uma classe ancestral dela (mas não o "
"contrário: uma cláusula :keyword:`except` que menciona uma classe derivada "
"daquela que foi levantada não vai capturar tal exceção). No exemplo a seguir "
"será exibido B, C e D nessa ordem::"

#: ../../tutorial/classes.rst:750
msgid ""
"Note that if the except clauses were reversed (with ``except B`` first), it "
"would have printed B, B, B --- the first matching except clause is triggered."
msgstr ""
"Se a ordem das cláusulas fosse invertida (``except B`` no início), seria "
"exibido B, B, B --- somente a primeira cláusula :keyword:`except` compatível "
"é ativada."

#: ../../tutorial/classes.rst:753
msgid ""
"When an error message is printed for an unhandled exception, the exception's "
"class name is printed, then a colon and a space, and finally the instance "
"converted to a string using the built-in function :func:`str`."
msgstr ""
"No caso de uma exceção não tratada, quando a mensagem de erro é gerada, o "
"nome da classe da exceção é exibido, seguido de ``': '`` (dois pontos e um "
"espaço), e finalmente aparece a instância da exceção convertida para string "
"através da função embutida :func:`str`."

#: ../../tutorial/classes.rst:761
msgid "Iterators"
msgstr "Iteradores"

#: ../../tutorial/classes.rst:763
msgid ""
"By now you have probably noticed that most container objects can be looped "
"over using a :keyword:`for` statement::"
msgstr ""
"Você já deve ter notado que pode usar laços :keyword:`for` com a maioria das "
"coleções em Python::"

#: ../../tutorial/classes.rst:777
msgid ""
"This style of access is clear, concise, and convenient.  The use of "
"iterators pervades and unifies Python.  Behind the scenes, the :keyword:"
"`for` statement calls :func:`iter` on the container object.  The function "
"returns an iterator object that defines the method :meth:`~iterator.next` "
"which accesses elements in the container one at a time.  When there are no "
"more elements, :meth:`~iterator.next` raises a :exc:`StopIteration` "
"exception which tells the :keyword:`for` loop to terminate. This example "
"shows how it all works::"
msgstr ""
"Esse estilo de acesso é limpo, conciso e conveniente. O uso de iteradores "
"promove uma unificação ao longo de toda a linguagem. Nos bastidores, o "
"comando :keyword:`for` aplica a função embutida :func:`iter` à coleção. Essa "
"função devolve um iterador que define o método :meth:`next`, que acessa os "
"elementos da coleção em sequência, um por vez. Quando acabam os elementos, :"
"meth:`next` levanta uma exceção :exc:`StopIteration`, indicando que o laço :"
"keyword:`for` deve encerrar. Este exemplo mostra como tudo funciona::"

#: ../../tutorial/classes.rst:802
msgid ""
"Having seen the mechanics behind the iterator protocol, it is easy to add "
"iterator behavior to your classes.  Define an :meth:`__iter__` method which "
"returns an object with a :meth:`~iterator.next` method.  If the class "
"defines :meth:`~iterator.next`, then :meth:`__iter__` can just return "
"``self``::"
msgstr ""
"Observando o mecanismo por trás do protocolo dos iteradores, fica fácil "
"adicionar esse comportamento às suas classes. Defina uma método :meth:"
"`__iter__` que devolve um objeto que tenha um método :meth:`next`. Se uma "
"classe já define :meth:`next`, então :meth:`__iter__` pode simplesmente "
"devolver ``self``::"

#: ../../tutorial/classes.rst:839
msgid "Generators"
msgstr "Geradores"

#: ../../tutorial/classes.rst:841
msgid ""
":term:`Generator`\\s are a simple and powerful tool for creating iterators.  "
"They are written like regular functions but use the :keyword:`yield` "
"statement whenever they want to return data.  Each time :func:`next` is "
"called on it, the generator resumes where it left off (it remembers all the "
"data values and which statement was last executed).  An example shows that "
"generators can be trivially easy to create::"
msgstr ""
"Funções geradoras (:term:`generator <generator>`) são uma maneira fácil e "
"poderosa de criar um iterador. Uma função geradora é escrita como uma função "
"normal, mas usa o comando :keyword:`yield` para produzir resultados. (N.d.T. "
"Quando invocada, a função geradora produz um objeto gerador.) Cada vez que :"
"meth:`next` é invocado, o gerador continua a partir de onde parou (ele "
"mantem na memória seus dados internos e a próxima instrução a ser "
"executada). Um exemplo mostra como geradores podem ser muito fáceis de "
"criar::"

#: ../../tutorial/classes.rst:862
msgid ""
"Anything that can be done with generators can also be done with class-based "
"iterators as described in the previous section.  What makes generators so "
"compact is that the :meth:`__iter__` and :meth:`~generator.next` methods are "
"created automatically."
msgstr ""
"Qualquer coisa feita com geradores também pode ser feita com iteradores "
"baseados numa classe, como descrito na seção anterior. O que torna geradores "
"tão compactos é que os métodos :meth:`__iter__` e :meth:`next` são criados "
"automaticamente."

#: ../../tutorial/classes.rst:867
msgid ""
"Another key feature is that the local variables and execution state are "
"automatically saved between calls.  This made the function easier to write "
"and much more clear than an approach using instance variables like ``self."
"index`` and ``self.data``."
msgstr ""
"Outro ponto chave é que as variáveis locais e o estado da execução são "
"preservados automaticamente entre as chamadas de :meth:`next`. Isto torna a "
"função mais fácil de escrever e muito mais clara do que uma implementação "
"usando variáveis de instância como ``self.index`` e ``self.data``."

#: ../../tutorial/classes.rst:872
msgid ""
"In addition to automatic method creation and saving program state, when "
"generators terminate, they automatically raise :exc:`StopIteration`. In "
"combination, these features make it easy to create iterators with no more "
"effort than writing a regular function."
msgstr ""
"Além disso, quando geradores terminam, eles levantam :exc:`StopIteration` "
"automaticamente. Combinados, todos estes aspectos tornam a criação de "
"iteradores tão fácil quanto escrever uma função normal."

#: ../../tutorial/classes.rst:881
msgid "Generator Expressions"
msgstr "Expressões Geradoras"

#: ../../tutorial/classes.rst:883
msgid ""
"Some simple generators can be coded succinctly as expressions using a syntax "
"similar to list comprehensions but with parentheses instead of square "
"brackets. These expressions are designed for situations where the generator "
"is used right away by an enclosing function.  Generator expressions are more "
"compact but less versatile than full generator definitions and tend to be "
"more memory friendly than equivalent list comprehensions."
msgstr ""
"Alguns geradores simples podem ser codificados de forma sucinta como "
"expressões usando uma sintaxe semelhante a compreensões de lista, mas com "
"parênteses em vez de colchetes. Essas expressões são projetadas para "
"situações em que o gerador é usado imediatamente por uma função de "
"fechamento. As expressões do gerador são mais compactas, mas menos versáteis "
"do que as definições completas do gerador e tendem a ser mais amigáveis à "
"memória do que as compreensões de lista equivalentes."

#: ../../tutorial/classes.rst:890
msgid "Examples::"
msgstr "Exemplos::"

#: ../../tutorial/classes.rst:914
msgid "Footnotes"
msgstr "Notas de Rodapé"

#: ../../tutorial/classes.rst:915
msgid ""
"Except for one thing.  Module objects have a secret read-only attribute "
"called :attr:`~object.__dict__` which returns the dictionary used to "
"implement the module's namespace; the name :attr:`~object.__dict__` is an "
"attribute but not a global name. Obviously, using this violates the "
"abstraction of namespace implementation, and should be restricted to things "
"like post-mortem debuggers."
msgstr ""
"Exceto por um detalhe. Objetos módulo têm um atributo secreto apenas para  "
"leitura chamado :attr:`__dict__` que é uma referência ao dicionário usado "
"para  implementar o namespace do módulo; o nome :attr:`__dict__` é um "
"atributo mas  não um nome global. Obviamente, acessar esse atributo viola a "
"abstração da  implementação de namespaces, e é algo que só deve ser feito "
"por ferramentas  especiais, como depuradores \"post-mortem\". \n"
"\n"
".. [#] N.d.T. Os termos :term:`new-style class <new-style class>` e  \"old-"
"style class\" referem-se a duas implementações de classes que  convivem "
"desde o Python 2.2. A implementação mais antiga, \"old-style  classes\" foi "
"preservada até o Python 2.7 para manter a compatibilidade com  bibliotecas e "
"scripts antigos, mas deixou de existir a partir do Python  3.0. As \"new-"
"style classes\" suportam o mecanismo de descritores, usado para  implementar "
"propriedades (*properties*). Recomenda-se que todo código  Python novo use "
"apenas \"new-style classes\".\n"
"\n"
" Desde o Python 2.2, a forma de declarar uma classe determina se ela usa a  "
"implementação nova ou antiga. Qualquer classe derivada direta ou  "
"indiretamente de :class:`object` é uma classe \"new-style\". Objetos classe  "
"novos são do tipo ``type`` e objetos classe antigos são do tipo  "
"``classobj``. Veja este exemplo::\n"
"\n"
" >>> class Nova(object):\n"
" ... pass\n"
" ...\n"
" >>> type(Nova)\n"
" <type 'type'>\n"
" >>> class Velha:\n"
" ... pass\n"
" ...\n"
" >>> type(Velha)\n"
" <type 'classobj'>\n"
"\n"
" Note que a definição acima é recursiva. Em particular, uma classe\n"
" que herda de uma classe antiga e de uma nova é uma classe \"new-style\",\n"
" pois através da classe nova ela é uma subclasse indireta de :class:"
"`object`.\n"
" Não é uma boa prática misturar os dois estilos de classes, mas eis um\n"
" exemplo para ilustrar esse ponto::\n"
"\n"
" >>> class Mista(Velha, Nova):\n"
" ... pass\n"
" ...\n"
" >>> type(Mista)\n"
" <type 'type'>\n"
"\n"
" Para saber mais sobre as diferenças, veja `New Class vs Classic Class`_ no "
"wiki\n"
" do python.org ou artigo original de Guido van Rossum, `Unifying types and\n"
" classes in Python 2.2`_.\n"
"\n"
".. _New Class vs Classic Class: http://wiki.python.org/moin/"
"NewClassVsClassicClass\n"
".. _Unifying types and classes in Python 2.2: http://www.python.org/download/"
"releases/2.2.3/descrintro/\n"
"\n"
".. [#] N.d.T. Esse parágrafo descreve uma aplicação do conceito de \"duck\n"
" typing\" (literalmente, \"tipagem pato\"), cuja ideia central é que os\n"
" atributos e comportamentos de um objeto são mais importantes que seu tipo:\n"
" \"Quando vejo um pássaro que anda com um pato, nada como um pato, e grasna\n"
" como um pato, chamo esse pássaro de pato.\" (James Whitcomb Riley). "
"Segundo\n"
" a Wikipedia_ (em inglês), a metáfora dos atributos de um pato no contexto\n"
" de programação orientada a objetos foi usada pela primeira vez por\n"
" Alex Martelli no grupo *comp.lang.python* em 26/jul/2000. O assunto da\n"
" mensagem era polymorphism_.\n"
"\n"
".. _Wikipedia: http://en.wikipedia.org/wiki/Duck_typing#History\n"
".. _polymorphism: http://groups.google.com/group/comp.lang.python/msg/"
"e230ca916be58835"
