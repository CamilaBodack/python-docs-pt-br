# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:46+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/python-doc/"
"python-27/language/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/floatingpoint.rst:5
msgid "Floating Point Arithmetic:  Issues and Limitations"
msgstr "Aritmética de ponto flutuante: problemas e limitações"

#: ../../tutorial/floatingpoint.rst:10
msgid ""
"Floating-point numbers are represented in computer hardware as base 2 "
"(binary) fractions.  For example, the decimal fraction ::"
msgstr ""
"Números de ponto flutuante são representados no hardware do computador como "
"frações binárias (base 2). Por exemplo, a fração decimal::"

#: ../../tutorial/floatingpoint.rst:15
msgid ""
"has value 1/10 + 2/100 + 5/1000, and in the same way the binary fraction ::"
msgstr ""
"tem o valor 1/10 + 2/100 + 5/1000, e da mesma maneira a fração binária::"

#: ../../tutorial/floatingpoint.rst:19
msgid ""
"has value 0/2 + 0/4 + 1/8.  These two fractions have identical values, the "
"only real difference being that the first is written in base 10 fractional "
"notation, and the second in base 2."
msgstr ""
"tem o valor 0/2 + 0/4 + 1/8. Essas duas frações têm valores idênticos, a "
"única\n"
"diferença real é que a primeira está representada na forma de frações base "
"10,\n"
"e a segunda na base 2."

#: ../../tutorial/floatingpoint.rst:23
msgid ""
"Unfortunately, most decimal fractions cannot be represented exactly as "
"binary fractions.  A consequence is that, in general, the decimal floating-"
"point numbers you enter are only approximated by the binary floating-point "
"numbers actually stored in the machine."
msgstr ""
"Infelizmente, muitas frações decimais não podem ser representadas "
"precisamente\n"
"como frações binárias. O resultado é que, em geral, os números decimais de\n"
"ponto flutuante que você digita acabam sendo armazenados de forma apenas\n"
"aproximada, na forma de números binários de ponto flutuante."

#: ../../tutorial/floatingpoint.rst:28
msgid ""
"The problem is easier to understand at first in base 10.  Consider the "
"fraction 1/3.  You can approximate that as a base 10 fraction::"
msgstr ""
"O problema é mais fácil de entender primeiro em base 10. Considere a fração\n"
"1/3. Podemos representá-la aproximadamente como uma fração base 10::"

#: ../../tutorial/floatingpoint.rst:33 ../../tutorial/floatingpoint.rst:37
msgid "or, better, ::"
msgstr "ou melhor, ::"

#: ../../tutorial/floatingpoint.rst:41
msgid ""
"and so on.  No matter how many digits you're willing to write down, the "
"result will never be exactly 1/3, but will be an increasingly better "
"approximation of 1/3."
msgstr ""
"e assim por diante. Não importa quantos dígitos você está disposto a "
"escrever,\n"
"o resultado nunca será exatamente 1/3, mas será uma aproximação de cada vez\n"
"melhor de 1/3."

#: ../../tutorial/floatingpoint.rst:45
msgid ""
"In the same way, no matter how many base 2 digits you're willing to use, the "
"decimal value 0.1 cannot be represented exactly as a base 2 fraction.  In "
"base 2, 1/10 is the infinitely repeating fraction ::"
msgstr ""
"Da mesma forma, não importa quantos dígitos de base 2 você está disposto a\n"
"usar, o valor decimal 0.1 não pode ser representado exatamente como uma "
"fração\n"
"de base 2. Em base 2, 1/10 é uma fração binária que se repete infinitamente::"

#: ../../tutorial/floatingpoint.rst:51
msgid "Stop at any finite number of bits, and you get an approximation."
msgstr ""
"Se limitamos a representação a qualquer número finito de bits, obtemos "
"apenas\n"
"uma aproximação."

#: ../../tutorial/floatingpoint.rst:53
msgid ""
"On a typical machine running Python, there are 53 bits of precision "
"available for a Python float, so the value stored internally when you enter "
"the decimal number ``0.1`` is the binary fraction ::"
msgstr ""
"Em uma máquina típica rodando Python, há 53 bits de precisão disponível "
"para\n"
"um ``float``, de modo que o valor armazenado internamente quando você "
"digita\n"
"o número decimal ``0.1`` é esta fração binária::"

#: ../../tutorial/floatingpoint.rst:59
msgid "which is close to, but not exactly equal to, 1/10."
msgstr "que chega perto, mas não é exatamente igual a 1/10."

#: ../../tutorial/floatingpoint.rst:61
msgid ""
"It's easy to forget that the stored value is an approximation to the "
"original decimal fraction, because of the way that floats are displayed at "
"the interpreter prompt.  Python only prints a decimal approximation to the "
"true decimal value of the binary approximation stored by the machine.  If "
"Python were to print the true decimal value of the binary approximation "
"stored for 0.1, it would have to display ::"
msgstr ""
"É fácil esquecer que o valor armazenado é uma aproximação da fração decimal\n"
"original, devido à forma como floats são exibidos no interpretador "
"interativo.\n"
"Python exibe apenas uma aproximação decimal do verdadeiro valor decimal da\n"
"aproximação binária armazenada pela máquina. Se Python exibisse o "
"verdadeiro\n"
"valor decimal da aproximação binária que representa o decimal 0.1, teria\n"
"que mostrar::"

#: ../../tutorial/floatingpoint.rst:71
msgid ""
"That is more digits than most people find useful, so Python keeps the number "
"of digits manageable by displaying a rounded value instead ::"
msgstr ""
"Isso é bem mais dígitos do que a maioria das pessoas considera útil, então "
"Python\n"
"limita o número de dígitos, apresentando em vez disso um valor arredondado::"

#: ../../tutorial/floatingpoint.rst:77
msgid ""
"It's important to realize that this is, in a real sense, an illusion: the "
"value in the machine is not exactly 1/10, you're simply rounding the "
"*display* of the true machine value.  This fact becomes apparent as soon as "
"you try to do arithmetic with these values ::"
msgstr ""
"É importante perceber que isso é, de fato, uma ilusão: o valor na máquina "
"não\n"
"é exatamente 1/10, estamos simplesmente arredondando a exibição do "
"verdadeiro\n"
"valor na máquina. Esse fato torna-se evidente logo que você tenta fazer\n"
"aritmética com estes valores::"

#: ../../tutorial/floatingpoint.rst:85
msgid ""
"Note that this is in the very nature of binary floating-point: this is not a "
"bug in Python, and it is not a bug in your code either.  You'll see the same "
"kind of thing in all languages that support your hardware's floating-point "
"arithmetic (although some languages may not *display* the difference by "
"default, or in all output modes)."
msgstr ""
"Note que esse é a própria natureza do ponto flutuante binário: não é um bug "
"em\n"
"Python, e nem é um bug em seu código. Você verá o mesmo tipo de coisa em "
"todas\n"
"as linguagens que usam as instruções de aritmética de ponto flutuante do\n"
"hardware (apesar de algumas linguagens não *mostrarem* a diferença, por\n"
"padrão, ou em todos os modos de saída)."

#: ../../tutorial/floatingpoint.rst:91
msgid ""
"Other surprises follow from this one.  For example, if you try to round the "
"value 2.675 to two decimal places, you get this ::"
msgstr ""
"Outras surpresas decorrem desse fato. Por exemplo, se tentar arredondar o\n"
"valor 2.675 para duas casas decimais, obterá esse resultado::"

#: ../../tutorial/floatingpoint.rst:97
msgid ""
"The documentation for the built-in :func:`round` function says that it "
"rounds to the nearest value, rounding ties away from zero.  Since the "
"decimal fraction 2.675 is exactly halfway between 2.67 and 2.68, you might "
"expect the result here to be (a binary approximation to) 2.68.  It's not, "
"because when the decimal string ``2.675`` is converted to a binary floating-"
"point number, it's again replaced with a binary approximation, whose exact "
"value is ::"
msgstr ""
"A documentação da função embutida :func:`round` diz que ela arredonda para "
"o\n"
"valor mais próximo, e em caso de empate opta pela aproximação mais distante "
"de\n"
"zero. Uma vez que a fração decimal 2.675 fica exatamente a meio caminho "
"entre\n"
"2.67 e 2.68, poderíamos esperar que o resultado fosse (uma aproximação "
"binária\n"
"de) 2.68. Mas não é, porque quando a string decimal ``2.675`` é convertida "
"em\n"
"um número de ponto flutuante binário, é substituída por uma aproximação\n"
"binária, cujo valor exato é::"

#: ../../tutorial/floatingpoint.rst:106
msgid ""
"Since this approximation is slightly closer to 2.67 than to 2.68, it's "
"rounded down."
msgstr ""
"Uma vez que esta aproximação é ligeiramente mais próxima de 2.67 do que de\n"
"2.68, acaba sendo arredondada para baixo."

#: ../../tutorial/floatingpoint.rst:109
msgid ""
"If you're in a situation where you care which way your decimal halfway-cases "
"are rounded, you should consider using the :mod:`decimal` module. "
"Incidentally, the :mod:`decimal` module also provides a nice way to \"see\" "
"the exact value that's stored in any particular Python float ::"
msgstr ""
"Se você estiver em uma situação onde precisa saber exatamente como esses\n"
"valores intermediários são arredondados, considere usar o módulo\n"
":mod:`decimal`. Aliás, o módulo :mod:`decimal` também oferece uma boa "
"maneira\n"
"de \"ver\" o valor exato que é armazenado em qualquer float em Python::"

#: ../../tutorial/floatingpoint.rst:118
msgid ""
"Another consequence is that since 0.1 is not exactly 1/10, summing ten "
"values of 0.1 may not yield exactly 1.0, either::"
msgstr ""
"Outra consequência é que, uma vez que 0.1 não é exatamente 1/10, somar 0.1 "
"dez\n"
"vezes também não produz exatamente 1.0::"

#: ../../tutorial/floatingpoint.rst:128
msgid ""
"Binary floating-point arithmetic holds many surprises like this.  The "
"problem with \"0.1\" is explained in precise detail below, in the "
"\"Representation Error\" section.  See `The Perils of Floating Point <http://"
"www.lahey.com/float.htm>`_ for a more complete account of other common "
"surprises."
msgstr ""
"A aritmética de ponto flutuante binário traz muitas surpresas como essas. O\n"
"problema do \"0.1\" é explicado em detalhes precisos abaixo, na seção `Erro "
"de\n"
"Representação`_. Para uma descrição mais completa de outras surpresas "
"comuns,\n"
"veja `The Perils of Floating Point <http://www.lahey.com/float.htm>`_\\ ."

#: ../../tutorial/floatingpoint.rst:133
msgid ""
"As that says near the end, \"there are no easy answers.\"  Still, don't be "
"unduly wary of floating-point!  The errors in Python float operations are "
"inherited from the floating-point hardware, and on most machines are on the "
"order of no more than 1 part in 2\\*\\*53 per operation.  That's more than "
"adequate for most tasks, but you do need to keep in mind that it's not "
"decimal arithmetic, and that every float operation can suffer a new rounding "
"error."
msgstr ""
"Apesar de que os casos patológicos existem, na maioria dos usos cotidianos "
"de\n"
"aritmética de ponto flutuante ao fim você verá o resultado esperado\n"
"simplesmente arredondando a exibição dos resultados finais para o número de\n"
"dígitos decimais que deseja. Para ter um bom controle sobre como um float é\n"
"exibido, veja os especificadores de formato do método :meth:`str.format` em\n"
":ref:`formatstrings`."

#: ../../tutorial/floatingpoint.rst:140
msgid ""
"While pathological cases do exist, for most casual use of floating-point "
"arithmetic you'll see the result you expect in the end if you simply round "
"the display of your final results to the number of decimal digits you "
"expect.  For fine control over how a float is displayed see the :meth:`str."
"format` method's format specifiers in :ref:`formatstrings`."
msgstr ""

#: ../../tutorial/floatingpoint.rst:150
msgid "Representation Error"
msgstr "Erro de representação"

#: ../../tutorial/floatingpoint.rst:152
msgid ""
"This section explains the \"0.1\" example in detail, and shows how you can "
"perform an exact analysis of cases like this yourself.  Basic familiarity "
"with binary floating-point representation is assumed."
msgstr ""
"Esta seção explica o exemplo do \"0,1\" em detalhes, e mostra como você "
"pode\n"
"realizar uma análise exata de casos semelhantes. Assumimos que você tem uma\n"
"familiaridade básica com representação binária de ponto flutuante."

#: ../../tutorial/floatingpoint.rst:156
msgid ""
":dfn:`Representation error` refers to the fact that some (most, actually) "
"decimal fractions cannot be represented exactly as binary (base 2) "
"fractions. This is the chief reason why Python (or Perl, C, C++, Java, "
"Fortran, and many others) often won't display the exact decimal number you "
"expect::"
msgstr ""
":dfn:`Erro de representação` refere-se ao fato de que algumas frações "
"decimais\n"
"(a maioria, na verdade) não podem ser representadas exatamente como frações\n"
"binárias (base 2). Esta é a principal razão por que Python (ou Perl, C, C+"
"+,\n"
"Java, Fortran, e muitas outras) frequentemente não exibe o número decimal\n"
"exato que esperamos::"

#: ../../tutorial/floatingpoint.rst:164
msgid ""
"Why is that?  1/10 and 2/10 are not exactly representable as a binary "
"fraction. Almost all machines today (July 2010) use IEEE-754 floating point "
"arithmetic, and almost all platforms map Python floats to IEEE-754 \"double "
"precision\".  754 doubles contain 53 bits of precision, so on input the "
"computer strives to convert 0.1 to the closest fraction it can of the form "
"*J*/2**\\ *N* where *J* is an integer containing exactly 53 bits.  "
"Rewriting ::"
msgstr ""
"Por que isso acontece? 1/10 e 2/10 não são representáveis exatamente ​​como\n"
"frações binárias. Quase todas as máquinas atuais (julho de 2010) usam\n"
"aritmética de ponto flutuante conforme a norma IEEE-754, e Python, em quase\n"
"todas as plataformas, representa um float como um \"IEEE-754 double "
"precision\n"
"float\" (\"float de precisão dupla IEEE-754\"). Os tais \"doubles IEEE-754\" "
"têm 53\n"
"bits de precisão, por isso na entrada o computador se esforça para "
"converter\n"
"0.1 para a fração mais próxima que pode, na forma *J*/2**\\ *N* onde *J* é "
"um\n"
"número inteiro contendo exatamente 53 bits. Reescrevendo::"

#: ../../tutorial/floatingpoint.rst:173
msgid "as ::"
msgstr "como ::"

#: ../../tutorial/floatingpoint.rst:177
msgid ""
"and recalling that *J* has exactly 53 bits (is ``>= 2**52`` but ``< "
"2**53``), the best value for *N* is 56::"
msgstr ""
"e recordando que *J* tem exatamente 53 bits (é ``>= 2**52``, mas ``< "
"2**53``),\n"
"o melhor valor para *N* é 56::"

#: ../../tutorial/floatingpoint.rst:187
msgid ""
"That is, 56 is the only value for *N* that leaves *J* with exactly 53 bits. "
"The best possible value for *J* is then that quotient rounded::"
msgstr ""
"Ou seja, 56 é o único valor de *N* que deixa *J* com exatamente 53 bits.\n"
"O melhor valor possível para *J* então é aquele quociente arredondado::"

#: ../../tutorial/floatingpoint.rst:194
msgid ""
"Since the remainder is more than half of 10, the best approximation is "
"obtained by rounding up::"
msgstr ""
"Uma vez que o resto é maior que a metade de 10, a melhor aproximação é "
"obtida\n"
"arredondando para cima::"

#: ../../tutorial/floatingpoint.rst:200
msgid ""
"Therefore the best possible approximation to 1/10 in 754 double precision is "
"that over 2\\*\\*56, or ::"
msgstr ""
"Portanto, a melhor aproximação possível de 1/10 como um \"IEEE-754 double\n"
"precision\" é aquele valor dividido por 2\\*\\* 56, ou::"

#: ../../tutorial/floatingpoint.rst:205
msgid ""
"Note that since we rounded up, this is actually a little bit larger than "
"1/10; if we had not rounded up, the quotient would have been a little bit "
"smaller than 1/10.  But in no case can it be *exactly* 1/10!"
msgstr ""
"Note que, como arredondamos para cima, esse valor é de fato um pouco maior "
"que\n"
"1/10; se não tivéssemos arredondado para cima, o quociente teria sido um "
"pouco\n"
"menor que 1/10. Mas em nenhum caso ele pode ser *exatamente* 1/10!"

#: ../../tutorial/floatingpoint.rst:209
msgid ""
"So the computer never \"sees\" 1/10:  what it sees is the exact fraction "
"given above, the best 754 double approximation it can get::"
msgstr ""
"Por isso, o computador nunca \"vê\" 1/10: o que ele vê é exatamente a "
"fração\n"
"dada acima, a melhor aproximação \"IEEE-754 double\" possível::"

#: ../../tutorial/floatingpoint.rst:215
msgid ""
"If we multiply that fraction by 10\\*\\*30, we can see the (truncated) value "
"of its 30 most significant decimal digits::"
msgstr ""
"Se multiplicarmos essa fração por 10\\*\\*30, podemos ver o valor (truncado) "
"de\n"
"seus 30 dígitos mais significativos::"

#: ../../tutorial/floatingpoint.rst:221
msgid ""
"meaning that the exact number stored in the computer is approximately equal "
"to the decimal value 0.100000000000000005551115123125.  In versions prior to "
"Python 2.7 and Python 3.1, Python rounded this value to 17 significant "
"digits, giving '0.10000000000000001'.  In current versions, Python displays "
"a value based on the shortest decimal fraction that rounds correctly back to "
"the true binary value, resulting simply in '0.1'."
msgstr ""
"o que significa que o número exato armazenados no computador é "
"aproximadamente\n"
"igual ao o valor decimal 0.100000000000000005551115123125. Em versões de\n"
"Python anteriores a 2.7 e 3.1, Python exibia esse valor arredondado para 17\n"
"dígitos significativos, produzindo '0.10000000000000001'. Nas versões "
"atuais,\n"
"Python exibe a fração decimal mais curta que pode ser convertida para o\n"
"verdadeiro valor binário, o que resulta simplesmente em '0.1'."
