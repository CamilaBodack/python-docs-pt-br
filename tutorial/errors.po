# SOME DESCRIPTIVE TITLE.
# Copyright (C) 1990-2020, Python Software Foundation
# This file is distributed under the same license as the Python package.
#
# Translators:
# Claudio Rogerio Carvalho Filho <excriptbrasil@gmail.com>, 2017
msgid ""
msgstr ""
"Project-Id-Version: Python 2.7\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2020-02-09 18:46+0900\n"
"PO-Revision-Date: 2019-09-01 05:18+0000\n"
"Last-Translator: Adorilson Bezerra <adorilson@gmail.com>\n"
"Language-Team: Portuguese (Brazil) (http://www.transifex.com/python-doc/python-27/language/pt_BR/)\n"
"Language: pt_BR\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=2; plural=(n > 1);\n"

#: ../../tutorial/errors.rst:5
msgid "Errors and Exceptions"
msgstr "Erros e Exceções"

#: ../../tutorial/errors.rst:7
msgid ""
"Until now error messages haven't been more than mentioned, but if you have "
"tried out the examples you have probably seen some.  There are (at least) "
"two distinguishable kinds of errors: *syntax errors* and *exceptions*."
msgstr ""
"Até agora mensagens de erro foram apenas mencionadas, mas se você tentou "
"aplicar algum dos exemplos você provavelmente deve ter visto algumas. "
"Existem (pelo menos) dois tipos distintos de erros: *erros de sintaxe*  e "
"*exceções*."

#: ../../tutorial/errors.rst:15
msgid "Syntax Errors"
msgstr "Erros de Sintaxe"

#: ../../tutorial/errors.rst:17
msgid ""
"Syntax errors, also known as parsing errors, are perhaps the most common "
"kind of complaint you get while you are still learning Python::"
msgstr ""
"Erros de sintaxe, também conhecido como erros de análise, são provavelmente "
"o tipo mais recorrente de problema que você deverá encontrar enquanto "
"estiver aprendendo Python::"

#: ../../tutorial/errors.rst:26
msgid ""
"The parser repeats the offending line and displays a little 'arrow' pointing"
" at the earliest point in the line where the error was detected.  The error "
"is caused by (or at least detected at) the token *preceding* the arrow: in "
"the example, the error is detected at the keyword :keyword:`print`, since a "
"colon (``':'``) is missing before it.  File name and line number are printed"
" so you know where to look in case the input came from a script."
msgstr ""
"O parser repete a linha inválida e apresenta uma pequena 'seta' apontando para\n"
"o ponto da linha em que o erro foi encontrado. O erro é causado (ou ao menos\n"
"detectado) pelo token que *precede* a seta: no exemplo, o erro foi detectado\n"
"na palavra reservada :keyword:`print`, uma vez que o dois-pontos (``':'``)\n"
"está faltando antes dela. O nome de arquivo e número de linha são exibidos\n"
"para que você possa rastrear o erro no texto do script."

#: ../../tutorial/errors.rst:37
msgid "Exceptions"
msgstr "Exceções"

#: ../../tutorial/errors.rst:39
msgid ""
"Even if a statement or expression is syntactically correct, it may cause an "
"error when an attempt is made to execute it. Errors detected during "
"execution are called *exceptions* and are not unconditionally fatal: you "
"will soon learn how to handle them in Python programs.  Most exceptions are "
"not handled by programs, however, and result in error messages as shown "
"here::"
msgstr ""
"Mesmo quando uma declaração ou uma expressão está sintaticamente correta, "
"ela pode causar um erro quando for executada. Erros detectados durante "
"execuções são chamados *exceções* e não são incondicionalmente fatais: você "
"logo irá aprender a lidar com eles nos seus programas Python. No entanto, a "
"maior parte das exceções não são lidadas por programas e resultam em "
"mensagens de erro como mostradas a seguir::"

#: ../../tutorial/errors.rst:58
msgid ""
"The last line of the error message indicates what happened. Exceptions come "
"in different types, and the type is printed as part of the message: the "
"types in the example are :exc:`ZeroDivisionError`, :exc:`NameError` and "
":exc:`TypeError`. The string printed as the exception type is the name of "
"the built-in exception that occurred.  This is true for all built-in "
"exceptions, but need not be true for user-defined exceptions (although it is"
" a useful convention). Standard exception names are built-in identifiers "
"(not reserved keywords)."
msgstr ""
"A última linha da mensagem de erro mostra o que aconteceu. Exceções possuem "
"diferentes tipos e o tipo é mostrado como parte da mensagem: os tipos que "
"aparecem no exemplo são :exc:`ZeroDivisionError`, :exc:`NameError` e "
":exc:`TypeError`. A string que é mostrada como o tipo de exceção é o nome da"
" exceção que ocorreu. Isso deve acontecer em todas as exceções padrão, mas "
"não acontecem em exceções definidas pelo usuário (apesar de ser uma "
"convenção útil). Nomes padrões de exceção são identificadores padrão (mas "
"não palavras-chave reservadas)."

#: ../../tutorial/errors.rst:66
msgid ""
"The rest of the line provides detail based on the type of exception and what"
" caused it."
msgstr ""
"O resto da linha apresenta detalhes baseado no tipo de exceção e o que a "
"causou."

#: ../../tutorial/errors.rst:69
msgid ""
"The preceding part of the error message shows the context where the "
"exception happened, in the form of a stack traceback. In general it contains"
" a stack traceback listing source lines; however, it will not display lines "
"read from standard input."
msgstr ""
"A parte anterior à mensagem de erro mostra o contexto em que a exceção "
"aconteceu, na forma de um traceback (situação da pilha de execução). Em "
"geral ele contém um traceback listando as linhas de origem"

#: ../../tutorial/errors.rst:74
msgid ""
":ref:`bltin-exceptions` lists the built-in exceptions and their meanings."
msgstr ":ref:`Exceções` lista as exceções padrão e seus significados."

#: ../../tutorial/errors.rst:80
msgid "Handling Exceptions"
msgstr "Lidando com Exceções"

#: ../../tutorial/errors.rst:82
msgid ""
"It is possible to write programs that handle selected exceptions. Look at "
"the following example, which asks the user for input until a valid integer "
"has been entered, but allows the user to interrupt the program (using "
":kbd:`Control-C` or whatever the operating system supports); note that a "
"user-generated interruption is signalled by raising the "
":exc:`KeyboardInterrupt` exception. ::"
msgstr ""
"É possível escrever programas que lidam com exceções selecionadas. Olhe o "
"exemplo a seguir, que pede para que o usuário insira uma entrada até que um "
"inteiro válido tenha sido inserido, mas permite que o usuário interrompa o "
"programa (usando :kbd:`Control-C` ou qualquer comando que o sistema "
"operacional suporte); note que uma interrupção gerada por um usuário é "
"sinalizada por uma exceção lançada como :exc:`KeyboardInterrupt` exception. "
"::"

#: ../../tutorial/errors.rst:96
msgid "The :keyword:`try` statement works as follows."
msgstr "A declaração :keyword:`try` funciona como descrito a seguir."

#: ../../tutorial/errors.rst:98
msgid ""
"First, the *try clause* (the statement(s) between the :keyword:`try` and "
":keyword:`except` keywords) is executed."
msgstr ""
"Primeiramente, a *cláusula do try* (a(s) instrução(ões) dadas entre a "
"palavra reservada : keyword:`try` e a :keyword:`except`) é executada."

#: ../../tutorial/errors.rst:101
msgid ""
"If no exception occurs, the *except clause* is skipped and execution of the "
":keyword:`try` statement is finished."
msgstr ""
"Se nenhuma exceção ocorrer, a *cláusula except* é ignorada e a execução da "
"declaração :keyword:`try` é finalizada."

#: ../../tutorial/errors.rst:104
msgid ""
"If an exception occurs during execution of the try clause, the rest of the "
"clause is skipped.  Then if its type matches the exception named after the "
":keyword:`except` keyword, the except clause is executed, and then execution"
" continues after the :keyword:`try` statement."
msgstr ""
"Se uma exceção ocorre durante a execução de uma cláusula do try, o resto da "
"cláusula é ignorado. Se o erro levantado corresponde à exceção determinada "
"depois da palavra reservada :keyword:`except` , a cláusula de exceção é "
"executada e a execução continua após a instrução do :keyword:`try`."

#: ../../tutorial/errors.rst:109
msgid ""
"If an exception occurs which does not match the exception named in the "
"except clause, it is passed on to outer :keyword:`try` statements; if no "
"handler is found, it is an *unhandled exception* and execution stops with a "
"message as shown above."
msgstr ""
"Se uma exceção ocorrer que não corresponder à uma exceção chamada na "
"cláusula except, ela é passada adiante para outras instruções "
":keyword:`try`; se nenhum tratamento para aquela exceção for encontrado, ela"
" é uma *unhandled exception* e a execução é interrompida com uma mensagem "
"conforme mostrado acima."

#: ../../tutorial/errors.rst:114
msgid ""
"A :keyword:`try` statement may have more than one except clause, to specify "
"handlers for different exceptions.  At most one handler will be executed. "
"Handlers only handle exceptions that occur in the corresponding try clause, "
"not in other handlers of the same :keyword:`try` statement.  An except "
"clause may name multiple exceptions as a parenthesized tuple, for example::"
msgstr ""
"A instrução :keyword:`try` pode ter mais de uma cláusula :keyword:`except`\n"
"para especificar múltiplos tratadores para diferentes exceções. No máximo um\n"
"único tratador será ativado. Tratadores só são sensíveis às exceções\n"
"levantadas no interior da cláusula try, e não às que tenham ocorrido no\n"
"interior de outro tratador numa mesma instrução :keyword:`try`. Um tratador\n"
"pode ser sensível a múltiplas exceções, desde que as especifique em uma\n"
"tupla::"

#: ../../tutorial/errors.rst:123
msgid ""
"Note that the parentheses around this tuple are required, because ``except "
"ValueError, e:`` was the syntax used for what is normally written as "
"``except ValueError as e:`` in modern Python (described below). The old "
"syntax is still supported for backwards compatibility. This means ``except "
"RuntimeError, TypeError`` is not equivalent to ``except (RuntimeError, "
"TypeError):`` but to ``except RuntimeError as TypeError:`` which is not what"
" you want."
msgstr ""

#: ../../tutorial/errors.rst:131
msgid ""
"The last except clause may omit the exception name(s), to serve as a "
"wildcard. Use this with extreme caution, since it is easy to mask a real "
"programming error in this way!  It can also be used to print an error "
"message and then re-raise the exception (allowing a caller to handle the "
"exception as well)::"
msgstr ""
"A última cláusula :keyword:`except` pode omitir o nome da exceção, funcionando\n"
"como um curinga. Utilize esse recurso com extrema cautela, uma vez que isso\n"
"pode esconder erros do programador e do usuário! Também pode ser utilizado\n"
"para exibir uma mensagem de erro e então re-levantar a exceção (permitindo que\n"
"o invocador da função atual também possa tratá-la). ::"

#: ../../tutorial/errors.rst:150
msgid ""
"The :keyword:`try` ... :keyword:`except` statement has an optional *else "
"clause*, which, when present, must follow all except clauses.  It is useful "
"for code that must be executed if the try clause does not raise an "
"exception.  For example::"
msgstr ""
"A construção :keyword:`try` ... :keyword:`except` possui uma *cláusula else*\n"
"opcional, que quando presente, deve ser colocada depois de todas as outras\n"
"cláusulas. É útil para um código que precisa ser executado se nenhuma exceção\n"
"foi levantada. Por exemplo::"

#: ../../tutorial/errors.rst:164
msgid ""
"The use of the :keyword:`else` clause is better than adding additional code "
"to the :keyword:`try` clause because it avoids accidentally catching an "
"exception that wasn't raised by the code being protected by the "
":keyword:`try` ... :keyword:`except` statement."
msgstr ""
"Esse recurso é melhor do que simplesmente adicionar o código da cláusula\n"
":keyword:`else` ao corpo da cláusula :keyword:`try`, pois mantém as exceções\n"
"levantadas no :keyword:`else` num escopo diferente de tratamento das exceções\n"
"levantadas na cláusula :keyword:`try`, evitando que acidentalmente seja\n"
"tratada uma exceção que não foi levantada pelo código protegido pela\n"
"construção :keyword:`try` ... :keyword:`except`."

#: ../../tutorial/errors.rst:169
msgid ""
"When an exception occurs, it may have an associated value, also known as the"
" exception's *argument*. The presence and type of the argument depend on the"
" exception type."
msgstr ""
"Quando uma exceção ocorre, ela pode estar associada a um valor chamado\n"
"*argumento* da exceção. A presença e o tipo do argumento dependem do tipo da\n"
"exceção."

#: ../../tutorial/errors.rst:173
msgid ""
"The except clause may specify a variable after the exception name (or "
"tuple). The variable is bound to an exception instance with the arguments "
"stored in ``instance.args``.  For convenience, the exception instance "
"defines :meth:`__str__` so the arguments can be printed directly without "
"having to reference ``.args``."
msgstr ""
"A cláusula except pode especificar uma variável depois do nome (ou da tupla de\n"
"nomes) da exceção. A variável é associada à instância de exceção capturada,\n"
"com os argumentos armazenados em ``instancia.args``. Por conveniência, a\n"
"instância define o método :meth:`__str__` para que os argumentos possam ser\n"
"exibidos diretamente sem necessidade de acessar ``.args``."

#: ../../tutorial/errors.rst:179
msgid ""
"One may also instantiate an exception first before raising it and add any "
"attributes to it as desired. ::"
msgstr ""
"Pode-se também instanciar uma exceção antes de levantá-la e adicionar qualquer\n"
"atributo a ela, conforme desejado. ::"

#: ../../tutorial/errors.rst:198
msgid ""
"If an exception has an argument, it is printed as the last part ('detail') "
"of the message for unhandled exceptions."
msgstr ""
"Se uma exceção possui argumento, ele é exibido ao final ('detalhe') da\n"
"mensagem de exceções não tratadas."

#: ../../tutorial/errors.rst:201
msgid ""
"Exception handlers don't just handle exceptions if they occur immediately in"
" the try clause, but also if they occur inside functions that are called "
"(even indirectly) in the try clause. For example::"
msgstr ""
"Além disso, tratadores de exceção são capazes de capturar exceções que tenham\n"
"sido levantadas no interior de funções invocadas (mesmo que indiretamente) na\n"
"cláusula try. Por exemplo::"

#: ../../tutorial/errors.rst:219
msgid "Raising Exceptions"
msgstr "Levantando exceções"

#: ../../tutorial/errors.rst:221
msgid ""
"The :keyword:`raise` statement allows the programmer to force a specified "
"exception to occur. For example::"
msgstr ""
"A instrução :keyword:`raise` permite ao programador forçar a ocorrência de um\n"
"determinado tipo de exceção. Por exemplo::"

#: ../../tutorial/errors.rst:229
msgid ""
"The sole argument to :keyword:`raise` indicates the exception to be raised. "
"This must be either an exception instance or an exception class (a class "
"that derives from :class:`Exception`)."
msgstr ""
"O argumento de :keyword:`raise` indica a exceção a ser levantada. Esse\n"
"argumento deve ser uma instância de exceção ou uma classe de exceção (uma\n"
"classe que deriva de :class:`Exception`)"

#: ../../tutorial/errors.rst:233
msgid ""
"If you need to determine whether an exception was raised but don't intend to"
" handle it, a simpler form of the :keyword:`raise` statement allows you to "
"re-raise the exception::"
msgstr ""
"Caso você precise determinar se uma exceção foi levantada ou não, mas não quer\n"
"manipular o erro, uma forma simples de instrução :keyword:`raise` permite que\n"
"você levante-a novamente::"

#: ../../tutorial/errors.rst:252
msgid "User-defined Exceptions"
msgstr "Exceções definidas pelo usuário"

#: ../../tutorial/errors.rst:254
msgid ""
"Programs may name their own exceptions by creating a new exception class "
"(see :ref:`tut-classes` for more about Python classes).  Exceptions should "
"typically be derived from the :exc:`Exception` class, either directly or "
"indirectly.  For example::"
msgstr ""
"Programas podem definir novos tipos de exceções, através da criação de uma\n"
"nova classe (veja :ref:`tut-classes` para mais informações sobre classes\n"
"Python). Exceções devem ser derivadas da classe :exc:`Exception`, direta ou\n"
"indiretamente. Por exemplo::"

#: ../../tutorial/errors.rst:276
msgid ""
"In this example, the default :meth:`__init__` of :class:`Exception` has been"
" overridden.  The new behavior simply creates the *value* attribute.  This "
"replaces the default behavior of creating the *args* attribute."
msgstr ""
"Neste exemplo, o método padrão :meth:`__init__` da classe :class:`Exception`\n"
"foi redefinido. O novo comportamento simplesmente cria o atributo *valor*.\n"
"Isso substitui o comportamento padrão de criar o atributo *args*."

#: ../../tutorial/errors.rst:280
msgid ""
"Exception classes can be defined which do anything any other class can do, "
"but are usually kept simple, often only offering a number of attributes that"
" allow information about the error to be extracted by handlers for the "
"exception.  When creating a module that can raise several distinct errors, a"
" common practice is to create a base class for exceptions defined by that "
"module, and subclass that to create specific exception classes for different"
" error conditions::"
msgstr ""
"Classes de exceções podem ser definidas para fazer qualquer coisa que\n"
"qualquer outra classe faz, mas em geral são bem simples, frequentemente\n"
"oferecendo apenas alguns atributos que fornecem informações sobre o erro que\n"
"ocorreu. Ao criar um módulo que pode gerar diversos erros, uma prática comum é\n"
"criar uma classe base para as exceções definidas por aquele módulo, e as\n"
"classes específicas para cada condição de erro como subclasses dela::"

#: ../../tutorial/errors.rst:318
msgid ""
"Most exceptions are defined with names that end in \"Error\", similar to the"
" naming of the standard exceptions."
msgstr ""
"É comum que novas exceções sejam definidas com nomes terminando em "
"\"Error\", semelhante a muitas exceções embutidas."

#: ../../tutorial/errors.rst:321
msgid ""
"Many standard modules define their own exceptions to report errors that may "
"occur in functions they define.  More information on classes is presented in"
" chapter :ref:`tut-classes`."
msgstr ""
"Muitos módulos padrão definem novas exceções para reportar erros que ocorrem\n"
"no interior das funções que definem. Mais informações sobre classes aparecem\n"
"no capítulo :ref:`tut-classes`."

#: ../../tutorial/errors.rst:329
msgid "Defining Clean-up Actions"
msgstr "Definindo ações de limpeza"

#: ../../tutorial/errors.rst:331
msgid ""
"The :keyword:`try` statement has another optional clause which is intended "
"to define clean-up actions that must be executed under all circumstances.  "
"For example::"
msgstr ""
"A instrução :keyword:`try` possui outra cláusula opcional, cuja finalidade é\n"
"permitir a implementação de ações de limpeza, que sempre devem ser executadas\n"
"independentemente da ocorrência de exceções. Como no exemplo::"

#: ../../tutorial/errors.rst:345
msgid ""
"A *finally clause* is always executed before leaving the :keyword:`try` "
"statement, whether an exception has occurred or not. When an exception has "
"occurred in the :keyword:`try` clause and has not been handled by an "
":keyword:`except` clause (or it has occurred in an :keyword:`except` or "
":keyword:`else` clause), it is re-raised after the :keyword:`finally` clause"
" has been executed.  The :keyword:`finally` clause is also executed \"on the"
" way out\" when any other clause of the :keyword:`try` statement is left via"
" a :keyword:`break`, :keyword:`continue` or :keyword:`return` statement.  A "
"more complicated example (having :keyword:`except` and :keyword:`finally` "
"clauses in the same :keyword:`try` statement works as of Python 2.5)::"
msgstr ""
"Uma *cláusula finally* é sempre executada, ocorrendo ou não uma exceção.\n"
"Quando ocorre uma exceção na cláusula :keyword:`try` e ela não é tratada por\n"
"uma cláusula :keyword:`except` (ou quando ocorre em cláusulas\n"
":keyword:`except` ou :keyword:`else`), ela é re-levantada depois que a\n"
"cláusula :keyword:`finally` é executada. A cláusula :keyword:`finally` é\n"
"executada \"na saída\" quando qualquer outra cláusula da instrução\n"
":keyword:`try` é finalizada, mesmo que seja por meio de qualquer uma das\n"
"instruções :keyword:`break`, :keyword:`continue` ou :keyword:`return`. Um\n"
"exemplo mais completo::"

#: ../../tutorial/errors.rst:379
msgid ""
"As you can see, the :keyword:`finally` clause is executed in any event.  The"
" :exc:`TypeError` raised by dividing two strings is not handled by the "
":keyword:`except` clause and therefore re-raised after the "
":keyword:`finally` clause has been executed."
msgstr ""
"Como você pode ver, a cláusula :keyword:`finally` é executado em todos os\n"
"casos. A exceção :exc:`TypeError` levantada pela divisão de duas strings não é\n"
"tratada pela cláusula :keyword:`except` e portanto é re-levantada depois que a\n"
"cláusula :keyword:`finally` é executada."

#: ../../tutorial/errors.rst:384
msgid ""
"In real world applications, the :keyword:`finally` clause is useful for "
"releasing external resources (such as files or network connections), "
"regardless of whether the use of the resource was successful."
msgstr ""
"Em aplicação do mundo real, a cláusula :keyword:`finally` é útil para liberar\n"
"recursos externos (como arquivos ou conexões de rede), independentemente do\n"
"uso do recurso ter sido bem sucedido ou não."

#: ../../tutorial/errors.rst:392
msgid "Predefined Clean-up Actions"
msgstr "Ações de limpeza predefinidas"

#: ../../tutorial/errors.rst:394
msgid ""
"Some objects define standard clean-up actions to be undertaken when the "
"object is no longer needed, regardless of whether or not the operation using"
" the object succeeded or failed. Look at the following example, which tries "
"to open a file and print its contents to the screen. ::"
msgstr ""
"Alguns objetos definem ações de limpeza padrões para serem executadas quando o\n"
"objeto não é mais necessário, independentemente da operação que estava usando\n"
"o objeto ter sido ou não bem sucedida. Veja o exemplo a seguir, que tenta\n"
"abrir um arquivo e exibir seu conteúdo na tela. ::"

#: ../../tutorial/errors.rst:402
msgid ""
"The problem with this code is that it leaves the file open for an "
"indeterminate amount of time after the code has finished executing. This is "
"not an issue in simple scripts, but can be a problem for larger "
"applications. The :keyword:`with` statement allows objects like files to be "
"used in a way that ensures they are always cleaned up promptly and "
"correctly. ::"
msgstr ""
"O problema com esse código é que ele deixa o arquivo aberto um período\n"
"indeterminado depois que o código é executado. Isso não chega a ser problema\n"
"em scripts simples, mas pode ser um problema para grandes aplicações. A\n"
"palavra reservada :keyword:`with` permite que objetos como arquivos sejam\n"
"utilizados com a certeza de que sempre serão prontamente e corretamente\n"
"finalizados. ::"

#: ../../tutorial/errors.rst:412
msgid ""
"After the statement is executed, the file *f* is always closed, even if a "
"problem was encountered while processing the lines. Other objects which "
"provide predefined clean-up actions will indicate this in their "
"documentation."
msgstr ""
"Depois que a instrução é executada, o arquivo *a* é sempre fechado, mesmo se\n"
"ocorrer um problema durante o processamento das linhas. Outros objetos que\n"
"fornecem ações de limpeza predefinidas as indicarão em suas documentações."
